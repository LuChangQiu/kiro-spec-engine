# 核心开发原则（基准规则）

> **重要**: 这些是项目的基准规则，适用于所有 Spec，不应随意修改。
> 场景特定的规则请参考 `CURRENT_CONTEXT.md`

---

## 📋 Spec 驱动开发工作流程

### Spec 命名规范

**格式**: `{序号}-{序号}-{简短描述}`

**规则**:
- 使用 kebab-case（小写字母，单词用连字符分隔）
- 必须包含两个序号（用连字符分隔）
- 描述应简洁明确，反映 Spec 核心目标

**示例**:
- ✅ `01-00-user-space-diagnosis`
- ✅ `01-01-fix-duplicate-file-space-calculation`
- ✅ `02-00-oauth-api-upgrade`
- ❌ `user-space-diagnosis`（缺少序号）
- ❌ `01-user-space-diagnosis`（只有一个序号）
- ❌ `FixDuplicateFile`（不是 kebab-case）
- ❌ `fix_duplicate_file`（使用下划线而非连字符）

### 标准工作流程

```
1. 创建 Spec → 2. requirements.md → 3. design.md → 4. tasks.md → 5. 执行任务 → 6. 产物归档
```

### Spec 目录结构

```
.kiro/specs/{feature-name}/
├── requirements.md, design.md, tasks.md
├── scripts/, reports/, diagnostics/, tests/, results/
```

---

## ⚠️ 核心原则

### 1. Spec 驱动开发原则

**任何需求都必须先建立 Spec**
- 所有产物归档到 Spec 目录：scripts/, reports/, diagnostics/, tests/, results/
- 禁止将脚本、测试直接放到项目根目录

### 2. 文件管理原则

**禁止在根目录下随意生成临时文件**
- 临时文件用完立即删除
- 所有产物归档到对应的 Spec 目录

### 3. 代码质量原则

- 代码必须能够编译通过
- 修改后必须运行相关测试
- 遵循项目的编码规范

### 4. 🔥 Ultrawork 原则(借鉴 Sisyphus 精神)

**核心理念**: 像西西弗斯推石上山一样,永不放弃,不懈努力,直到任务完美完成

#### 执行标准
- **专业级质量**: 每个阶段追求生产级标准,不满足于"差不多"
- **不懈努力**: 遇到困难持续尝试解决方案,不轻易放弃或求助用户
- **完整交付**: 确保输出完整、准确、可用,达到专业水准

#### 各阶段 Ultrawork 要求
- **Requirements 阶段**: 像资深产品经理一样深入思考每个用户场景,考虑边界条件、异常情况、安全性、性能等各个方面
- **Design 阶段**: 像资深架构师一样设计每个组件,确保架构优雅、可扩展、易维护,考虑技术可行性和最佳实践
- **Tasks 阶段**: 像资深开发者一样实现每行代码,确保代码质量、测试覆盖、文档完整

#### 困难处理的 Ultrawork 精神
- **编译错误** → 仔细分析错误信息,理解根本原因,持续修复直到通过
- **逻辑问题** → 重新审视需求和设计,优化方案,不断迭代直到正确
- **技术难题** → 换个思路和角度,查阅资料,寻找最佳实践,持续突破
- **卡住不动** → 分解问题,从不同维度尝试,绝不轻易放弃
- **永不轻易转移责任给用户,而是主动承担和解决问题**

#### Ultrawork 质量标准
- **Requirements**: 覆盖所有场景,验收标准清晰可测试,考虑非功能需求
- **Design**: 架构合理,组件职责清晰,技术方案可行,有完整的双向追溯
- **Tasks**: 代码编译通过,测试全部通过,文档完整,符合最佳实践

### 5. 问题解决态度

**但凡有问题没有解决，一定是我搞错了**
- 不要轻易得出"这是外部服务的问题"的结论
- 必须继续找原因，直到最终修正
- 体现 Ultrawork 精神:���不放弃,持续推进

### 6. 问题解决流程

遇到问题时的检查顺序：
1. `.kiro/specs/` 中相关功能的文档
2. `.kiro/steering/` 中的规则
3. 项目根目录下的分析文档

### 6. 上下文管控原则

**必须主动管控上下文，避免 session token 耗尽**

**管控时机**：
- 每完成一组任务后：精简已完成任务的详细内容
- 每完成一个阶段后：更新 CURRENT_CONTEXT.md
- Token 使用率 > 50% 时：立即精简
- 阶段切换时：更新 CURRENT_CONTEXT.md 聚焦新阶段

**精简规则**：
- Spec 文档：保留任务标题和状态，删除详细实现步骤
- CURRENT_CONTEXT.md：只保留当前任务核心信息，删除历史详细数据

### 7. Spec 完成与 Steering 更新原则

**每完成一个 Spec，开始新 Spec 前，必须评估是否需要更新 Steering**
- 通用经验教训 → 更新 CORE_PRINCIPLES
- 当前 Spec 场景 → 更新 CURRENT_CONTEXT

### 8. 文档精简原则

**Spec 文档精简**：
- 已完成任务：保留标题和状态，删除详细实现
- 历史测试结果：保留结论，删除详细日志
- 文档 > 1000 行：立即拆分为多个文件

**Steering 文档精简**：
- CURRENT_CONTEXT.md 只保留当前 Spec 核心信息
- 历史数据归档到 Spec 目录
- Session 启动后 token 使用率 > 50%：立即精简

### 9. 数据原子性原则（Data Atomicity Principle）

**核心定义**：系统中的每一类数据应该有且仅有一个权威数据源（Single Source of Truth, SSOT）

**适用范围**：
- **配置数据** - 不应该有多个配置文件存储相同的信息
- **缓存数据** - 派生数据（视图、报表、字典）应该有唯一的缓存源
- **状态数据** - 系统状态应该集中管理，不分散存储

**设计要求**：
- 避免数据源多重性：同一信息不应存储在多个位置
- 保证更新原子性：相关数据的更新应该是原子操作
- 缓存数据原子性：派生数据应该从唯一源生成，不散列成多份
- 架构层面观察：从系统架构角度保证数据一致性，而非仅功能层面

**违反原则的后果**：
- 数据不一致风险
- 同步复杂度增加
- 事务性保证困难
- 维护成本上升

**实施指导**：
- 设计阶段：识别所有数据源，确保每类数据只有一个权威源
- 实现阶段：使用单一文件/表/缓存存储相关数据
- 更新操作：确保相关数据的更新是原子的（事务性）
- 缓存策略：所有缓存都从唯一数据源派生，不创建多份缓存

**示例**：
```javascript
// ❌ 错误：数据分散在多个文件
~/.kse/workspaces.json  - 存储工作区列表 + last_accessed
~/.kse/config.json      - 存储 active_workspace

// ✅ 正确：单一数据源
~/.kse/workspace-state.json  - 存储所有工作区相关数据
```

---

**版本**: v5.0  
**更新**: 2026-01-22  
**说明**: 适用于所有 Spec 的稳定核心原则
