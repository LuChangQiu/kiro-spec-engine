name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node-version: [16.x, 18.x, 20.x, 22.x]
        exclude:
          - os: macos-latest
            node-version: 16.x
          - os: macos-latest
            node-version: 18.x
          - os: macos-latest
            node-version: 20.x
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run tests
        run: npm test
      
      - name: Check coverage
        run: npm run coverage

  publish:
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20.x'
          registry-url: 'https://registry.npmjs.org'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci

      - name: Build release evidence notes
        id: release_notes
        shell: bash
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF_NAME}"
          RELEASE_DATE="$(date -u +%F)"
          NOTES_DIR=".kiro/reports/release-evidence"
          EVIDENCE_FILE="${NOTES_DIR}/handoff-runs.json"
          REVIEW_FILE="${NOTES_DIR}/handoff-evidence-review-${TAG}.md"
          DRAFT_FILE="${NOTES_DIR}/release-notes-${TAG}.md"
          FALLBACK_FILE="${NOTES_DIR}/release-notes-fallback-${TAG}.md"
          SUMMARY_FILE="${NOTES_DIR}/release-evidence-summary-${TAG}.json"
          GATE_FILE="${NOTES_DIR}/release-gate-${TAG}.json"
          HISTORY_FILE="${NOTES_DIR}/release-gate-history.json"
          HISTORY_SUMMARY_FILE="${NOTES_DIR}/release-gate-history-${TAG}.json"

          mkdir -p "${NOTES_DIR}"

          if [[ -f "${EVIDENCE_FILE}" ]]; then
            if node bin/kiro-spec-engine.js auto handoff evidence \
              --file "${EVIDENCE_FILE}" \
              --review-out "${REVIEW_FILE}" \
              --release-draft "${DRAFT_FILE}" \
              --release-version "${TAG}" \
              --release-date "${RELEASE_DATE}" \
              --json > "${SUMMARY_FILE}"; then
              if [[ -f "${DRAFT_FILE}" ]]; then
                echo "release_body_file=${DRAFT_FILE}" >> "$GITHUB_OUTPUT"
                echo "summary_file=${SUMMARY_FILE}" >> "$GITHUB_OUTPUT"
                echo "gate_file=${GATE_FILE}" >> "$GITHUB_OUTPUT"
                echo "evidence_used=true" >> "$GITHUB_OUTPUT"
                {
                  echo "asset_files<<EOF"
                  echo "${DRAFT_FILE}"
                  if [[ -f "${REVIEW_FILE}" ]]; then
                    echo "${REVIEW_FILE}"
                  fi
                  if [[ -f "${SUMMARY_FILE}" ]]; then
                    echo "${SUMMARY_FILE}"
                  fi
                  echo "${GATE_FILE}"
                  echo "${HISTORY_FILE}"
                  echo "${HISTORY_SUMMARY_FILE}"
                  echo "EOF"
                } >> "$GITHUB_OUTPUT"
                exit 0
              fi
            fi
          fi

          cat > "${FALLBACK_FILE}" <<EOF
          # Release ${TAG}

          Release date: ${RELEASE_DATE}

          See [CHANGELOG.md](https://github.com/${GITHUB_REPOSITORY}/blob/main/CHANGELOG.md) for details.
          EOF
          echo "release_body_file=${FALLBACK_FILE}" >> "$GITHUB_OUTPUT"
          echo "summary_file=" >> "$GITHUB_OUTPUT"
          echo "gate_file=${GATE_FILE}" >> "$GITHUB_OUTPUT"
          echo "evidence_used=false" >> "$GITHUB_OUTPUT"
          {
            echo "asset_files<<EOF"
            echo "${FALLBACK_FILE}"
            echo "${GATE_FILE}"
            echo "${HISTORY_FILE}"
            echo "${HISTORY_SUMMARY_FILE}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Evaluate release evidence gate
        shell: bash
        env:
          RELEASE_GATE_ENFORCE: ${{ vars.KSE_RELEASE_GATE_ENFORCE }}
          RELEASE_GATE_REQUIRE_EVIDENCE: ${{ vars.KSE_RELEASE_GATE_REQUIRE_EVIDENCE }}
          RELEASE_GATE_REQUIRE_GATE_PASS: ${{ vars.KSE_RELEASE_GATE_REQUIRE_GATE_PASS }}
          RELEASE_GATE_MIN_SPEC_SUCCESS_RATE: ${{ vars.KSE_RELEASE_GATE_MIN_SPEC_SUCCESS_RATE }}
          RELEASE_GATE_MAX_RISK_LEVEL: ${{ vars.KSE_RELEASE_GATE_MAX_RISK_LEVEL }}
          RELEASE_GATE_MAX_UNMAPPED_RULES: ${{ vars.KSE_RELEASE_GATE_MAX_UNMAPPED_RULES }}
          RELEASE_GATE_MAX_UNDECIDED_DECISIONS: ${{ vars.KSE_RELEASE_GATE_MAX_UNDECIDED_DECISIONS }}
          RELEASE_EVIDENCE_SUMMARY_FILE: ${{ steps.release_notes.outputs.summary_file }}
          RELEASE_EVIDENCE_USED: ${{ steps.release_notes.outputs.evidence_used }}
          RELEASE_GATE_REPORT_FILE: ${{ steps.release_notes.outputs.gate_file }}
        run: |
          set -euo pipefail
          node <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const configWarnings = [];

          function read(name, fallback = '') {
            const value = process.env[name];
            return value === undefined || value === null ? fallback : `${value}`.trim();
          }

          function parseBoolean(name, fallback) {
            const raw = read(name, '');
            if (!raw) return fallback;
            const lowered = raw.toLowerCase();
            if (['1', 'true', 'yes', 'y', 'on'].includes(lowered)) return true;
            if (['0', 'false', 'no', 'n', 'off'].includes(lowered)) return false;
            configWarnings.push(`invalid boolean ${name}=${raw}, fallback=${fallback}`);
            return fallback;
          }

          function parseNumber(name, fallback) {
            const raw = read(name, '');
            if (!raw) return fallback;
            const parsed = Number(raw);
            if (!Number.isFinite(parsed)) {
              configWarnings.push(`invalid number ${name}=${raw}, fallback=${fallback}`);
              return fallback;
            }
            return parsed;
          }

          function parseRiskLevel(name, fallback) {
            const raw = read(name, '').toLowerCase();
            if (!raw) return fallback;
            if (['low', 'medium', 'high', 'unknown'].includes(raw)) {
              return raw;
            }
            configWarnings.push(`invalid risk level ${name}=${raw}, fallback=${fallback}`);
            return fallback;
          }

          function riskRank(level) {
            const normalized = `${level || 'unknown'}`.trim().toLowerCase();
            const ranking = {
              low: 1,
              medium: 2,
              high: 3,
              unknown: 4
            };
            return ranking[normalized] || 5;
          }

          const enforce = parseBoolean('RELEASE_GATE_ENFORCE', false);
          const requireEvidence = parseBoolean('RELEASE_GATE_REQUIRE_EVIDENCE', false);
          const requireGatePass = parseBoolean('RELEASE_GATE_REQUIRE_GATE_PASS', true);
          const minSpecSuccessRate = parseNumber('RELEASE_GATE_MIN_SPEC_SUCCESS_RATE', 0);
          const maxRiskLevel = parseRiskLevel('RELEASE_GATE_MAX_RISK_LEVEL', 'unknown');
          const maxUnmappedRules = parseNumber('RELEASE_GATE_MAX_UNMAPPED_RULES', Number.POSITIVE_INFINITY);
          const maxUndecidedDecisions = parseNumber('RELEASE_GATE_MAX_UNDECIDED_DECISIONS', Number.POSITIVE_INFINITY);
          const evidenceUsed = parseBoolean('RELEASE_EVIDENCE_USED', false);
          const summaryFile = read('RELEASE_EVIDENCE_SUMMARY_FILE', '');
          const gateReportFile = read('RELEASE_GATE_REPORT_FILE', '');

          const violations = [];
          const signals = [];

          if (!summaryFile || !fs.existsSync(summaryFile)) {
            signals.push('summary=missing');
            if (requireEvidence) {
              violations.push('release evidence summary is required but missing');
            }
          } else {
            try {
              const raw = fs.readFileSync(summaryFile, 'utf8');
              const gatePayload = JSON.parse(raw);
              const currentOverview = gatePayload && gatePayload.current_overview && typeof gatePayload.current_overview === 'object'
                ? gatePayload.current_overview
                : {};
              const gate = currentOverview.gate && typeof currentOverview.gate === 'object'
                ? currentOverview.gate
                : {};
              const gateActual = gate.actual && typeof gate.actual === 'object'
                ? gate.actual
                : {};
              const ontology = currentOverview.ontology_validation && typeof currentOverview.ontology_validation === 'object'
                ? currentOverview.ontology_validation
                : {};
              const ontologyMetrics = ontology.metrics && typeof ontology.metrics === 'object'
                ? ontology.metrics
                : {};

              const gatePassed = gate.passed === true;
              const specSuccessRate = Number(gateActual.spec_success_rate_percent);
              const riskLevel = `${gateActual.risk_level || 'unknown'}`.toLowerCase();
              const unmappedRules = Number.isFinite(Number(gateActual.ontology_business_rule_unmapped))
                ? Number(gateActual.ontology_business_rule_unmapped)
                : Number(ontologyMetrics.business_rule_unmapped);
              const undecidedDecisions = Number.isFinite(Number(gateActual.ontology_decision_undecided))
                ? Number(gateActual.ontology_decision_undecided)
                : Number(ontologyMetrics.decision_undecided);

              signals.push(`summary=${summaryFile}`);
              signals.push(`gate_passed=${gatePassed}`);
              signals.push(`spec_success_rate=${Number.isFinite(specSuccessRate) ? specSuccessRate : 'n/a'}`);
              signals.push(`risk_level=${riskLevel || 'unknown'}`);
              signals.push(`unmapped_rules=${Number.isFinite(unmappedRules) ? unmappedRules : 'n/a'}`);
              signals.push(`undecided_decisions=${Number.isFinite(undecidedDecisions) ? undecidedDecisions : 'n/a'}`);

              if (requireGatePass && !gatePassed) {
                violations.push('handoff gate is not passed');
              }
              if (Number.isFinite(specSuccessRate) && specSuccessRate < minSpecSuccessRate) {
                violations.push(`spec success rate ${specSuccessRate} < min ${minSpecSuccessRate}`);
              }
              if (riskRank(riskLevel) > riskRank(maxRiskLevel)) {
                violations.push(`risk level ${riskLevel} exceeds max ${maxRiskLevel}`);
              }
              if (Number.isFinite(unmappedRules) && unmappedRules > maxUnmappedRules) {
                violations.push(`ontology unmapped rules ${unmappedRules} > max ${maxUnmappedRules}`);
              }
              if (Number.isFinite(undecidedDecisions) && undecidedDecisions > maxUndecidedDecisions) {
                violations.push(`ontology undecided decisions ${undecidedDecisions} > max ${maxUndecidedDecisions}`);
              }
            } catch (error) {
              signals.push(`summary=parse_error:${error.message}`);
              violations.push(`release evidence summary parse failed: ${error.message}`);
            }
          }

          const mode = enforce ? 'enforce' : 'advisory';
          const header = `[release-gate] mode=${mode} evidence_used=${evidenceUsed} require_evidence=${requireEvidence}`;
          console.log(header);
          signals.forEach((line) => console.log(`[release-gate] ${line}`));
          configWarnings.forEach((line) => console.log(`[release-gate] warning=${line}`));

          if (gateReportFile) {
            const reportPayload = {
              mode,
              enforce,
              evidence_used: evidenceUsed,
              require_evidence: requireEvidence,
              require_gate_pass: requireGatePass,
              thresholds: {
                min_spec_success_rate: minSpecSuccessRate,
                max_risk_level: maxRiskLevel,
                max_unmapped_rules: Number.isFinite(maxUnmappedRules) ? maxUnmappedRules : null,
                max_undecided_decisions: Number.isFinite(maxUndecidedDecisions) ? maxUndecidedDecisions : null
              },
              summary_file: summaryFile || null,
              config_warnings: configWarnings,
              signals,
              violations,
              gate_passed: violations.length === 0,
              evaluated_at: new Date().toISOString()
            };
            fs.mkdirSync(path.dirname(gateReportFile), { recursive: true });
            fs.writeFileSync(gateReportFile, `${JSON.stringify(reportPayload, null, 2)}\n`, 'utf8');
            console.log(`[release-gate] report_file=${gateReportFile}`);
          }

          const summaryPath = process.env.GITHUB_STEP_SUMMARY;
          if (summaryPath) {
            const lines = [
              '## Release Evidence Gate',
              '',
              `- mode: ${mode}`,
              `- evidence used: ${evidenceUsed}`,
              `- require evidence: ${requireEvidence}`,
              `- require gate pass: ${requireGatePass}`,
              `- min spec success rate: ${minSpecSuccessRate}`,
              `- max risk level: ${maxRiskLevel}`,
              `- max unmapped rules: ${Number.isFinite(maxUnmappedRules) ? maxUnmappedRules : 'inf'}`,
              `- max undecided decisions: ${Number.isFinite(maxUndecidedDecisions) ? maxUndecidedDecisions : 'inf'}`
            ];
            if (configWarnings.length > 0) {
              lines.push('', '### Config Warnings');
              for (const warning of configWarnings) {
                lines.push(`- ${warning}`);
              }
            }
            if (signals.length > 0) {
              lines.push('', '### Observed Signals');
              for (const signal of signals) {
                lines.push(`- ${signal}`);
              }
            }
            if (violations.length > 0) {
              lines.push('', '### Violations');
              for (const violation of violations) {
                lines.push(`- ${violation}`);
              }
            } else {
              lines.push('', '### Result');
              lines.push('- gate passed');
            }
            fs.appendFileSync(summaryPath, `${lines.join('\n')}\n`);
          }

          if (violations.length > 0) {
            const message = `[release-gate] violations: ${violations.join('; ')}`;
            if (enforce) {
              console.error(message);
              process.exit(1);
            }
            console.warn(`${message} (advisory only)`);
          }
          NODE

      - name: Build release gate history index
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF_NAME}"
          NOTES_DIR=".kiro/reports/release-evidence"
          HISTORY_FILE="${NOTES_DIR}/release-gate-history.json"
          HISTORY_SUMMARY_FILE="${NOTES_DIR}/release-gate-history-${TAG}.json"
          LATEST_RELEASE_FILE="${NOTES_DIR}/latest-release-${TAG}.json"
          LATEST_RELEASE_API="https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/latest"

          mkdir -p "${NOTES_DIR}"
          if curl -fsSL \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            "${LATEST_RELEASE_API}" \
            -o "${LATEST_RELEASE_FILE}"; then
            HISTORY_ASSET_URL="$(node -e "const fs=require('fs');const payload=JSON.parse(fs.readFileSync(process.argv[1],'utf8'));const assets=Array.isArray(payload.assets)?payload.assets:[];const hit=assets.find(item=>item&&item.name==='release-gate-history.json');if(hit&&hit.url){process.stdout.write(hit.url);}" "${LATEST_RELEASE_FILE}")"
            if [[ -n "${HISTORY_ASSET_URL}" ]]; then
              curl -fsSL \
                -H "Authorization: Bearer ${GITHUB_TOKEN}" \
                -H "Accept: application/octet-stream" \
                "${HISTORY_ASSET_URL}" \
                -o "${HISTORY_FILE}" || true
            fi
          fi
          rm -f "${LATEST_RELEASE_FILE}"

          if ! node bin/kiro-spec-engine.js auto handoff gate-index \
            --dir "${NOTES_DIR}" \
            --history-file "${HISTORY_FILE}" \
            --out "${HISTORY_FILE}" \
            --json > "${HISTORY_SUMMARY_FILE}"; then
            cat > "${HISTORY_SUMMARY_FILE}" <<EOF
            {
              "mode": "auto-handoff-release-gate-history",
              "error": "failed to build release gate history index"
            }
            EOF
            if [[ ! -f "${HISTORY_FILE}" ]]; then
              cat > "${HISTORY_FILE}" <<EOF
              {
                "mode": "auto-handoff-release-gate-history",
                "entries": []
              }
              EOF
            fi
          fi

      - name: Publish to npm
        run: npm publish --access public
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          body_path: ${{ steps.release_notes.outputs.release_body_file }}
          files: ${{ steps.release_notes.outputs.asset_files }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
