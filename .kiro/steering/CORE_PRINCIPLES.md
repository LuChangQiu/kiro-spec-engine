# 核心开发原则（基准规则）

> **重要**: 这些是项目的基准规则，适用于所有 Spec，不应随意修改。
> 场景特定的规则请参考 `CURRENT_CONTEXT.md`

---

## 📋 Spec 驱动开发

### 命名规范
**格式**: `{序号}-{序号}-{简短描述}` (kebab-case)

**示例**: ✅ `01-00-user-authentication` | ❌ `user-auth` (缺序号) | ❌ `UserAuth` (非kebab-case)

### 工作流程
```
创建 Spec → requirements.md → design.md → tasks.md → 执行任务 → 产物归档
```

### 目录结构
```
.kiro/specs/{feature-name}/
├── requirements.md, design.md, tasks.md
├── scripts/, reports/, diagnostics/, tests/, results/
```

---

## ⚠️ 核心原则

### 1. Spec 驱动开发
- 任何需求必须先建立 Spec
- 所有产物归档到 Spec 目录（scripts/, reports/, diagnostics/, tests/, results/）
- 禁止将脚本、测试直接放到项目根目录

### 2. 文件管理
**根目录**: 禁止随意生成临时文件，用完立即删除

**Steering 目录严格管控** ⚠️:
- 该目录所有文件在每个 session 自动加载
- 只能放置: CORE_PRINCIPLES.md, ENVIRONMENT.md, CURRENT_CONTEXT.md, RULES_GUIDE.md
- 禁止放置: 分析报告、历史数据、临时文件、详细文档
- 其他内容归档到: `.kiro/specs/` 或 `docs/`

### 3. 质量零容忍 ⚠️⚠️⚠️

**千里之堤溃于蚁穴 - 绝不忽视任何问题**

**代码质量**:
- 代码必须编译通过
- 修改后必须运行相关测试
- 遵循项目编码规范

**测试失败零容忍**:
- ❌ 绝对禁止: 忽视测试失败（即使看起来"无关"）
- ❌ 绝对禁止: 测试失败情况下发布版本
- ✅ 必须执行: 调查每个失败的根本原因
- ✅ 必须执行: 修复所有失败后才能继续
- ✅ 必须执行: 发布前运行完整测试套件

**避免重复测试** ⚠️:
- ❌ 禁止: Spec 执行过程中已运行测试，完成后再次运行全量测试
- ❌ 禁止: 文件保存时自动触发测试（如果刚执行完测试）
- ✅ 正确: 任务执行中运行测试验证，完成后直接总结，不重复测试
- ✅ 例外: 如果任务执行中未运行测试，完成时必须运行
- **原因**: 避免浪费时间和资源，提高开发效率
- **Kiro 特殊情况**: 文件保存时会触发 subagent，但如果刚执行完测试，应跳过重复测试

**为什么重要**: 测试是质量最后防线 | 小问题累积导致系统崩溃 | 忽视问题让修复成本指数级增长 | 重复测试浪费资源

### 4. Ultrawork 精神 🔥

**核心**: 像西西弗斯推石上山，永不放弃，直到任务完美完成

**执行标准**:
- 专业级质量: 追求生产级标准，不满足于"差不多"
- 不懈努力: 持续尝试解决方案，不轻易放弃或求助用户
- 完整交付: 确保输出完整、准确、可用

**各阶段要求**:
- Requirements: 深入思考场景，考虑边界、异常、安全、性能
- Design: 确保架构优雅、可扩展、易维护，符合最佳实践
- Tasks: 确保代码质量、测试覆盖、文档完整

**困难处理**:
- 编译错误 → 分析根因，持续修复
- 逻辑问题 → 重审需求，不断迭代
- 技术难题 → 换思路，查资料，持续突破
- 卡住不动 → 分解问题，多维尝试
- **永不轻易转移责任给用户**

**质量标准**:
- Requirements: 覆盖所有场景，验收标准清晰可测试
- Design: 架构合理，组件职责清晰，有完整双向追溯
- Tasks: 代码编译通过，测试全部通过，文档完整

### 4.1 完全自主执行权限 🚀

**授权范围**: 当项目已被 kse 接管（存在 `.kiro/` 目录和 `version.json`），AI 拥有完全自主执行权限

**自主执行原则**:
- ✅ 无需用户确认: 可以直接推进整个 Spec 的所有任务
- ✅ 自主决策: 可以自主选择实现方案、工具、技术栈
- ✅ 自主修复: 遇到问题时自主分析和修复，不中断流程
- ✅ 自主测试: 自主运行测试、分析结果、修复失败
- ✅ 自主优化: 发现问题时自主优化代码和设计

**执行策略**:
- 连续推进: 一次性完成多个相关任务，不中断询问
- 批量操作: 批量创建文件、批量修改、批量测试
- 智能跳过: 自动跳过可选任务（标记为 `*` 的任务）
- 错误恢复: 遇到错误时自动尝试多种修复方案

**用户交互时机**（仅在以下情况需要用户介入）:
- ❌ 遇到无法解决的致命错误（尝试多次后仍失败）
- ❌ 需要外部资源（API 密钥、数据库连接等）
- ❌ 需要重大架构决策（影响整个项目的设计变更）
- ❌ Spec 完全完成，需要用户验收

**禁止行为**:
- ❌ 每个任务都询问用户是否继续
- ❌ 每次修改文件都请求确认
- ❌ 遇到小问题就停下来求助
- ❌ 过度谨慎导致执行效率低下

**目标**: 让用户只需说"开始执行 Spec 22-00"，AI 就能自主完成所有任务，最后交付完整的功能

### 5. 上下文管控

**主动管控，避免 token 耗尽**

**管控时机**:
- 每完成一组任务 → 精简已完成任务详细内容
- 每完成一个阶段 → 更新 CURRENT_CONTEXT.md
- Token 使用率 > 50% → 立即精简
- 阶段切换 → 更新 CURRENT_CONTEXT.md 聚焦新阶段

**精简规则**:
- Spec 文档: 保留任务标题和状态，删除详细实现
- CURRENT_CONTEXT.md: 只保留当前任务核心信息
- 文档 > 1000 行: 立即拆分为多个文件
- 历史数据: 归档到 Spec 目录

### 6. Steering 更新

**每完成一个 Spec，开始新 Spec 前，评估是否需要更新 Steering**:
- 通用经验教训 → 更新 CORE_PRINCIPLES
- 当前 Spec 场景 → 更新 CURRENT_CONTEXT

### 7. 数据原子性原则

**核心**: 每类数据有且仅有一个权威数据源（Single Source of Truth）

**适用范围**:
- 配置数据: 不应有多个配置文件存储相同信息
- 缓存数据: 派生数据应有唯一缓存源
- 状态数据: 系统状态应集中管理

**设计要求**:
- 避免数据源多重性
- 保证更新原子性
- 从架构层面保证数据一致性

**违反后果**: 数据不一致 | 同步复杂度增加 | 事务性保证困难 | 维护成本上升

**示例**:
```javascript
// ❌ 错误：数据分散
~/.kse/workspaces.json  - 存储工作区列表 + last_accessed
~/.kse/config.json      - 存储 active_workspace

// ✅ 正确：单一数据源
~/.kse/workspace-state.json  - 存储所有工作区相关数据
```

### 8. 文档同步更新原则

**核心**: 重要功能的代码变更必须同步更新相关文档

**适用范围**:
- 项目级功能: 新增核心功能必须更新 README.md
- 用户指南: 新增命令或工作流必须更新用户文档
- API 变更: 公开 API 变更必须更新 API 文档
- 配置变更: 配置格式变更必须更新配置文档

**更新时机**:
- 功能实现完成时: 立即更新相关文档
- Spec 完成前: 确保所有文档已同步更新
- 发布前: 验证文档与代码一致性

**文档类型**:
- README.md: 项目概览、核心功能、快速开始
- docs/: 详细用户指南、API 文档、示例
- CHANGELOG.md: 版本变更记录
- 代码注释: 复杂逻辑的内联文档

**违反后果**: 用户困惑 | 功能难以发现 | 使用门槛提高 | 维护成本增加

**示例**:
```
✅ 正确流程:
1. 实现环境管理功能
2. 更新 docs/environment-management-guide.md（详细指南）
3. 更新 README.md（添加功能概览和快速链接）
4. 更新 CHANGELOG.md（记录版本变更）

❌ 错误流程:
1. 实现环境管理功能
2. 完成 ✓（文档未更新，用户不知道如何使用）
```

---

**版本**: v10.0  
**更新**: 2026-01-31  
**说明**: 添加"文档同步更新原则"（原则 8）
**变更**: 明确重要功能必须同步更新文档，避免文档滞后
