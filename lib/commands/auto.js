/**
 * Autonomous Control CLI Commands
 */

const AutonomousEngine = require('../auto/autonomous-engine');
const { mergeConfigs, DEFAULT_CONFIG } = require('../auto/config-schema');
const { runAutoCloseLoop } = require('../auto/close-loop-runner');
const { analyzeGoalSemantics } = require('../auto/semantic-decomposer');
const MOQUI_CAPABILITY_LEXICON = require('../data/moqui-capability-lexicon.json');
const fs = require('fs-extra');
const path = require('path');
const chalk = require('chalk');
const { spawnSync } = require('child_process');

const AUTO_ARCHIVE_SCHEMA_VERSION = '1.0';
const AUTO_ARCHIVE_SCHEMA_SUPPORTED_VERSIONS = new Set([AUTO_ARCHIVE_SCHEMA_VERSION]);
const AUTO_HANDOFF_DEFAULT_QUEUE_FILE = '.kiro/auto/handoff-goals.lines';
const AUTO_HANDOFF_RUN_REPORT_DIR = '.kiro/reports/handoff-runs';
const AUTO_HANDOFF_RELEASE_EVIDENCE_FILE = '.kiro/reports/release-evidence/handoff-runs.json';
const AUTO_HANDOFF_EVIDENCE_REVIEW_DEFAULT_FILE = '.kiro/reports/release-evidence/handoff-evidence-review.md';
const AUTO_HANDOFF_RELEASE_EVIDENCE_DIR = '.kiro/reports/release-evidence';
const AUTO_HANDOFF_RELEASE_GATE_HISTORY_FILE = '.kiro/reports/release-evidence/release-gate-history.json';
const AUTO_HANDOFF_MOQUI_BASELINE_JSON_FILE = '.kiro/reports/release-evidence/moqui-template-baseline.json';
const AUTO_HANDOFF_MOQUI_BASELINE_MARKDOWN_FILE = '.kiro/reports/release-evidence/moqui-template-baseline.md';
const AUTO_HANDOFF_SCENE_PACKAGE_BATCH_JSON_FILE = '.kiro/reports/release-evidence/scene-package-publish-batch-dry-run.json';
const AUTO_HANDOFF_SCENE_PACKAGE_BATCH_TASK_QUEUE_FILE = '.kiro/auto/ontology-remediation.lines';
const AUTO_HANDOFF_MOQUI_CAPABILITY_COVERAGE_JSON_FILE = '.kiro/reports/release-evidence/moqui-capability-coverage.json';
const AUTO_HANDOFF_MOQUI_CAPABILITY_COVERAGE_MARKDOWN_FILE = '.kiro/reports/release-evidence/moqui-capability-coverage.md';
const AUTO_HANDOFF_MOQUI_REMEDIATION_QUEUE_FILE = '.kiro/auto/moqui-remediation.lines';
const AUTO_HANDOFF_CLI_SCRIPT_FILE = path.resolve(__dirname, '..', '..', 'bin', 'kiro-spec-engine.js');
const MOQUI_CAPABILITY_LEXICON_INDEX = buildMoquiCapabilityLexiconIndex(MOQUI_CAPABILITY_LEXICON);

/**
 * Register auto commands
 * @param {Object} program - Commander program
 */
function registerAutoCommands(program) {
  const auto = program
    .command('auto')
    .description('Autonomous execution control');
  
  // kse auto run
  auto
    .command('run <spec-name>')
    .description('Run Spec autonomously')
    .option('-m, --mode <mode>', 'Execution mode (conservative|balanced|aggressive)', 'balanced')
    .action(async (specName, options) => {
      try {
        console.log(chalk.blue(`Starting autonomous execution: ${specName}`));
        console.log(chalk.gray(`Mode: ${options.mode}`));
        
        const config = await loadConfig(options.mode);
        const engine = new AutonomousEngine(specName, config);
        
        await engine.initialize();
        await engine.start();
        await engine.executeTaskQueue();
        await engine.stop();
        
        const status = engine.getStatus();
        console.log(chalk.green('\n✓ Execution completed'));
        console.log(chalk.gray(`Tasks completed: ${status.queueStatus.completed}/${status.queueStatus.total}`));
        
      } catch (error) {
        console.error(chalk.red(`Error: ${error.message}`));
        process.exit(1);
      }
    });
  
  // kse auto create
  auto
    .command('create <feature-description>')
    .description('Create and run Spec autonomously')
    .option('-n, --name <name>', 'Spec name')
    .option('-m, --mode <mode>', 'Execution mode', 'balanced')
    .action(async (description, options) => {
      try {
        const specName = options.name || generateSpecName(description);
        
        console.log(chalk.blue(`Creating Spec: ${specName}`));
        console.log(chalk.gray(`Description: ${description}`));
        
        const config = await loadConfig(options.mode);
        const engine = new AutonomousEngine(specName, config);
        
        await engine.initialize();
        await engine.start();
        
        const result = await engine.createSpecAutonomously(description);
        
        console.log(chalk.green('\n✓ Spec created'));
        console.log(chalk.gray(`Requirements: ${result.requirementsCreated ? '✓' : '✗'}`));
        console.log(chalk.gray(`Design: ${result.designCreated ? '✓' : '✗'}`));
        console.log(chalk.gray(`Tasks: ${result.tasksCreated ? '✓' : '✗'}`));
        
        await engine.stop();
        
      } catch (error) {
        console.error(chalk.red(`Error: ${error.message}`));
        process.exit(1);
      }
    });
  
  // kse auto status
  auto
    .command('status [spec-name]')
    .description('Show autonomous execution status')
    .action(async (specName) => {
      try {
        if (!specName) {
          // Show all active executions
          console.log(chalk.blue('Active autonomous executions:'));
          console.log(chalk.gray('(No active executions)'));
          return;
        }
        
        const config = await loadConfig();
        const engine = new AutonomousEngine(specName, config);
        
        await engine.initialize();
        const status = engine.getStatus();
        
        console.log(chalk.blue(`\nStatus: ${specName}`));
        console.log(chalk.gray(`Running: ${status.isRunning ? 'Yes' : 'No'}`));
        console.log(chalk.gray(`Paused: ${status.isPaused ? 'Yes' : 'No'}`));
        console.log(chalk.gray(`Current task: ${status.currentTask || 'None'}`));
        console.log(chalk.gray(`Progress: ${status.progress.overallProgress}%`));
        console.log(chalk.gray(`Tasks: ${status.queueStatus.completed}/${status.queueStatus.total}`));
        
      } catch (error) {
        console.error(chalk.red(`Error: ${error.message}`));
        process.exit(1);
      }
    });
  
  // kse auto resume
  auto
    .command('resume [spec-name]')
    .description('Resume paused execution')
    .action(async (specName) => {
      try {
        if (!specName) {
          console.error(chalk.red('Error: Spec name required'));
          process.exit(1);
        }
        
        const config = await loadConfig();
        const engine = new AutonomousEngine(specName, config);
        
        await engine.initialize();
        await engine.resume();
        await engine.executeTaskQueue();
        await engine.stop();
        
        console.log(chalk.green('✓ Execution resumed and completed'));
        
      } catch (error) {
        console.error(chalk.red(`Error: ${error.message}`));
        process.exit(1);
      }
    });
  
  // kse auto stop
  auto
    .command('stop <spec-name>')
    .description('Stop autonomous execution')
    .action(async (specName) => {
      try {
        const config = await loadConfig();
        const engine = new AutonomousEngine(specName, config);
        
        await engine.initialize();
        await engine.stop();
        
        console.log(chalk.green('✓ Execution stopped'));
        
      } catch (error) {
        console.error(chalk.red(`Error: ${error.message}`));
        process.exit(1);
      }
    });
  
  // kse auto config
  auto
    .command('config')
    .description('Show/edit autonomous configuration')
    .option('--show', 'Show current configuration')
    .option('--mode <mode>', 'Set default mode')
    .action(async (options) => {
      try {
        const configPath = path.join(process.cwd(), '.kiro', 'auto', 'config.json');
        
        if (options.show) {
          const config = await loadConfig();
          console.log(chalk.blue('Current configuration:'));
          console.log(JSON.stringify(config, null, 2));
          return;
        }
        
        if (options.mode) {
          const config = await loadConfig();
          config.mode = options.mode;
          await fs.ensureDir(path.dirname(configPath));
          await fs.writeJson(configPath, config, { spaces: 2 });
          console.log(chalk.green(`✓ Mode set to: ${options.mode}`));
          return;
        }
        
        console.log(chalk.gray('Use --show to view configuration'));
        console.log(chalk.gray('Use --mode <mode> to set default mode'));
        
      } catch (error) {
        console.error(chalk.red(`Error: ${error.message}`));
        process.exit(1);
      }
    });

  const runCloseLoopCommand = async (goal, options, extra = {}) => {
    const resumeAliases = new Set(['continue', '继续']);
    let normalizedGoal = goal;
    let resumeRef = typeof options.resume === 'string' && options.resume.trim()
      ? options.resume.trim()
      : null;

    if (!resumeRef) {
      const goalToken = typeof goal === 'string' ? goal.trim() : '';
      const normalizedGoalToken = goalToken.toLowerCase();
      if (resumeAliases.has(goalToken) || resumeAliases.has(normalizedGoalToken)) {
        resumeRef = 'interrupted';
        normalizedGoal = undefined;
      }
    }

    if (extra.forceResumeRef) {
      resumeRef = extra.forceResumeRef;
      normalizedGoal = undefined;
    }

    const effectiveOptions = resumeRef
      ? { ...options, resume: resumeRef }
      : options;

    if (!effectiveOptions.resume && (!normalizedGoal || `${normalizedGoal}`.trim() === '')) {
      throw new Error('Goal is required unless --resume is provided.');
    }
    return runAutoCloseLoop(normalizedGoal, effectiveOptions);
  };

  // kse auto close-loop
  applyCloseLoopOptions(
    auto
      .command('close-loop [goal]')
      .description('Autonomously decompose one goal into master/sub Specs and execute to closure'),
    { includeOut: true }
  )
    .action(async (goal, options) => {
      try {
        const result = await runCloseLoopCommand(goal, options);
        if (result.status === 'failed') {
          process.exit(1);
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  // kse auto continue
  applyCloseLoopOptions(
    auto
      .command('continue')
      .description('Continue latest interrupted close-loop session'),
    { includeOut: true }
  )
    .action(async (options) => {
      try {
        const result = await runCloseLoopCommand(undefined, options, {
          forceResumeRef: 'interrupted'
        });
        if (result.status === 'failed') {
          process.exit(1);
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  // kse auto close-loop-batch
  applyCloseLoopOptions(
    auto
      .command('close-loop-batch [goals-file]')
      .description('Run autonomous close-loop for multiple goals from a file'),
    { includeOut: false }
  )
    .option('--format <format>', 'Goals file format: auto|json|lines (default: auto)', 'auto')
    .option('--decompose-goal <goal>', 'Decompose one broad goal into multiple batch goals automatically')
    .option('--program-goals <n>', 'Target number of generated goals for --decompose-goal (default: adaptive)', parseInt)
    .option('--program-min-quality-score <n>', 'Minimum decomposition quality score before automatic refinement (0-100, default: 70)', parseFloat)
    .option('--program-quality-gate', 'Fail when final decomposition quality is below --program-min-quality-score')
    .option('--resume-from-summary <path|latest>', 'Resume pending goals from a previous close-loop-batch summary JSON (or latest)')
    .option('--resume-strategy <strategy>', 'Resume strategy for --resume-from-summary: pending|failed-only (default: pending)', 'pending')
    .option('--batch-parallel <n>', 'Maximum goals to run concurrently in batch mode (default: adaptive under autonomous policy)', parseInt)
    .option('--batch-agent-budget <n>', 'Global parallel-agent budget shared across all batch goals', parseInt)
    .option('--batch-priority <strategy>', 'Batch goal priority strategy: fifo|complex-first|complex-last|critical-first (default: complex-first under autonomous policy)', 'fifo')
    .option('--batch-aging-factor <n>', 'Aging boost per scheduling cycle for waiting goals (default: 2 under autonomous policy)', parseInt)
    .option('--batch-retry-rounds <n>', 'Automatically retry failed/stopped goals for N extra rounds (default: 0, or until-complete under autonomous policy)', parseInt)
    .option('--batch-retry-strategy <strategy>', 'Batch retry strategy: adaptive|strict (default: adaptive)', 'adaptive')
    .option('--batch-retry-until-complete', 'Keep retrying failed/stopped goals until completed or retry max is reached')
    .option('--batch-retry-max-rounds <n>', 'Max extra rounds when --batch-retry-until-complete is enabled (default: 10)', parseInt)
    .option('--no-batch-autonomous', 'Disable autonomous batch policy and use explicit batch flags only')
    .option('--batch-session-id <id>', 'Set explicit batch session id for batch summary persistence')
    .option('--batch-session-keep <n>', 'Keep newest N batch summary sessions after each batch run', parseInt)
    .option('--batch-session-older-than-days <n>', 'Only prune batch summary sessions older than N days', parseInt)
    .option('--spec-session-keep <n>', 'After run, keep newest N spec directories under .kiro/specs', parseInt)
    .option('--spec-session-older-than-days <n>', 'Only prune spec directories older than N days', parseInt)
    .option('--no-spec-session-protect-active', 'Allow spec retention prune to delete active/recently referenced specs')
    .option('--spec-session-protect-window-days <n>', 'Protection window (days) for recent session references when pruning specs', parseInt)
    .option('--spec-session-max-total <n>', 'Spec directory budget: maximum total directories allowed under .kiro/specs', parseInt)
    .option('--spec-session-max-created <n>', 'Spec growth guard: maximum estimated created directories in this run', parseInt)
    .option('--spec-session-max-created-per-goal <n>', 'Spec growth guard: maximum estimated created directories per processed goal', parseFloat)
    .option('--spec-session-max-duplicate-goals <n>', 'Spec growth guard: maximum duplicate goals allowed in one batch input', parseInt)
    .option('--spec-session-budget-hard-fail', 'Fail run when spec directory budget is exceeded before/after execution')
    .option('--no-batch-session', 'Disable automatic close-loop-batch summary session persistence')
    .option('--continue-on-error', 'Continue processing remaining goals when one goal fails')
    .option('--out <path>', 'Write batch summary JSON to file')
    .action(async (goalsFile, options) => {
      try {
        if (options.resume) {
          throw new Error('--resume is not supported in close-loop-batch. Use per-goal close-loop or remove --resume.');
        }
        if (options.sessionId) {
          throw new Error('--session-id is not supported in close-loop-batch. Session ids are generated per goal.');
        }
        if (options.programGoals !== undefined && options.programGoals !== null && !options.decomposeGoal) {
          throw new Error('--program-goals requires --decompose-goal.');
        }
        const batchAutonomousEnabled = options.batchAutonomous !== false;
        if (
          options.batchRetryMaxRounds !== undefined &&
          options.batchRetryMaxRounds !== null &&
          !options.batchRetryUntilComplete &&
          !batchAutonomousEnabled
        ) {
          throw new Error('--batch-retry-max-rounds requires --batch-retry-until-complete.');
        }
        if (options.batchRetryMaxRounds !== undefined && options.batchRetryMaxRounds !== null) {
          normalizeBatchRetryMaxRounds(options.batchRetryMaxRounds);
        }
        if (options.batchSessionKeep !== undefined && options.batchSessionKeep !== null) {
          normalizeBatchSessionKeep(options.batchSessionKeep);
        }
        if (options.batchSessionOlderThanDays !== undefined && options.batchSessionOlderThanDays !== null) {
          normalizeBatchSessionOlderThanDays(options.batchSessionOlderThanDays);
        }
        if (options.specSessionKeep !== undefined && options.specSessionKeep !== null) {
          normalizeSpecKeep(options.specSessionKeep);
        }
        if (options.specSessionOlderThanDays !== undefined && options.specSessionOlderThanDays !== null) {
          normalizeOlderThanDays(options.specSessionOlderThanDays);
        }
        if (options.specSessionProtectWindowDays !== undefined && options.specSessionProtectWindowDays !== null) {
          normalizeSpecSessionProtectWindowDays(options.specSessionProtectWindowDays);
        }
        if (options.specSessionMaxTotal !== undefined && options.specSessionMaxTotal !== null) {
          normalizeSpecSessionMaxTotal(options.specSessionMaxTotal);
        }
        if (options.specSessionMaxCreated !== undefined && options.specSessionMaxCreated !== null) {
          normalizeSpecSessionMaxCreated(options.specSessionMaxCreated);
        }
        if (options.specSessionMaxCreatedPerGoal !== undefined && options.specSessionMaxCreatedPerGoal !== null) {
          normalizeSpecSessionMaxCreatedPerGoal(options.specSessionMaxCreatedPerGoal);
        }
        if (options.specSessionMaxDuplicateGoals !== undefined && options.specSessionMaxDuplicateGoals !== null) {
          normalizeSpecSessionMaxDuplicateGoals(options.specSessionMaxDuplicateGoals);
        }
        if (options.batchSessionId !== undefined && options.batchSessionId !== null) {
          const sanitizedBatchSessionId = sanitizeBatchSessionId(options.batchSessionId);
          if (!sanitizedBatchSessionId) {
            throw new Error('--batch-session-id is invalid after sanitization.');
          }
        }
        if (options.resumeFromSummary && goalsFile) {
          throw new Error('Provide either <goals-file> or --resume-from-summary, not both.');
        }
        if (options.decomposeGoal && goalsFile) {
          throw new Error('Provide either <goals-file> or --decompose-goal, not both.');
        }
        if (options.decomposeGoal && options.resumeFromSummary) {
          throw new Error('Provide either --resume-from-summary or --decompose-goal, not both.');
        }
        if (!options.resumeFromSummary && !options.decomposeGoal && (!goalsFile || `${goalsFile}`.trim() === '')) {
          throw new Error('<goals-file> is required unless --resume-from-summary or --decompose-goal is provided.');
        }

        const projectPath = process.cwd();
        const goalsResult = options.decomposeGoal
          ? buildCloseLoopBatchGoalsFromGoal(
            options.decomposeGoal,
            options.programGoals,
            {
              minQualityScore: options.programMinQualityScore,
              enforceQualityGate: Boolean(options.programQualityGate)
            }
          )
          : options.resumeFromSummary
            ? await loadCloseLoopBatchGoalsFromSummary(
              projectPath,
              options.resumeFromSummary,
              options.format,
              options.resumeStrategy
            )
            : await loadCloseLoopBatchGoals(projectPath, goalsFile, options.format);
        if (goalsResult.goals.length === 0) {
          throw new Error(`No goals found in batch file: ${goalsResult.file}`);
        }

        const summary = await executeCloseLoopBatch(goalsResult, options, projectPath, 'auto-close-loop-batch');
        printCloseLoopBatchSummary(summary, options);

        if (
          summary.status !== 'completed' ||
          isSpecSessionBudgetHardFailure(summary) ||
          isSpecSessionGrowthGuardHardFailure(summary)
        ) {
          process.exit(1);
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  // kse auto close-loop-program
  applyCloseLoopOptions(
    auto
      .command('close-loop-program <goal>')
      .description('Autonomously decompose one broad goal into multiple close-loop goals and run as a program'),
    { includeOut: false }
  )
    .option('--program-goals <n>', 'Target number of generated goals for program decomposition (default: adaptive)', parseInt)
    .option('--program-min-quality-score <n>', 'Minimum decomposition quality score before automatic refinement (0-100, default: 70)', parseFloat)
    .option('--program-quality-gate', 'Fail when final decomposition quality is below --program-min-quality-score')
    .option('--batch-parallel <n>', 'Maximum goals to run concurrently in program mode', parseInt)
    .option('--batch-agent-budget <n>', 'Global parallel-agent budget shared across all program goals', parseInt)
    .option('--batch-priority <strategy>', 'Program goal priority strategy: fifo|complex-first|complex-last|critical-first', 'fifo')
    .option('--batch-aging-factor <n>', 'Aging boost per scheduling cycle for waiting goals', parseInt)
    .option('--batch-retry-rounds <n>', 'Automatically retry failed/stopped goals for N extra rounds', parseInt)
    .option('--batch-retry-strategy <strategy>', 'Batch retry strategy: adaptive|strict', 'adaptive')
    .option('--batch-retry-until-complete', 'Keep retrying failed/stopped goals until completed or retry max is reached')
    .option('--batch-retry-max-rounds <n>', 'Max extra rounds for retry-until-complete mode (default: 10)', parseInt)
    .option('--no-batch-autonomous', 'Disable autonomous batch policy in close-loop-program')
    .option('--batch-session-id <id>', 'Set explicit batch session id for summary persistence')
    .option('--batch-session-keep <n>', 'Keep newest N batch summary sessions after each program run', parseInt)
    .option('--batch-session-older-than-days <n>', 'Only prune batch summary sessions older than N days', parseInt)
    .option('--spec-session-keep <n>', 'After run, keep newest N spec directories under .kiro/specs', parseInt)
    .option('--spec-session-older-than-days <n>', 'Only prune spec directories older than N days', parseInt)
    .option('--no-spec-session-protect-active', 'Allow spec retention prune to delete active/recently referenced specs')
    .option('--spec-session-protect-window-days <n>', 'Protection window (days) for recent session references when pruning specs', parseInt)
    .option('--spec-session-max-total <n>', 'Spec directory budget: maximum total directories allowed under .kiro/specs', parseInt)
    .option('--spec-session-max-created <n>', 'Spec growth guard: maximum estimated created directories in this run', parseInt)
    .option('--spec-session-max-created-per-goal <n>', 'Spec growth guard: maximum estimated created directories per processed goal', parseFloat)
    .option('--spec-session-max-duplicate-goals <n>', 'Spec growth guard: maximum duplicate goals allowed in one batch input', parseInt)
    .option('--spec-session-budget-hard-fail', 'Fail run when spec directory budget is exceeded before/after execution')
    .option('--no-batch-session', 'Disable automatic close-loop-program summary session persistence')
    .option('--continue-on-error', 'Continue processing remaining goals when one goal fails')
    .option('--no-program-auto-recover', 'Disable automatic recovery loop when program run ends with unresolved goals')
    .option('--program-recover-use-action <n>', 'Preferred remediation action index for program auto recovery (default: memory/default)', parseInt)
    .option('--program-recover-resume-strategy <strategy>', 'Program auto recovery resume strategy: pending|failed-only (default: pending)', 'pending')
    .option('--program-recover-max-rounds <n>', 'Max rounds for program auto recovery (default: 5)', parseInt)
    .option('--program-recover-max-minutes <n>', 'Max elapsed minutes for program auto recovery loop (default: unlimited)', parseInt)
    .option('--program-gate-profile <profile>', 'Program convergence gate profile: default|dev|staging|prod', 'default')
    .option('--program-gate-fallback-profile <profile>', 'Fallback gate profile when primary gate fails: none|default|dev|staging|prod', 'none')
    .option('--program-gate-fallback-chain <profiles>', 'Ordered fallback gate profiles (comma-separated): none|default|dev|staging|prod')
    .option('--program-min-success-rate <n>', 'Program convergence gate: minimum success rate percent (default: 100)', parseFloat)
    .option('--program-max-risk-level <level>', 'Program convergence gate: maximum allowed risk level (low|medium|high)')
    .option('--program-max-elapsed-minutes <n>', 'Program convergence gate: maximum elapsed minutes (default: unlimited)', parseInt)
    .option('--program-max-agent-budget <n>', 'Program convergence gate: maximum allowed agent budget/effective parallel budget', parseInt)
    .option('--program-max-total-sub-specs <n>', 'Program convergence gate: maximum total sub-specs generated across program goals', parseInt)
    .option('--no-program-gate-auto-remediate', 'Disable automatic remediation patch/prune suggestions after gate failure')
    .option('--program-govern-until-stable', 'Enable post-run governance loop until gate/anomaly stability is reached')
    .option('--program-govern-max-rounds <n>', 'Max governance rounds when --program-govern-until-stable is enabled (default: 3)', parseInt)
    .option('--program-govern-max-minutes <n>', 'Max elapsed minutes for governance loop (default: 60)', parseInt)
    .option('--program-govern-anomaly-weeks <n>', 'KPI trend lookback weeks for governance anomaly checks (default: 8)', parseInt)
    .option('--program-govern-anomaly-period <period>', 'KPI trend period for governance anomaly checks: week|day', 'week')
    .option('--no-program-govern-anomaly', 'Disable anomaly-triggered governance decisions (gate-only)')
    .option('--program-govern-use-action <n>', 'Pinned remediation action index used by governance rounds (default: memory/default)', parseInt)
    .option('--no-program-govern-auto-action', 'Disable automatic remediation action selection/execution inside governance loop')
    .option('--recovery-memory-scope <scope>', 'Recovery memory scope key (default: auto: project + git branch)')
    .option('--program-audit-out <path>', 'Write program audit JSON with recovery and coordination trace')
    .option('--program-kpi-out <path>', 'Write program KPI snapshot JSON to file')
    .option('--out <path>', 'Write program summary JSON to file')
    .action(async (goal, options) => {
      try {
        const result = await executeCloseLoopProgramGoal(goal, options, {
          projectPath: process.cwd(),
          printSummary: true,
          writeOutputs: true
        });
        if (result.exitCode !== 0) {
          process.exit(1);
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  // kse auto close-loop-controller
  auto
    .command('close-loop-controller [queue-file]')
    .description('Run a persistent autonomous controller that drains a goal queue via close-loop-program execution')
    .option('--controller-resume <session>', 'Resume controller from persisted session id/file/latest')
    .option('--queue-format <format>', 'Queue file format: auto|json|lines (default: auto)', 'auto')
    .option('--no-controller-dedupe', 'Disable duplicate broad-goal deduplication when loading queue entries')
    .option('--dequeue-limit <n>', 'Maximum goals to consume from queue per controller cycle (default: all pending goals)', parseInt)
    .option('--wait-on-empty', 'Keep polling when queue is empty instead of exiting')
    .option('--poll-seconds <n>', 'Polling interval seconds when --wait-on-empty is enabled (default: 30)', parseInt)
    .option('--max-cycles <n>', 'Maximum controller cycles before exit (default: 1000)', parseInt)
    .option('--max-minutes <n>', 'Maximum controller elapsed minutes before exit (default: 120)', parseInt)
    .option('--controller-lock-file <path>', 'Controller lease lock file path (default: <queue-file>.lock)')
    .option('--controller-lock-ttl-seconds <n>', 'Stale lock takeover threshold seconds (default: 1800)', parseInt)
    .option('--no-controller-lock', 'Disable controller lease lock (not recommended in concurrent runs)')
    .option('--stop-on-goal-failure', 'Stop controller immediately when one dequeued goal fails')
    .option('--controller-session-id <id>', 'Set explicit controller session id for summary persistence')
    .option('--controller-session-keep <n>', 'Keep newest N controller sessions after each controller run', parseInt)
    .option('--controller-session-older-than-days <n>', 'Only prune controller sessions older than N days', parseInt)
    .option('--no-controller-session', 'Disable close-loop-controller summary session persistence')
    .option('--controller-out <path>', 'Write controller summary JSON to file')
    .option('--controller-done-file <path>', 'Append completed goals to a line-based archive file')
    .option('--controller-failed-file <path>', 'Append failed goals to a line-based archive file')
    .option('--controller-print-program-summary', 'Print per-goal close-loop-program summary while controller runs')
    .option('--program-goals <n>', 'Target number of generated goals for program decomposition (default: adaptive)', parseInt)
    .option('--program-min-quality-score <n>', 'Minimum decomposition quality score before automatic refinement (0-100, default: 70)', parseFloat)
    .option('--program-quality-gate', 'Fail when final decomposition quality is below --program-min-quality-score')
    .option('--batch-parallel <n>', 'Maximum goals to run concurrently in program mode', parseInt)
    .option('--batch-agent-budget <n>', 'Global parallel-agent budget shared across all program goals', parseInt)
    .option('--batch-priority <strategy>', 'Program goal priority strategy: fifo|complex-first|complex-last|critical-first', 'fifo')
    .option('--batch-aging-factor <n>', 'Aging boost per scheduling cycle for waiting goals', parseInt)
    .option('--batch-retry-rounds <n>', 'Automatically retry failed/stopped goals for N extra rounds', parseInt)
    .option('--batch-retry-strategy <strategy>', 'Batch retry strategy: adaptive|strict', 'adaptive')
    .option('--batch-retry-until-complete', 'Keep retrying failed/stopped goals until completed or retry max is reached')
    .option('--batch-retry-max-rounds <n>', 'Max extra rounds for retry-until-complete mode (default: 10)', parseInt)
    .option('--no-batch-autonomous', 'Disable autonomous batch policy in close-loop-controller')
    .option('--continue-on-error', 'Continue processing remaining goals when one goal fails')
    .option('--no-program-auto-recover', 'Disable automatic recovery loop when program run ends with unresolved goals')
    .option('--program-recover-use-action <n>', 'Preferred remediation action index for program auto recovery (default: memory/default)', parseInt)
    .option('--program-recover-resume-strategy <strategy>', 'Program auto recovery resume strategy: pending|failed-only (default: pending)', 'pending')
    .option('--program-recover-max-rounds <n>', 'Max rounds for program auto recovery (default: 5)', parseInt)
    .option('--program-recover-max-minutes <n>', 'Max elapsed minutes for program auto recovery loop (default: unlimited)', parseInt)
    .option('--program-gate-profile <profile>', 'Program convergence gate profile: default|dev|staging|prod', 'default')
    .option('--program-gate-fallback-profile <profile>', 'Fallback gate profile when primary gate fails: none|default|dev|staging|prod', 'none')
    .option('--program-gate-fallback-chain <profiles>', 'Ordered fallback gate profiles (comma-separated): none|default|dev|staging|prod')
    .option('--program-min-success-rate <n>', 'Program convergence gate: minimum success rate percent (default: 100)', parseFloat)
    .option('--program-max-risk-level <level>', 'Program convergence gate: maximum allowed risk level (low|medium|high)')
    .option('--program-max-elapsed-minutes <n>', 'Program convergence gate: maximum elapsed minutes (default: unlimited)', parseInt)
    .option('--program-max-agent-budget <n>', 'Program convergence gate: maximum allowed agent budget/effective parallel budget', parseInt)
    .option('--program-max-total-sub-specs <n>', 'Program convergence gate: maximum total sub-specs generated across program goals', parseInt)
    .option('--no-program-gate-auto-remediate', 'Disable automatic remediation patch/prune suggestions after gate failure')
    .option('--program-govern-until-stable', 'Enable post-run governance loop until gate/anomaly stability is reached')
    .option('--program-govern-max-rounds <n>', 'Max governance rounds when --program-govern-until-stable is enabled (default: 3)', parseInt)
    .option('--program-govern-max-minutes <n>', 'Max elapsed minutes for governance loop (default: 60)', parseInt)
    .option('--program-govern-anomaly-weeks <n>', 'KPI trend lookback weeks for governance anomaly checks (default: 8)', parseInt)
    .option('--program-govern-anomaly-period <period>', 'KPI trend period for governance anomaly checks: week|day', 'week')
    .option('--no-program-govern-anomaly', 'Disable anomaly-triggered governance decisions (gate-only)')
    .option('--program-govern-use-action <n>', 'Pinned remediation action index used by governance rounds (default: memory/default)', parseInt)
    .option('--no-program-govern-auto-action', 'Disable automatic remediation action selection/execution inside governance loop')
    .option('--recovery-memory-scope <scope>', 'Recovery memory scope key (default: auto: project + git branch)')
    .option('--dry-run', 'Preview decomposition without writing files')
    .option('--json', 'Output machine-readable JSON')
    .action(async (queueFile, options) => {
      try {
        const projectPath = process.cwd();
        if (options.controllerResume && queueFile) {
          throw new Error('[queue-file] cannot be combined with --controller-resume.');
        }
        const resumedSession = options.controllerResume
          ? await loadCloseLoopControllerSessionPayload(projectPath, options.controllerResume)
          : null;
        const summary = await runCloseLoopController(queueFile, options, {
          projectPath,
          resumedSession
        });
        if (options.json) {
          console.log(JSON.stringify(summary, null, 2));
        } else {
          printCloseLoopControllerSummary(summary);
        }
        if (summary.status !== 'completed') {
          process.exit(1);
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  // kse auto close-loop-recover
  applyCloseLoopOptions(
    auto
      .command('close-loop-recover [summary]')
      .description('Automatically recover unresolved goals from a prior close-loop program/batch summary using remediation actions'),
    { includeOut: false }
  )
    .option('--use-action <n>', 'Select remediation action index from diagnostics (default: 1)', parseInt)
    .option('--resume-strategy <strategy>', 'Resume strategy for summary recovery: pending|failed-only (default: pending)', 'pending')
    .option('--recover-until-complete', 'Keep running recovery rounds until completion or recover max rounds is reached')
    .option('--recover-max-rounds <n>', 'Max recovery rounds when --recover-until-complete is enabled (default: 5)', parseInt)
    .option('--recover-max-minutes <n>', 'Max elapsed minutes for recovery loop (default: unlimited)', parseInt)
    .option('--recovery-memory-ttl-days <n>', 'Prune recovery memory entries older than N days before selecting action', parseInt)
    .option('--recovery-memory-scope <scope>', 'Recovery memory scope key (default: auto: project + git branch)')
    .option('--batch-parallel <n>', 'Maximum goals to run concurrently during recovery', parseInt)
    .option('--batch-agent-budget <n>', 'Global parallel-agent budget shared across recovery goals', parseInt)
    .option('--batch-priority <strategy>', 'Recovery goal priority strategy: fifo|complex-first|complex-last|critical-first', 'fifo')
    .option('--batch-aging-factor <n>', 'Aging boost per scheduling cycle for waiting goals', parseInt)
    .option('--batch-retry-rounds <n>', 'Automatically retry failed/stopped goals for N extra rounds', parseInt)
    .option('--batch-retry-strategy <strategy>', 'Batch retry strategy: adaptive|strict', 'adaptive')
    .option('--batch-retry-until-complete', 'Keep retrying failed/stopped goals until completed or retry max is reached')
    .option('--batch-retry-max-rounds <n>', 'Max extra rounds for retry-until-complete mode (default: 10)', parseInt)
    .option('--no-batch-autonomous', 'Disable autonomous batch policy in close-loop-recover')
    .option('--batch-session-id <id>', 'Set explicit batch session id for summary persistence')
    .option('--batch-session-keep <n>', 'Keep newest N batch summary sessions after each recovery run', parseInt)
    .option('--batch-session-older-than-days <n>', 'Only prune batch summary sessions older than N days', parseInt)
    .option('--spec-session-keep <n>', 'After run, keep newest N spec directories under .kiro/specs', parseInt)
    .option('--spec-session-older-than-days <n>', 'Only prune spec directories older than N days', parseInt)
    .option('--no-spec-session-protect-active', 'Allow spec retention prune to delete active/recently referenced specs')
    .option('--spec-session-protect-window-days <n>', 'Protection window (days) for recent session references when pruning specs', parseInt)
    .option('--spec-session-max-total <n>', 'Spec directory budget: maximum total directories allowed under .kiro/specs', parseInt)
    .option('--spec-session-max-created <n>', 'Spec growth guard: maximum estimated created directories in this run', parseInt)
    .option('--spec-session-max-created-per-goal <n>', 'Spec growth guard: maximum estimated created directories per processed goal', parseFloat)
    .option('--spec-session-max-duplicate-goals <n>', 'Spec growth guard: maximum duplicate goals allowed in one batch input', parseInt)
    .option('--spec-session-budget-hard-fail', 'Fail run when spec directory budget is exceeded before/after execution')
    .option('--program-gate-profile <profile>', 'Recovery convergence gate profile: default|dev|staging|prod', 'default')
    .option('--program-gate-fallback-profile <profile>', 'Recovery fallback gate profile: none|default|dev|staging|prod', 'none')
    .option('--program-gate-fallback-chain <profiles>', 'Recovery ordered fallback gate profiles (comma-separated): none|default|dev|staging|prod')
    .option('--program-min-success-rate <n>', 'Recovery convergence gate: minimum success rate percent', parseFloat)
    .option('--program-max-risk-level <level>', 'Recovery convergence gate: maximum allowed risk level (low|medium|high)')
    .option('--program-max-elapsed-minutes <n>', 'Recovery convergence gate: maximum elapsed minutes', parseInt)
    .option('--program-max-agent-budget <n>', 'Recovery convergence gate: maximum allowed agent budget/effective parallel budget', parseInt)
    .option('--program-max-total-sub-specs <n>', 'Recovery convergence gate: maximum total sub-specs generated across goals', parseInt)
    .option('--no-program-gate-auto-remediate', 'Disable automatic remediation patch/prune suggestions after gate failure')
    .option('--no-batch-session', 'Disable automatic close-loop-recover summary session persistence')
    .option('--program-kpi-out <path>', 'Write recovery KPI snapshot JSON to file')
    .option('--program-audit-out <path>', 'Write recovery audit JSON with strategy and round history')
    .option('--continue-on-error', 'Continue processing remaining goals when one goal fails')
    .option('--out <path>', 'Write recovery summary JSON to file')
    .action(async (summaryCandidate, options) => {
      try {
        const projectPath = process.cwd();
        const summaryInput = typeof summaryCandidate === 'string' && summaryCandidate.trim()
          ? summaryCandidate.trim()
          : 'latest';
        const recoverAutonomousEnabled = options.batchAutonomous !== false;
        const resumeStrategy = normalizeResumeStrategy(options.resumeStrategy);
        const recoverUntilComplete = Boolean(options.recoverUntilComplete);
        const recoverMaxRounds = recoverUntilComplete
          ? normalizeRecoverMaxRounds(options.recoverMaxRounds)
          : 1;
        const recoverMaxMinutes = normalizeRecoverMaxMinutes(options.recoverMaxMinutes, '--recover-max-minutes');
        const recoveryStartedAt = Date.now();
        const programGatePolicy = resolveProgramGatePolicy({
          profile: options.programGateProfile,
          minSuccessRate: options.programMinSuccessRate,
          maxRiskLevel: options.programMaxRiskLevel,
          maxElapsedMinutes: options.programMaxElapsedMinutes,
          maxAgentBudget: options.programMaxAgentBudget,
          maxTotalSubSpecs: options.programMaxTotalSubSpecs
        });
        const gateFallbackProfile = normalizeProgramGateFallbackProfile(options.programGateFallbackProfile);
        const gateFallbackChain = resolveProgramGateFallbackChain(options.programGateFallbackChain, gateFallbackProfile);
        const recoveryMemoryTtlDays = normalizeRecoveryMemoryTtlDays(options.recoveryMemoryTtlDays);
        const recoveryMemoryScope = await resolveRecoveryMemoryScope(projectPath, options.recoveryMemoryScope);

        if (options.resume) {
          throw new Error('--resume is not supported in close-loop-recover. Recovery source is selected by [summary].');
        }
        if (options.sessionId) {
          throw new Error('--session-id is not supported in close-loop-recover. Session ids are generated per goal.');
        }
        if (
          options.recoverMaxRounds !== undefined &&
          options.recoverMaxRounds !== null &&
          !recoverUntilComplete
        ) {
          throw new Error('--recover-max-rounds requires --recover-until-complete.');
        }
        if (
          options.batchRetryMaxRounds !== undefined &&
          options.batchRetryMaxRounds !== null &&
          !options.batchRetryUntilComplete &&
          !recoverAutonomousEnabled
        ) {
          throw new Error('--batch-retry-max-rounds requires --batch-retry-until-complete.');
        }
        if (options.batchRetryMaxRounds !== undefined && options.batchRetryMaxRounds !== null) {
          normalizeBatchRetryMaxRounds(options.batchRetryMaxRounds);
        }
        if (options.batchSessionKeep !== undefined && options.batchSessionKeep !== null) {
          normalizeBatchSessionKeep(options.batchSessionKeep);
        }
        if (options.batchSessionOlderThanDays !== undefined && options.batchSessionOlderThanDays !== null) {
          normalizeBatchSessionOlderThanDays(options.batchSessionOlderThanDays);
        }
        if (options.specSessionKeep !== undefined && options.specSessionKeep !== null) {
          normalizeSpecKeep(options.specSessionKeep);
        }
        if (options.specSessionOlderThanDays !== undefined && options.specSessionOlderThanDays !== null) {
          normalizeOlderThanDays(options.specSessionOlderThanDays);
        }
        if (options.specSessionProtectWindowDays !== undefined && options.specSessionProtectWindowDays !== null) {
          normalizeSpecSessionProtectWindowDays(options.specSessionProtectWindowDays);
        }
        if (options.specSessionMaxTotal !== undefined && options.specSessionMaxTotal !== null) {
          normalizeSpecSessionMaxTotal(options.specSessionMaxTotal);
        }
        if (options.specSessionMaxCreated !== undefined && options.specSessionMaxCreated !== null) {
          normalizeSpecSessionMaxCreated(options.specSessionMaxCreated);
        }
        if (options.specSessionMaxCreatedPerGoal !== undefined && options.specSessionMaxCreatedPerGoal !== null) {
          normalizeSpecSessionMaxCreatedPerGoal(options.specSessionMaxCreatedPerGoal);
        }
        if (options.specSessionMaxDuplicateGoals !== undefined && options.specSessionMaxDuplicateGoals !== null) {
          normalizeSpecSessionMaxDuplicateGoals(options.specSessionMaxDuplicateGoals);
        }
        if (options.batchSessionId !== undefined && options.batchSessionId !== null) {
          const sanitizedBatchSessionId = sanitizeBatchSessionId(options.batchSessionId);
          if (!sanitizedBatchSessionId) {
            throw new Error('--batch-session-id is invalid after sanitization.');
          }
        }

        const sourceSummary = await loadCloseLoopBatchSummaryPayload(projectPath, summaryInput);
        const recoveryResult = await executeCloseLoopRecoveryCycle({
          projectPath,
          sourceSummary,
          baseOptions: options,
          recoverAutonomousEnabled,
          resumeStrategy,
          recoverUntilComplete,
          recoverMaxRounds,
          recoverMaxDurationMs: recoverMaxMinutes === null ? null : recoverMaxMinutes * 60 * 1000,
          recoveryMemoryTtlDays,
          recoveryMemoryScope,
          actionCandidate: options.useAction
        });
        const recoveryCompletedAt = Date.now();
        recoveryResult.summary.program_started_at = new Date(recoveryStartedAt).toISOString();
        recoveryResult.summary.program_completed_at = new Date(recoveryCompletedAt).toISOString();
        recoveryResult.summary.program_elapsed_ms = Math.max(0, recoveryCompletedAt - recoveryStartedAt);
        await applyProgramGateOutcome(recoveryResult.summary, {
          projectPath,
          options,
          programGatePolicy,
          gateFallbackChain,
          enableAutoRemediation: options.programGateAutoRemediate !== false
        });
        await maybeWriteProgramAudit(recoveryResult.summary, options.programAuditOut, projectPath);

        printCloseLoopBatchSummary(recoveryResult.summary, recoveryResult.options || options);

        if (
          recoveryResult.summary.status !== 'completed' ||
          !recoveryResult.summary.program_gate_effective.passed ||
          isSpecSessionBudgetHardFailure(recoveryResult.summary) ||
          isSpecSessionGrowthGuardHardFailure(recoveryResult.summary)
        ) {
          process.exit(1);
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  const autoBatchSession = auto
    .command('batch-session')
    .description('Manage close-loop-batch summary sessions');

  autoBatchSession
    .command('list')
    .description('List persisted close-loop-batch summary sessions')
    .option('--limit <n>', 'Maximum sessions to show (default: 20)', parseInt)
    .option('--status <statuses>', 'Filter by status token(s), comma-separated (case-insensitive)')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await listCloseLoopBatchSummarySessions(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }

        if (result.total === 0) {
          console.log(chalk.gray('No close-loop-batch summary sessions found.'));
          return;
        }

        if (Array.isArray(result.status_filter) && result.status_filter.length > 0) {
          console.log(chalk.gray(`Status filter: ${result.status_filter.join(', ')}`));
        }
        console.log(chalk.blue(`Close-loop-batch summary sessions (${result.total}):`));
        if (result.status_counts && Object.keys(result.status_counts).length > 0) {
          console.log(chalk.gray(`  Status counts: ${JSON.stringify(result.status_counts)}`));
        }
        result.sessions.forEach(session => {
          const updated = session.updated_at || 'unknown-time';
          const status = session.status || 'unknown';
          console.log(chalk.gray(`- ${session.id} | ${status} | ${updated} | processed ${session.processed_goals}/${session.total_goals}`));
        });
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoBatchSession
    .command('stats')
    .description('Aggregate persisted close-loop-batch summary session telemetry')
    .option('--days <n>', 'Only include sessions updated within last N days', parseInt)
    .option('--status <statuses>', 'Filter by status token(s), comma-separated (case-insensitive)')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await statsCloseLoopBatchSummarySessions(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }

        if (result.total_sessions === 0) {
          console.log(chalk.gray('No close-loop-batch summary sessions found for the selected stats filter.'));
          return;
        }

        console.log(chalk.blue('Close-loop-batch session stats:'));
        if (result.criteria.days !== null) {
          console.log(chalk.gray(`  Window days: ${result.criteria.days}`));
        }
        if (Array.isArray(result.criteria.status_filter) && result.criteria.status_filter.length > 0) {
          console.log(chalk.gray(`  Status filter: ${result.criteria.status_filter.join(', ')}`));
        }
        console.log(chalk.gray(`  Sessions: ${result.total_sessions}`));
        console.log(chalk.gray(`  Completion rate: ${result.completion_rate_percent}%`));
        console.log(chalk.gray(`  Failure rate: ${result.failure_rate_percent}%`));
        console.log(chalk.gray(`  Total goals sum: ${result.total_goals_sum}`));
        console.log(chalk.gray(`  Processed goals sum: ${result.processed_goals_sum}`));
        console.log(chalk.gray(`  Unprocessed goals sum: ${result.unprocessed_goals_sum}`));
        if (result.status_counts && Object.keys(result.status_counts).length > 0) {
          console.log(chalk.gray(`  Status counts: ${JSON.stringify(result.status_counts)}`));
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoBatchSession
    .command('prune')
    .description('Prune old close-loop-batch summary sessions by retention policy')
    .option('--keep <n>', 'Keep newest N sessions (default: 20)', parseInt)
    .option('--older-than-days <n>', 'Only prune sessions older than N days', parseInt)
    .option('--dry-run', 'Preview prune result without deleting files')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await pruneCloseLoopBatchSummarySessionsCli(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }

        console.log(chalk.blue('Close-loop-batch summary session prune summary:'));
        console.log(chalk.gray(`  Total: ${result.total_sessions}`));
        console.log(chalk.gray(`  Kept: ${result.kept_sessions}`));
        console.log(chalk.gray(`  Deleted: ${result.deleted_count}`));
        if (result.dry_run) {
          console.log(chalk.gray('  Mode: dry-run (no files deleted)'));
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  const autoControllerSession = auto
    .command('controller-session')
    .description('Manage close-loop-controller summary sessions');

  autoControllerSession
    .command('list')
    .description('List persisted close-loop-controller summary sessions')
    .option('--limit <n>', 'Maximum sessions to show (default: 20)', parseInt)
    .option('--status <statuses>', 'Filter by status token(s), comma-separated (case-insensitive)')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await listCloseLoopControllerSessions(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }

        if (result.total === 0) {
          console.log(chalk.gray('No close-loop-controller summary sessions found.'));
          return;
        }

        if (Array.isArray(result.status_filter) && result.status_filter.length > 0) {
          console.log(chalk.gray(`Status filter: ${result.status_filter.join(', ')}`));
        }
        console.log(chalk.blue(`Close-loop-controller summary sessions (${result.total}):`));
        if (result.status_counts && Object.keys(result.status_counts).length > 0) {
          console.log(chalk.gray(`  Status counts: ${JSON.stringify(result.status_counts)}`));
        }
        result.sessions.forEach(session => {
          const updated = session.updated_at || 'unknown-time';
          const status = session.status || 'unknown';
          const processed = Number(session.processed_goals);
          const pending = Number(session.pending_goals);
          const processedDisplay = Number.isFinite(processed) ? processed : '?';
          const totalDisplay = (Number.isFinite(processed) && Number.isFinite(pending))
            ? processed + pending
            : '?';
          console.log(chalk.gray(`- ${session.id} | ${status} | ${updated} | processed ${processedDisplay}/${totalDisplay}`));
        });
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoControllerSession
    .command('stats')
    .description('Aggregate persisted close-loop-controller summary session telemetry')
    .option('--days <n>', 'Only include sessions updated within last N days', parseInt)
    .option('--status <statuses>', 'Filter by status token(s), comma-separated (case-insensitive)')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await statsCloseLoopControllerSessions(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }

        if (result.total_sessions === 0) {
          console.log(chalk.gray('No close-loop-controller summary sessions found for the selected stats filter.'));
          return;
        }

        console.log(chalk.blue('Close-loop-controller session stats:'));
        if (result.criteria.days !== null) {
          console.log(chalk.gray(`  Window days: ${result.criteria.days}`));
        }
        if (Array.isArray(result.criteria.status_filter) && result.criteria.status_filter.length > 0) {
          console.log(chalk.gray(`  Status filter: ${result.criteria.status_filter.join(', ')}`));
        }
        console.log(chalk.gray(`  Sessions: ${result.total_sessions}`));
        console.log(chalk.gray(`  Completion rate: ${result.completion_rate_percent}%`));
        console.log(chalk.gray(`  Failure rate: ${result.failure_rate_percent}%`));
        console.log(chalk.gray(`  Processed goals sum: ${result.processed_goals_sum}`));
        console.log(chalk.gray(`  Pending goals sum: ${result.pending_goals_sum}`));
        if (result.status_counts && Object.keys(result.status_counts).length > 0) {
          console.log(chalk.gray(`  Status counts: ${JSON.stringify(result.status_counts)}`));
        }
        if (result.queue_format_counts && Object.keys(result.queue_format_counts).length > 0) {
          console.log(chalk.gray(`  Queue formats: ${JSON.stringify(result.queue_format_counts)}`));
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoControllerSession
    .command('prune')
    .description('Prune old close-loop-controller summary sessions by retention policy')
    .option('--keep <n>', 'Keep newest N sessions (default: 20)', parseInt)
    .option('--older-than-days <n>', 'Only prune sessions older than N days', parseInt)
    .option('--dry-run', 'Preview prune result without deleting files')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await pruneCloseLoopControllerSessionsCli(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }

        console.log(chalk.blue('Close-loop-controller summary session prune summary:'));
        console.log(chalk.gray(`  Total: ${result.total_sessions}`));
        console.log(chalk.gray(`  Kept: ${result.kept_sessions}`));
        console.log(chalk.gray(`  Deleted: ${result.deleted_count}`));
        if (result.dry_run) {
          console.log(chalk.gray('  Mode: dry-run (no files deleted)'));
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  // kse auto session
  const autoSession = auto
    .command('session')
    .description('Manage close-loop session snapshots');

  autoSession
    .command('list')
    .description('List persisted close-loop sessions')
    .option('--limit <n>', 'Maximum sessions to show (default: 20)', parseInt)
    .option('--status <statuses>', 'Filter by status token(s), comma-separated (case-insensitive)')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await listCloseLoopSessions(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }

        if (result.total === 0) {
          console.log(chalk.gray('No close-loop sessions found.'));
          return;
        }

        if (Array.isArray(result.status_filter) && result.status_filter.length > 0) {
          console.log(chalk.gray(`Status filter: ${result.status_filter.join(', ')}`));
        }
        console.log(chalk.blue(`Close-loop sessions (${result.total}):`));
        if (result.status_counts && Object.keys(result.status_counts).length > 0) {
          console.log(chalk.gray(`  Status counts: ${JSON.stringify(result.status_counts)}`));
        }
        result.sessions.forEach(session => {
          const updated = session.updated_at || 'unknown-time';
          const master = session.master_spec || 'unknown-master';
          const status = session.status || 'unknown';
          console.log(chalk.gray(`- ${session.id} | ${status} | ${updated} | ${master}`));
        });
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoSession
    .command('stats')
    .description('Aggregate persisted close-loop session telemetry')
    .option('--days <n>', 'Only include sessions updated within last N days', parseInt)
    .option('--status <statuses>', 'Filter by status token(s), comma-separated (case-insensitive)')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await statsCloseLoopSessions(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }

        if (result.total_sessions === 0) {
          console.log(chalk.gray('No close-loop sessions found for the selected stats filter.'));
          return;
        }

        console.log(chalk.blue('Close-loop session stats:'));
        if (result.criteria.days !== null) {
          console.log(chalk.gray(`  Window days: ${result.criteria.days}`));
        }
        if (Array.isArray(result.criteria.status_filter) && result.criteria.status_filter.length > 0) {
          console.log(chalk.gray(`  Status filter: ${result.criteria.status_filter.join(', ')}`));
        }
        console.log(chalk.gray(`  Sessions: ${result.total_sessions}`));
        console.log(chalk.gray(`  Completion rate: ${result.completion_rate_percent}%`));
        console.log(chalk.gray(`  Failure rate: ${result.failure_rate_percent}%`));
        console.log(chalk.gray(`  Sub-spec sum: ${result.sub_spec_count_sum}`));
        console.log(chalk.gray(`  Unique master specs: ${result.unique_master_spec_count}`));
        if (result.status_counts && Object.keys(result.status_counts).length > 0) {
          console.log(chalk.gray(`  Status counts: ${JSON.stringify(result.status_counts)}`));
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoSession
    .command('prune')
    .description('Prune old close-loop sessions by retention policy')
    .option('--keep <n>', 'Keep newest N sessions (default: 20)', parseInt)
    .option('--older-than-days <n>', 'Only prune sessions older than N days', parseInt)
    .option('--dry-run', 'Preview prune result without deleting files')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await pruneCloseLoopSessions(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }

        console.log(chalk.blue('Close-loop session prune summary:'));
        console.log(chalk.gray(`  Total: ${result.total_sessions}`));
        console.log(chalk.gray(`  Kept: ${result.kept_sessions}`));
        console.log(chalk.gray(`  Deleted: ${result.deleted_count}`));
        if (result.dry_run) {
          console.log(chalk.gray('  Mode: dry-run (no files deleted)'));
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  // kse auto spec-session
  const autoSpecSession = auto
    .command('spec-session')
    .description('Manage .kiro/specs directory retention and cleanup');

  autoSpecSession
    .command('list')
    .description('List persisted spec directories under .kiro/specs')
    .option('--limit <n>', 'Maximum specs to show (default: 20)', parseInt)
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await listSpecSessions(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }

        if (result.total === 0) {
          console.log(chalk.gray('No spec directories found.'));
          return;
        }

        console.log(chalk.blue(`Spec directories (${result.total}):`));
        result.specs.forEach(spec => {
          const updated = spec.updated_at || 'unknown-time';
          console.log(chalk.gray(`- ${spec.id} | ${updated} | ${spec.file}`));
        });
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoSpecSession
    .command('prune')
    .description('Prune old spec directories by retention policy')
    .option('--keep <n>', 'Keep newest N spec directories (default: 200)', parseInt)
    .option('--older-than-days <n>', 'Only prune spec directories older than N days', parseInt)
    .option('--no-protect-active', 'Allow pruning directories even when they appear active')
    .option('--protect-window-days <n>', 'Protection window (days) for recent session references (default: 7)', parseInt)
    .option('--show-protection-reasons', 'Include per-spec protection reason details in output')
    .option('--dry-run', 'Preview prune result without deleting directories')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await pruneSpecSessions(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }

        console.log(chalk.blue('Spec directory prune summary:'));
        console.log(chalk.gray(`  Total: ${result.total_specs}`));
        console.log(chalk.gray(`  Kept: ${result.kept_specs}`));
        console.log(chalk.gray(`  Deleted: ${result.deleted_count}`));
        if (result.protected_count > 0) {
          console.log(chalk.gray(`  Protected: ${result.protected_count}`));
        }
        if (result.dry_run) {
          console.log(chalk.gray('  Mode: dry-run (no directories deleted)'));
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  const autoKpi = auto
    .command('kpi')
    .description('Inspect autonomous execution KPI snapshots and trends');

  autoKpi
    .command('trend')
    .description('Aggregate periodic KPI trend from persisted batch/program/recover/controller summaries')
    .option('--weeks <n>', 'Number of recent weeks to include (default: 8)', parseInt)
    .option('--mode <mode>', 'Summary mode filter: all|batch|program|recover|controller (default: all)', 'all')
    .option('--period <period>', 'Bucket period: week|day (default: week)', 'week')
    .option('--csv', 'Output trend buckets as CSV (stdout and --out file)')
    .option('--out <path>', 'Write KPI trend output to file (JSON default, CSV when --csv)')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await buildAutoKpiTrend(process.cwd(), options);
        if (options.out) {
          if (options.csv && !options.json) {
            const csv = formatAutoKpiTrendCsv(result);
            await maybeWriteTextOutput(result, csv, options.out, process.cwd());
          } else {
            await maybeWriteOutput(result, options.out, process.cwd());
          }
        }
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }
        if (options.csv) {
          console.log(formatAutoKpiTrendCsv(result));
          return;
        }

        console.log(chalk.blue('Autonomous KPI trend summary:'));
        console.log(chalk.gray(`  Weeks: ${result.weeks}`));
        console.log(chalk.gray(`  Period: ${result.period_unit}`));
        console.log(chalk.gray(`  Mode: ${result.mode}`));
        console.log(chalk.gray(`  Runs analyzed: ${result.total_runs}`));
        console.log(chalk.gray(`  Overall success rate: ${result.overall.success_rate_percent}%`));
        console.log(chalk.gray(`  Anomalies detected: ${result.anomalies.length}`));
        if (result.trend.length > 0) {
          console.log(chalk.gray('  Trend buckets:'));
          result.trend.forEach(item => {
            console.log(chalk.gray(
              `    - ${item.period}: runs=${item.runs}, success=${item.success_rate_percent}%`
            ));
          });
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  const autoObservability = auto
    .command('observability')
    .description('Build unified autonomous observability snapshots across archives and trends');

  autoObservability
    .command('snapshot')
    .description('Generate one unified observability snapshot for sessions, governance, and KPI trend')
    .option('--days <n>', 'Only include sessions updated within last N days', parseInt)
    .option('--status <statuses>', 'Filter session status token(s), comma-separated (case-insensitive)')
    .option('--weeks <n>', 'Number of recent weeks to include in KPI trend (default: 8)', parseInt)
    .option('--trend-mode <mode>', 'Trend mode: all|batch|program|recover|controller (default: all)', 'all')
    .option('--trend-period <period>', 'Trend period: week|day (default: week)', 'week')
    .option('--out <path>', 'Write observability snapshot JSON to file')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await buildAutoObservabilitySnapshot(process.cwd(), options);
        if (options.out) {
          await maybeWriteOutput(result, options.out, process.cwd());
        }
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }
        console.log(chalk.blue('Autonomous observability snapshot:'));
        if (result.criteria.days !== null) {
          console.log(chalk.gray(`  Window days: ${result.criteria.days}`));
        }
        if (Array.isArray(result.criteria.status_filter) && result.criteria.status_filter.length > 0) {
          console.log(chalk.gray(`  Status filter: ${result.criteria.status_filter.join(', ')}`));
        }
        console.log(chalk.gray(`  Session total: ${result.highlights.total_sessions}`));
        console.log(chalk.gray(`  Completion rate: ${result.highlights.completion_rate_percent}%`));
        console.log(chalk.gray(`  Failure rate: ${result.highlights.failure_rate_percent}%`));
        console.log(chalk.gray(`  Governance risk: ${result.highlights.governance_risk_level}`));
        console.log(chalk.gray(`  Trend anomalies: ${result.highlights.kpi_anomaly_count}`));
        if (result.output_file) {
          console.log(chalk.gray(`  Output: ${result.output_file}`));
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  const autoSpec = auto
    .command('spec')
    .description('Agent-facing spec status and execution instruction interfaces');

  autoSpec
    .command('status <spec-name>')
    .description('Show structured status for one spec directory')
    .option('--json', 'Output machine-readable JSON')
    .action(async (specName, options) => {
      try {
        const result = await buildAutoSpecStatus(process.cwd(), specName);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }
        console.log(chalk.blue(`Spec status: ${result.spec.name}`));
        console.log(chalk.gray(`  Path: ${result.spec.path}`));
        console.log(chalk.gray(`  Collaboration status: ${result.collaboration.status}`));
        console.log(chalk.gray(`  Docs complete: ${result.docs.all_required_present ? 'yes' : 'no'}`));
        console.log(chalk.gray(
          `  Task progress: ${result.task_progress.closed}/${result.task_progress.total} (${result.task_progress.completion_rate_percent}%)`
        ));
        if (result.health.blockers.length > 0) {
          console.log(chalk.gray(`  Blockers: ${result.health.blockers.join(' | ')}`));
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoSpec
    .command('instructions <spec-name>')
    .description('Generate execution instructions for one spec (agent-oriented)')
    .option('--json', 'Output machine-readable JSON')
    .action(async (specName, options) => {
      try {
        const result = await buildAutoSpecInstructions(process.cwd(), specName);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }
        console.log(chalk.blue(`Spec instructions: ${result.spec.name}`));
        result.instructions.next_actions.forEach((item, index) => {
          console.log(chalk.gray(`  ${index + 1}. ${item}`));
        });
        if (result.instructions.priority_open_tasks.length > 0) {
          console.log(chalk.gray('  Priority open tasks:'));
          result.instructions.priority_open_tasks.slice(0, 5).forEach(item => {
            console.log(chalk.gray(`    - ${item}`));
          });
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  const autoHandoff = auto
    .command('handoff')
    .description('Plan and stage dual-track handoff integration workflows');

  autoHandoff
    .command('plan')
    .description('Build an executable KSE integration plan from a handoff manifest JSON')
    .requiredOption('--manifest <path>', 'Path to handoff-manifest.json')
    .option('--out <path>', 'Write generated integration plan JSON to file')
    .option('--strict', 'Fail when manifest validation contains errors')
    .option('--strict-warnings', 'Fail when manifest validation contains warnings')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await buildAutoHandoffPlan(process.cwd(), options);
        if (options.out) {
          await maybeWriteOutput(result, options.out, process.cwd());
        }
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }
        console.log(chalk.blue('Auto handoff integration plan:'));
        console.log(chalk.gray(`  Manifest: ${result.manifest_path}`));
        console.log(chalk.gray(`  Source project: ${result.source_project || 'unknown'}`));
        console.log(chalk.gray(`  Specs: ${result.handoff.spec_count}`));
        console.log(chalk.gray(`  Templates: ${result.handoff.template_count}`));
        console.log(chalk.gray(`  Validation errors: ${result.validation.errors.length}`));
        console.log(chalk.gray(`  Validation warnings: ${result.validation.warnings.length}`));
        console.log(chalk.gray(`  Phases: ${result.phases.length}`));
        if (result.output_file) {
          console.log(chalk.gray(`  Output: ${result.output_file}`));
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoHandoff
    .command('queue')
    .description('Generate close-loop queue goals from a handoff manifest JSON')
    .requiredOption('--manifest <path>', 'Path to handoff-manifest.json')
    .option('--out <path>', `Queue output file (default: ${AUTO_HANDOFF_DEFAULT_QUEUE_FILE})`, AUTO_HANDOFF_DEFAULT_QUEUE_FILE)
    .option('--append', 'Append generated goals to existing queue file')
    .option('--no-include-known-gaps', 'Exclude known_gaps entries from generated queue goals')
    .option('--dry-run', 'Preview generated queue goals without writing file')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await buildAutoHandoffQueue(process.cwd(), options);
        if (!result.dry_run) {
          await writeAutoHandoffQueueFile(process.cwd(), result, options);
        }
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }
        console.log(chalk.blue('Auto handoff queue generated:'));
        console.log(chalk.gray(`  Manifest: ${result.manifest_path}`));
        console.log(chalk.gray(`  Goals: ${result.goal_count}`));
        console.log(chalk.gray(`  Include known gaps: ${result.include_known_gaps ? 'yes' : 'no'}`));
        console.log(chalk.gray(`  Mode: ${result.dry_run ? 'dry-run' : (result.append ? 'append' : 'overwrite')}`));
        if (result.output_file) {
          console.log(chalk.gray(`  Queue file: ${result.output_file}`));
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoHandoff
    .command('template-diff')
    .description('Compare manifest templates with local template registry and exports')
    .requiredOption('--manifest <path>', 'Path to handoff-manifest.json')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await buildAutoHandoffTemplateDiff(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }
        console.log(chalk.blue('Auto handoff template diff:'));
        console.log(chalk.gray(`  Manifest templates: ${result.manifest.template_count}`));
        console.log(chalk.gray(`  Local templates: ${result.local.template_count}`));
        console.log(chalk.gray(`  Missing in local: ${result.diff.missing_in_local.length}`));
        console.log(chalk.gray(`  Extra in local: ${result.diff.extra_in_local.length}`));
        console.log(chalk.gray(`  Compatibility: ${result.compatibility}`));
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoHandoff
    .command('regression')
    .description('Compare one handoff run report with its previous run')
    .option('--session-id <id|latest>', 'Handoff run session id or "latest"', 'latest')
    .option('--window <n>', 'Number of runs in regression trend window (default: 2)', value => parseInt(value, 10), 2)
    .option('--format <type>', 'Regression report format: json|markdown (default: json)', 'json')
    .option('--out <path>', 'Write regression report JSON to file')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const outputFormat = normalizeHandoffRegressionFormat(options.format);
        const result = await buildAutoHandoffRegressionReport(process.cwd(), options);
        result.report_format = outputFormat;
        if (options.out) {
          if (outputFormat === 'markdown') {
            const markdown = renderAutoHandoffRegressionMarkdown(result);
            await maybeWriteTextOutput(result, markdown, options.out, process.cwd());
          } else {
            await maybeWriteOutput(result, options.out, process.cwd());
          }
        }
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }
        if (outputFormat === 'markdown') {
          console.log(renderAutoHandoffRegressionMarkdown(result));
          return;
        }
        console.log(chalk.blue('Auto handoff regression:'));
        console.log(chalk.gray(`  Session: ${result.current.session_id}`));
        console.log(chalk.gray(`  Compared to: ${result.previous ? result.previous.session_id : 'none'}`));
        if (result.window) {
          console.log(chalk.gray(`  Window: ${result.window.actual}/${result.window.requested}`));
        }
        console.log(chalk.gray(`  Trend: ${result.trend}`));
        console.log(chalk.gray(`  Success-rate delta: ${result.delta.spec_success_rate_percent}`));
        console.log(chalk.gray(`  Risk-level delta: ${result.delta.risk_level_rank}`));
        if (result.output_file) {
          console.log(chalk.gray(`  Output: ${result.output_file}`));
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoHandoff
    .command('evidence')
    .description('Review merged handoff release evidence snapshot and current session overview')
    .option('--file <path>', `Release evidence file path (default: ${AUTO_HANDOFF_RELEASE_EVIDENCE_FILE})`, AUTO_HANDOFF_RELEASE_EVIDENCE_FILE)
    .option('--session-id <id|latest>', 'Session id to inspect from release evidence', 'latest')
    .option('--window <n>', 'Number of sessions in review window (default: 5)', value => parseInt(value, 10), 5)
    .option('--format <type>', 'Evidence report format: json|markdown (default: json)', 'json')
    .option('--out <path>', 'Write evidence review report to file')
    .option('--review-out <path>', `Write evidence review markdown for release drafting (default: ${AUTO_HANDOFF_EVIDENCE_REVIEW_DEFAULT_FILE})`)
    .option('--release-draft <path>', 'Write release notes draft markdown with handoff evidence summary')
    .option('--release-version <version>', 'Release version tag for release draft (default: v<package.json version>)')
    .option('--release-date <yyyy-mm-dd>', 'Release date for release draft (default: today UTC)')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const projectPath = process.cwd();
        const outputFormat = normalizeHandoffRegressionFormat(options.format);
        const result = await buildAutoHandoffEvidenceReviewReport(projectPath, options);
        result.report_format = outputFormat;
        const reviewMarkdown = renderAutoHandoffEvidenceReviewMarkdown(result);
        if (options.out) {
          if (outputFormat === 'markdown') {
            await maybeWriteTextOutput(result, reviewMarkdown, options.out, projectPath);
          } else {
            await maybeWriteOutput(result, options.out, projectPath);
          }
        }
        if (typeof options.releaseDraft === 'string' && options.releaseDraft.trim()) {
          const reviewOutCandidate = typeof options.reviewOut === 'string' && options.reviewOut.trim()
            ? options.reviewOut.trim()
            : (
              outputFormat === 'markdown' && typeof options.out === 'string' && options.out.trim()
                ? options.out.trim()
                : AUTO_HANDOFF_EVIDENCE_REVIEW_DEFAULT_FILE
            );
          const reviewOutFile = path.isAbsolute(reviewOutCandidate)
            ? reviewOutCandidate
            : path.join(projectPath, reviewOutCandidate);
          await fs.ensureDir(path.dirname(reviewOutFile));
          await fs.writeFile(reviewOutFile, reviewMarkdown, 'utf8');

          const releaseDraftContext = await resolveAutoHandoffReleaseDraftContext(projectPath, options);
          const releaseMarkdown = renderAutoHandoffReleaseNotesDraft(result, {
            version: releaseDraftContext.version,
            releaseDate: releaseDraftContext.releaseDate,
            reviewFile: reviewOutFile
          });
          const releaseDraftCandidate = options.releaseDraft.trim();
          const releaseDraftFile = path.isAbsolute(releaseDraftCandidate)
            ? releaseDraftCandidate
            : path.join(projectPath, releaseDraftCandidate);
          await fs.ensureDir(path.dirname(releaseDraftFile));
          await fs.writeFile(releaseDraftFile, releaseMarkdown, 'utf8');
          result.release_draft = {
            file: releaseDraftFile,
            version: releaseDraftContext.version,
            release_date: releaseDraftContext.releaseDate,
            review_file: reviewOutFile
          };
        }
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }
        if (outputFormat === 'markdown') {
          console.log(renderAutoHandoffEvidenceReviewMarkdown(result));
          return;
        }
        console.log(chalk.blue('Auto handoff release evidence review:'));
        console.log(chalk.gray(`  Evidence file: ${result.evidence_file}`));
        console.log(chalk.gray(`  Session: ${result.current && result.current.session_id ? result.current.session_id : 'n/a'}`));
        console.log(chalk.gray(`  Status: ${result.current && result.current.status ? result.current.status : 'n/a'}`));
        console.log(chalk.gray(`  Trend: ${result.trend}`));
        if (result.window) {
          console.log(chalk.gray(`  Window: ${result.window.actual}/${result.window.requested}`));
        }
        if (result.current_overview && result.current_overview.gate) {
          console.log(chalk.gray(`  Gate passed: ${result.current_overview.gate.passed ? 'yes' : 'no'}`));
        }
        if (result.current_overview && result.current_overview.moqui_baseline) {
          const moquiBaseline = result.current_overview.moqui_baseline;
          const moquiSummary = moquiBaseline && moquiBaseline.summary ? moquiBaseline.summary : null;
          console.log(chalk.gray(`  Moqui baseline: ${moquiBaseline.status || 'n/a'}`));
          if (moquiSummary) {
            const scoreText = Number.isFinite(Number(moquiSummary.avg_score))
              ? `${moquiSummary.avg_score}`
              : 'n/a';
            const validRateText = Number.isFinite(Number(moquiSummary.valid_rate_percent))
              ? `${moquiSummary.valid_rate_percent}%`
              : 'n/a';
            console.log(chalk.gray(`    Portfolio: ${moquiSummary.portfolio_passed === true ? 'pass' : 'fail'} | avg=${scoreText} | valid-rate=${validRateText}`));
          }
        }
        if (result.current_overview && result.current_overview.scene_package_batch) {
          const scenePackageBatch = result.current_overview.scene_package_batch;
          const sceneSummary = scenePackageBatch && scenePackageBatch.summary ? scenePackageBatch.summary : null;
          console.log(chalk.gray(`  Scene package batch: ${scenePackageBatch.status || 'n/a'}`));
          if (sceneSummary) {
            console.log(
              chalk.gray(
                `    Selected: ${sceneSummary.selected || 0} | ` +
                `failed=${sceneSummary.failed || 0} | ` +
                `batch-gate=${sceneSummary.batch_gate_passed === true ? 'pass' : 'fail'}`
              )
            );
          }
        }
        if (result.current_overview && result.current_overview.capability_coverage) {
          const capabilityCoverage = result.current_overview.capability_coverage;
          const capabilitySummary = capabilityCoverage && capabilityCoverage.summary ? capabilityCoverage.summary : null;
          console.log(chalk.gray(`  Capability coverage: ${capabilityCoverage.status || 'n/a'}`));
          if (capabilitySummary) {
            const coverageText = Number.isFinite(Number(capabilitySummary.coverage_percent))
              ? `${capabilitySummary.coverage_percent}%`
              : 'n/a';
            console.log(
              chalk.gray(
                `    Passed: ${capabilitySummary.passed === true ? 'yes' : 'no'} | ` +
                `coverage=${coverageText} | min=${capabilitySummary.min_required_percent}%`
              )
            );
          }
        }
        if (result.output_file) {
          console.log(chalk.gray(`  Output: ${result.output_file}`));
        }
        if (result.release_draft && result.release_draft.file) {
          console.log(chalk.gray(`  Release draft: ${result.release_draft.file}`));
          console.log(chalk.gray(`  Review markdown: ${result.release_draft.review_file}`));
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoHandoff
    .command('gate-index')
    .description('Build release gate history index from release-gate reports')
    .option('--dir <path>', `Directory containing release-gate-*.json files (default: ${AUTO_HANDOFF_RELEASE_EVIDENCE_DIR})`, AUTO_HANDOFF_RELEASE_EVIDENCE_DIR)
    .option('--history-file <path>', 'Optional existing history index JSON to merge')
    .option('--keep <n>', 'Keep latest N entries in index (default: 200)', value => parseInt(value, 10), 200)
    .option('--out <path>', `Write gate history index JSON to file (default: ${AUTO_HANDOFF_RELEASE_GATE_HISTORY_FILE})`, AUTO_HANDOFF_RELEASE_GATE_HISTORY_FILE)
    .option('--markdown-out <path>', 'Write human-readable gate history markdown summary')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const projectPath = process.cwd();
        const result = await buildAutoHandoffReleaseGateHistoryIndex(projectPath, options);
        await maybeWriteOutput(result, options.out, projectPath);
        if (typeof options.markdownOut === 'string' && options.markdownOut.trim()) {
          const markdownPath = path.isAbsolute(options.markdownOut.trim())
            ? options.markdownOut.trim()
            : path.join(projectPath, options.markdownOut.trim());
          await fs.ensureDir(path.dirname(markdownPath));
          await fs.writeFile(markdownPath, renderAutoHandoffReleaseGateHistoryMarkdown(result), 'utf8');
          result.markdown_file = markdownPath;
        }
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }
        console.log(chalk.blue('Auto handoff release gate history index:'));
        console.log(chalk.gray(`  Source dir: ${result.source_dir}`));
        console.log(chalk.gray(`  Entries: ${result.total_entries}`));
        if (result.latest) {
          console.log(chalk.gray(`  Latest: ${result.latest.tag || 'n/a'} (${result.latest.evaluated_at || 'n/a'})`));
          console.log(chalk.gray(`  Latest gate passed: ${result.latest.gate_passed === true ? 'yes' : (result.latest.gate_passed === false ? 'no' : 'n/a')}`));
        }
        if (result.aggregates) {
          console.log(chalk.gray(`  Gate pass rate: ${formatAutoHandoffRegressionValue(result.aggregates.pass_rate_percent)}%`));
          console.log(chalk.gray(`  Failed gates: ${result.aggregates.gate_failed_count}`));
        }
        if (result.warnings_count > 0) {
          console.log(chalk.yellow(`  Warnings: ${result.warnings_count}`));
        }
        if (result.output_file) {
          console.log(chalk.gray(`  Output: ${result.output_file}`));
        }
        if (result.markdown_file) {
          console.log(chalk.gray(`  Markdown: ${result.markdown_file}`));
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoHandoff
    .command('run')
    .description('Execute handoff integration pipeline: plan -> queue -> close-loop-batch -> observability')
    .requiredOption('--manifest <path>', 'Path to handoff-manifest.json')
    .option('--out <path>', 'Write handoff run report JSON to file')
    .option('--queue-out <path>', `Queue output file (default: ${AUTO_HANDOFF_DEFAULT_QUEUE_FILE})`, AUTO_HANDOFF_DEFAULT_QUEUE_FILE)
    .option('--append', 'Append generated goals to existing queue file')
    .option('--no-include-known-gaps', 'Exclude known_gaps entries from generated queue goals')
    .option('--continue-from <session|latest|file>', 'Continue pending goals from prior handoff run report')
    .option('--continue-strategy <strategy>', 'Resume strategy for --continue-from: auto|pending|failed-only (default: auto)', 'auto')
    .option('--dry-run', 'Preview execution plan and queue without running close-loop-batch')
    .option('--strict', 'Fail when manifest validation contains errors')
    .option('--strict-warnings', 'Fail when manifest validation contains warnings')
    .option('--no-dependency-batching', 'Disable dependency-aware spec execution batches')
    .option('--no-batch-autonomous', 'Disable autonomous batch policy during handoff close-loop execution')
    .option('--no-continue-on-error', 'Stop handoff close-loop-batch on first failed goal')
    .option('--batch-parallel <n>', 'Maximum concurrent goals during close-loop-batch', parseInt)
    .option('--batch-agent-budget <n>', 'Shared parallel-agent budget for close-loop-batch', parseInt)
    .option('--batch-retry-rounds <n>', 'Retry failed goals for N rounds during close-loop-batch', parseInt)
    .option('--batch-retry-until-complete', 'Retry until all goals complete or retry max is reached')
    .option('--batch-retry-max-rounds <n>', 'Max retry rounds when --batch-retry-until-complete is enabled', parseInt)
    .option('--min-spec-success-rate <n>', 'Gate: minimum handoff spec success rate percent (default: 100)', parseFloat)
    .option('--max-risk-level <level>', 'Gate: maximum allowed risk level (low|medium|high)', 'high')
    .option('--min-ontology-score <n>', 'Gate: minimum ontology quality score (0-100, default: 0)', parseFloat)
    .option('--max-unmapped-rules <n>', 'Gate: maximum allowed unmapped business rules (optional)', parseInt)
    .option('--max-undecided-decisions <n>', 'Gate: maximum allowed undecided decisions (optional)', parseInt)
    .option('--require-ontology-validation', 'Gate: require manifest ontology_validation to be present and passed (default: enabled)')
    .option('--no-require-ontology-validation', 'Gate: disable manifest ontology_validation requirement (not recommended)')
    .option('--require-moqui-baseline', 'Gate: require Moqui baseline portfolio to pass (default: enabled)')
    .option('--no-require-moqui-baseline', 'Gate: disable Moqui baseline portfolio requirement (not recommended)')
    .option('--require-scene-package-batch', 'Gate: require scene package publish-batch dry-run gate to pass when applicable (default: enabled)')
    .option('--no-require-scene-package-batch', 'Gate: disable scene package publish-batch dry-run requirement (not recommended)')
    .option('--min-capability-coverage <n>', 'Gate: minimum Moqui capability coverage percent (default: 100)', parseFloat)
    .option('--require-capability-coverage', 'Gate: require capability coverage threshold when capabilities are declared (default: enabled)')
    .option('--no-require-capability-coverage', 'Gate: disable capability coverage requirement (not recommended)')
    .option('--release-evidence-window <n>', 'Release evidence trend window size (2-50, default: 5)', parseInt)
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await runAutoHandoff(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
        } else {
          console.log(chalk.blue('Auto handoff run:'));
          console.log(chalk.gray(`  Session: ${result.session_id}`));
          console.log(chalk.gray(`  Status: ${result.status}`));
          console.log(chalk.gray(`  Manifest: ${result.manifest_path}`));
          console.log(chalk.gray(`  Specs: ${result.handoff && result.handoff.spec_count ? result.handoff.spec_count : 0}`));
          console.log(chalk.gray(`  Queue goals: ${result.queue && result.queue.goal_count ? result.queue.goal_count : 0}`));
          if (result.template_diff) {
            console.log(chalk.gray(`  Template compatibility: ${result.template_diff.compatibility}`));
          }
          if (result.dependency_execution && Array.isArray(result.dependency_execution.batches)) {
            console.log(chalk.gray(`  Execution batches: ${result.dependency_execution.batches.length}`));
          }
          if (result.gates) {
            console.log(chalk.gray(`  Gate passed: ${result.gates.passed ? 'yes' : 'no'}`));
          }
          if (result.moqui_baseline) {
            console.log(chalk.gray(`  Moqui baseline: ${result.moqui_baseline.status || 'unknown'}`));
            if (result.moqui_baseline.summary) {
              const baselineSummary = result.moqui_baseline.summary;
              const scoreText = Number.isFinite(Number(baselineSummary.avg_score))
                ? `${baselineSummary.avg_score}`
                : 'n/a';
              const validRateText = Number.isFinite(Number(baselineSummary.valid_rate_percent))
                ? `${baselineSummary.valid_rate_percent}%`
                : 'n/a';
              console.log(chalk.gray(`    Portfolio: ${baselineSummary.portfolio_passed ? 'pass' : 'fail'} | avg=${scoreText} | valid-rate=${validRateText}`));
            }
            if (result.moqui_baseline.output && result.moqui_baseline.output.json) {
              console.log(chalk.gray(`    Baseline report: ${result.moqui_baseline.output.json}`));
            }
          }
          if (result.scene_package_batch) {
            console.log(chalk.gray(`  Scene package batch: ${result.scene_package_batch.status || 'unknown'}`));
            if (result.scene_package_batch.summary) {
              const sceneSummary = result.scene_package_batch.summary;
              console.log(
                chalk.gray(
                  `    Selected: ${sceneSummary.selected || 0} | ` +
                  `failed=${sceneSummary.failed || 0} | ` +
                  `batch-gate=${sceneSummary.batch_gate_passed === true ? 'pass' : 'fail'}`
                )
              );
            }
            if (result.scene_package_batch.output && result.scene_package_batch.output.json) {
              console.log(chalk.gray(`    Batch report: ${result.scene_package_batch.output.json}`));
            }
          }
          if (result.moqui_capability_coverage) {
            console.log(chalk.gray(`  Capability coverage: ${result.moqui_capability_coverage.status || 'unknown'}`));
            if (result.moqui_capability_coverage.summary) {
              const coverageSummary = result.moqui_capability_coverage.summary;
              const coverageText = Number.isFinite(Number(coverageSummary.coverage_percent))
                ? `${coverageSummary.coverage_percent}%`
                : 'n/a';
              console.log(
                chalk.gray(
                  `    Passed: ${coverageSummary.passed === true ? 'yes' : 'no'} | ` +
                  `coverage=${coverageText} | min=${coverageSummary.min_required_percent}%`
                )
              );
            }
          }
          if (result.remediation_queue && result.remediation_queue.file) {
            console.log(chalk.gray(`  Remediation queue: ${toAutoHandoffCliPath(process.cwd(), result.remediation_queue.file)} (${result.remediation_queue.goal_count})`));
          }
          if (result.output_file) {
            console.log(chalk.gray(`  Report: ${result.output_file}`));
          }
          if (result.release_evidence && result.release_evidence.file) {
            const mergeState = result.release_evidence.merged === false
              ? (result.release_evidence.skipped ? 'skipped' : 'failed')
              : 'merged';
            console.log(chalk.gray(`  Release evidence: ${result.release_evidence.file} (${mergeState})`));
          }
          if (Array.isArray(result.recommendations) && result.recommendations.length > 0) {
            console.log(chalk.gray('  Recommendations:'));
            result.recommendations.slice(0, 3).forEach(item => {
              console.log(chalk.gray(`    - ${item}`));
            });
          }
        }
        if (result.status === 'failed') {
          process.exit(1);
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  const autoSchema = auto
    .command('schema')
    .description('Check and migrate autonomous archive schema compatibility');

  autoSchema
    .command('check')
    .description('Check autonomous archive schema compatibility')
    .option('--only <scopes>', 'Scope filter: all|close-loop-session|batch-session|controller-session|governance-session', 'all')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await checkAutoArchiveSchema(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }
        console.log(chalk.blue('Auto archive schema check:'));
        console.log(chalk.gray(`  Scope: ${result.scope.join(', ')}`));
        console.log(chalk.gray(`  Total files: ${result.summary.total_files}`));
        console.log(chalk.gray(`  Compatible: ${result.summary.compatible_files}`));
        console.log(chalk.gray(`  Missing schema_version: ${result.summary.missing_schema_version_files}`));
        console.log(chalk.gray(`  Incompatible: ${result.summary.incompatible_files}`));
        console.log(chalk.gray(`  Parse errors: ${result.summary.parse_error_files}`));
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoSchema
    .command('migrate')
    .description('Backfill or migrate autonomous archive schema_version')
    .option('--only <scopes>', 'Scope filter: all|close-loop-session|batch-session|controller-session|governance-session', 'all')
    .option('--target-version <version>', `Target schema version (default: ${AUTO_ARCHIVE_SCHEMA_VERSION})`, AUTO_ARCHIVE_SCHEMA_VERSION)
    .option('--apply', 'Apply migration writes (default: dry-run)')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await migrateAutoArchiveSchema(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }
        console.log(chalk.blue('Auto archive schema migrate:'));
        console.log(chalk.gray(`  Scope: ${result.scope.join(', ')}`));
        console.log(chalk.gray(`  Target version: ${result.target_version}`));
        console.log(chalk.gray(`  Mode: ${result.dry_run ? 'dry-run' : 'apply'}`));
        console.log(chalk.gray(`  Total files: ${result.summary.total_files}`));
        console.log(chalk.gray(`  Candidates: ${result.summary.candidate_files}`));
        console.log(chalk.gray(`  Updated: ${result.summary.updated_files}`));
        console.log(chalk.gray(`  Parse errors: ${result.summary.parse_error_files}`));
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  const autoGovernance = auto
    .command('governance')
    .description('Aggregate autonomous governance telemetry across archives');

  autoGovernance
    .command('stats')
    .description('Aggregate cross-archive session health, throughput, and recovery memory telemetry')
    .option('--days <n>', 'Only include sessions updated within last N days', parseInt)
    .option('--status <statuses>', 'Filter by status token(s), comma-separated (case-insensitive)')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await buildAutoGovernanceStats(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }

        console.log(chalk.blue('Autonomous governance stats:'));
        if (result.criteria.days !== null) {
          console.log(chalk.gray(`  Window days: ${result.criteria.days}`));
        }
        if (Array.isArray(result.criteria.status_filter) && result.criteria.status_filter.length > 0) {
          console.log(chalk.gray(`  Status filter: ${result.criteria.status_filter.join(', ')}`));
        }
        console.log(chalk.gray(`  Total sessions: ${result.totals.total_sessions}`));
        console.log(chalk.gray(`  Completion rate: ${result.totals.completion_rate_percent}%`));
        console.log(chalk.gray(`  Failure rate: ${result.totals.failure_rate_percent}%`));
        console.log(chalk.gray(`  Risk level: ${result.health.risk_level}`));
        if (Array.isArray(result.health.concerns) && result.health.concerns.length > 0) {
          console.log(chalk.gray(`  Concerns: ${result.health.concerns.length}`));
        }
        console.log(chalk.gray(`  Recovery signatures: ${result.recovery_memory.signature_count}`));
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoGovernance
    .command('maintain')
    .description('Plan and optionally apply governance maintenance actions for autonomous archives')
    .option('--days <n>', 'Only include sessions updated within last N days for assessment', parseInt)
    .option('--status <statuses>', 'Filter assessment by status token(s), comma-separated (case-insensitive)')
    .option('--session-keep <n>', 'Keep newest N close-loop sessions during maintenance (default: 50)', parseInt)
    .option('--batch-session-keep <n>', 'Keep newest N close-loop-batch sessions during maintenance (default: 50)', parseInt)
    .option('--controller-session-keep <n>', 'Keep newest N close-loop-controller sessions during maintenance (default: 50)', parseInt)
    .option('--recovery-memory-older-than-days <n>', 'Prune recovery-memory entries older than N days (default: 90)', parseInt)
    .option('--apply', 'Apply planned maintenance actions (default: plan-only)')
    .option('--dry-run', 'Preview actions without deleting files')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await runAutoGovernanceMaintenance(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }

        console.log(chalk.blue('Autonomous governance maintenance:'));
        console.log(chalk.gray(`  Apply mode: ${result.apply ? 'enabled' : 'plan-only'}`));
        if (result.dry_run) {
          console.log(chalk.gray('  Dry-run: true'));
        }
        console.log(chalk.gray(`  Planned actions: ${result.summary.planned_actions}`));
        console.log(chalk.gray(`  Applied actions: ${result.summary.applied_actions}`));
        console.log(chalk.gray(`  Failed actions: ${result.summary.failed_actions}`));
        console.log(chalk.gray(`  Risk before: ${result.assessment.health.risk_level}`));
        if (result.after_assessment) {
          console.log(chalk.gray(`  Risk after: ${result.after_assessment.health.risk_level}`));
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoGovernance
    .command('close-loop')
    .description('Run governance maintenance rounds until target risk or stop condition is reached')
    .option('--days <n>', 'Only include sessions updated within last N days for assessment', parseInt)
    .option('--status <statuses>', 'Filter assessment by status token(s), comma-separated (case-insensitive)')
    .option('--session-keep <n>', 'Keep newest N close-loop sessions during maintenance (default: 50)', parseInt)
    .option('--batch-session-keep <n>', 'Keep newest N close-loop-batch sessions during maintenance (default: 50)', parseInt)
    .option('--controller-session-keep <n>', 'Keep newest N close-loop-controller sessions during maintenance (default: 50)', parseInt)
    .option('--recovery-memory-older-than-days <n>', 'Prune recovery-memory entries older than N days (default: 90)', parseInt)
    .option('--max-rounds <n>', 'Max governance rounds (default: 3)', parseInt)
    .option('--target-risk <level>', 'Target risk level: low|medium|high (default: low)', 'low')
    .option('--governance-resume <session>', 'Resume governance close-loop from a prior session id, "latest", or JSON file path')
    .option('--governance-resume-allow-drift', 'Allow overriding persisted governance resume policy (target/advisory settings)')
    .option('--governance-session-id <id>', 'Set explicit governance close-loop session id for persistence')
    .option('--no-governance-session', 'Disable governance close-loop session persistence')
    .option('--governance-session-keep <n>', 'Prune governance close-loop sessions after run and keep newest N snapshots', parseInt)
    .option('--governance-session-older-than-days <n>', 'When pruning governance sessions, only delete sessions older than N days', parseInt)
    .option('--execute-advisory', 'Execute advisory actions (recover/controller resume) when detected')
    .option('--advisory-recover-max-rounds <n>', 'Max rounds for advisory recover execution (default: 3)', parseInt)
    .option('--advisory-controller-max-cycles <n>', 'Max cycles for advisory controller resume execution (default: 20)', parseInt)
    .option('--plan-only', 'Do not apply mutations; run one planning round only')
    .option('--dry-run', 'Preview maintenance actions without deleting files')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options, command) => {
      try {
        const optionSources = getCommandOptionSources(command, [
          'maxRounds',
          'targetRisk',
          'executeAdvisory',
          'advisoryRecoverMaxRounds',
          'advisoryControllerMaxCycles',
          'governanceResumeAllowDrift'
        ]);
        const result = await runAutoGovernanceCloseLoop(process.cwd(), {
          ...options,
          optionSources
        });
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }

        console.log(chalk.blue('Autonomous governance close-loop:'));
        console.log(chalk.gray(`  Rounds: ${result.performed_rounds}/${result.max_rounds}`));
        console.log(chalk.gray(`  Target risk: ${result.target_risk}`));
        console.log(chalk.gray(`  Final risk: ${result.final_assessment.health.risk_level}`));
        console.log(chalk.gray(`  Converged: ${result.converged ? 'yes' : 'no'}`));
        console.log(chalk.gray(`  Advisory execution: ${result.execute_advisory ? 'enabled' : 'disabled'}`));
        if (result.execute_advisory && result.advisory_summary) {
          console.log(chalk.gray(`  Advisory executed: ${result.advisory_summary.executed_actions}`));
          console.log(chalk.gray(`  Advisory failed: ${result.advisory_summary.failed_actions}`));
        }
        if (result.resumed_from_governance_session && result.resumed_from_governance_session.id) {
          console.log(chalk.gray(`  Resumed from governance session: ${result.resumed_from_governance_session.id}`));
        }
        if (result.governance_session && result.governance_session.file) {
          console.log(chalk.gray(`  Governance session: ${result.governance_session.file}`));
        }
        console.log(chalk.gray(`  Stop reason: ${result.stop_reason}`));
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  const autoGovernanceSession = autoGovernance
    .command('session')
    .description('Manage governance close-loop sessions');

  autoGovernanceSession
    .command('list')
    .description('List persisted governance close-loop sessions')
    .option('--limit <n>', 'Maximum governance sessions to return (default: 20)', parseInt)
    .option('--status <statuses>', 'Filter by status token(s), comma-separated (case-insensitive)')
    .option('--resume-only', 'Only include sessions resumed from a prior governance session')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await listGovernanceCloseLoopSessions(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }
        if (result.total === 0) {
          console.log(chalk.gray('No governance close-loop sessions found.'));
          return;
        }
        console.log(chalk.blue(`Governance close-loop sessions (showing ${result.sessions.length}/${result.total}):`));
        if (result.resume_only) {
          console.log(chalk.gray('  Resume-only filter: enabled'));
        }
        console.log(chalk.gray(`  Resumed sessions: ${result.resumed_sessions}`));
        console.log(chalk.gray(`  Fresh sessions: ${result.fresh_sessions}`));
        for (const session of result.sessions) {
          const rounds = Number.isInteger(Number(session.performed_rounds))
            ? `${session.performed_rounds}/${session.max_rounds}`
            : 'n/a';
          console.log(chalk.gray(
            `- ${session.id} [${session.status}] rounds=${rounds} ` +
            `converged=${session.converged ? 'yes' : 'no'} ` +
            `updated=${session.updated_at || 'unknown'}`
          ));
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoGovernanceSession
    .command('stats')
    .description('Aggregate governance close-loop session telemetry')
    .option('--days <n>', 'Only include sessions updated within last N days', parseInt)
    .option('--status <statuses>', 'Filter by status token(s), comma-separated (case-insensitive)')
    .option('--resume-only', 'Only include sessions resumed from a prior governance session')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await statsGovernanceCloseLoopSessions(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }
        if (result.total_sessions === 0) {
          console.log(chalk.gray('No governance close-loop sessions found for the selected stats filter.'));
          return;
        }
        console.log(chalk.blue('Governance close-loop session stats:'));
        if (result.criteria.days !== null) {
          console.log(chalk.gray(`  Window days: ${result.criteria.days}`));
        }
        if (Array.isArray(result.criteria.status_filter) && result.criteria.status_filter.length > 0) {
          console.log(chalk.gray(`  Status filter: ${result.criteria.status_filter.join(', ')}`));
        }
        if (result.criteria.resume_only) {
          console.log(chalk.gray('  Resume-only filter: enabled'));
        }
        console.log(chalk.gray(`  Total sessions: ${result.total_sessions}`));
        console.log(chalk.gray(`  Resumed sessions: ${result.resumed_sessions}`));
        console.log(chalk.gray(`  Fresh sessions: ${result.fresh_sessions}`));
        console.log(chalk.gray(`  Completed: ${result.completed_sessions}`));
        console.log(chalk.gray(`  Failed: ${result.failed_sessions}`));
        console.log(chalk.gray(`  Converged: ${result.converged_sessions}`));
        console.log(chalk.gray(`  Average rounds: ${result.average_performed_rounds}`));
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoGovernanceSession
    .command('prune')
    .description('Prune old governance close-loop sessions by retention policy')
    .option('--keep <n>', 'Keep newest N sessions (default: 20)', parseInt)
    .option('--older-than-days <n>', 'Only prune sessions older than N days', parseInt)
    .option('--dry-run', 'Preview actions without deleting files')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await pruneGovernanceCloseLoopSessions(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }
        console.log(chalk.blue('Governance close-loop session prune:'));
        console.log(chalk.gray(`  Candidates: ${result.candidates.length}`));
        console.log(chalk.gray(`  Deleted: ${result.deleted_count}`));
        if (result.dry_run) {
          console.log(chalk.gray('  Dry-run: true'));
        }
        if (result.errors.length > 0) {
          console.log(chalk.yellow(`  Errors: ${result.errors.length}`));
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  const autoRecoveryMemory = auto
    .command('recovery-memory')
    .description('Inspect and maintain close-loop recovery strategy memory');

  autoRecoveryMemory
    .command('show')
    .description('Show persisted recovery memory and summary statistics')
    .option('--scope <scope>', 'Filter memory by scope key')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await showCloseLoopRecoveryMemory(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }
        console.log(chalk.blue('Recovery memory summary:'));
        console.log(chalk.gray(`  Signatures: ${result.stats.signature_count}`));
        console.log(chalk.gray(`  Actions: ${result.stats.action_count}`));
        console.log(chalk.gray(`  File: ${result.file}`));
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoRecoveryMemory
    .command('scopes')
    .description('Show aggregated recovery memory statistics by scope')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await showCloseLoopRecoveryMemoryScopes(process.cwd());
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }
        console.log(chalk.blue('Recovery memory scopes:'));
        result.scopes.forEach(scope => {
          console.log(
            chalk.gray(
              `  ${scope.scope}: signatures=${scope.signature_count}, actions=${scope.action_count}, ` +
              `attempts=${scope.attempts}, success-rate=${scope.success_rate_percent}%`
            )
          );
        });
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoRecoveryMemory
    .command('prune')
    .description('Prune old recovery memory entries by age')
    .option('--older-than-days <n>', 'Delete memory entries older than N days (default: 30)', parseInt)
    .option('--scope <scope>', 'Only prune entries in this scope')
    .option('--dry-run', 'Preview prune result without writing memory file')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await pruneCloseLoopRecoveryMemory(process.cwd(), options);
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }
        console.log(chalk.blue('Recovery memory prune summary:'));
        console.log(chalk.gray(`  Signatures before: ${result.signatures_before}`));
        console.log(chalk.gray(`  Signatures after: ${result.signatures_after}`));
        console.log(chalk.gray(`  Actions removed: ${result.actions_removed}`));
        if (result.dry_run) {
          console.log(chalk.gray('  Mode: dry-run (no file updated)'));
        }
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });

  autoRecoveryMemory
    .command('clear')
    .description('Clear persisted recovery memory')
    .option('--json', 'Output machine-readable JSON')
    .action(async (options) => {
      try {
        const result = await clearCloseLoopRecoveryMemory(process.cwd());
        if (options.json) {
          console.log(JSON.stringify(result, null, 2));
          return;
        }
        console.log(chalk.blue('Recovery memory cleared.'));
        console.log(chalk.gray(`  File: ${result.file}`));
      } catch (error) {
        if (options.json) {
          console.log(JSON.stringify({ success: false, error: error.message }, null, 2));
        } else {
          console.error(chalk.red(`Error: ${error.message}`));
        }
        process.exit(1);
      }
    });
}

/**
 * Load configuration
 * @param {string} mode - Execution mode
 * @returns {Object} - Configuration
 */
async function loadConfig(mode) {
  const globalConfigPath = path.join(process.cwd(), '.kiro', 'auto', 'config.json');
  
  let globalConfig = {};
  if (await fs.pathExists(globalConfigPath)) {
    globalConfig = await fs.readJson(globalConfigPath);
  }
  
  if (mode) {
    globalConfig.mode = mode;
  }
  
  return mergeConfigs(globalConfig, {});
}

/**
 * Generate Spec name from description
 * @param {string} description - Feature description
 * @returns {string} - Spec name
 */
function generateSpecName(description) {
  const words = description.toLowerCase().split(/\s+/).slice(0, 3);
  const name = words.join('-').replace(/[^a-z0-9-]/g, '');
  const number = Math.floor(Math.random() * 1000);
  return `${number.toString().padStart(2, '0')}-00-${name}`;
}

function applyCloseLoopOptions(command, options = {}) {
  command
    .option('--subs <n>', 'Number of sub-specs to create (2-5)', parseInt)
    .option('--max-parallel <n>', 'Maximum parallel agents for orchestration', parseInt)
    .option('--prefix <n>', 'Use explicit Spec prefix number', parseInt)
    .option('--dod-tests <command>', 'Run a final DoD test command (for example: "npm run test:smoke")')
    .option('--dod-tests-timeout <ms>', 'Timeout (ms) for --dod-tests command', parseInt)
    .option('--dod-max-risk-level <level>', 'DoD risk gate: maximum derived run risk (low|medium|high)')
    .option('--dod-kpi-min-completion-rate <n>', 'DoD KPI gate: minimum completion rate percent (0-100)', parseFloat)
    .option('--dod-max-success-rate-drop <n>', 'DoD baseline gate: max allowed success-rate drop vs historical baseline (0-100)', parseFloat)
    .option('--dod-baseline-window <n>', 'DoD baseline gate: historical session window size (default: 5)', parseInt)
    .option('--no-dod-docs', 'Skip DoD doc completeness gate (requirements/design/tasks)')
    .option('--no-dod-collab', 'Skip DoD collaboration completed-status gate')
    .option('--dod-tasks-closed', 'Require all generated tasks checklists to be fully closed')
    .option('--no-dod', 'Disable all DoD gates')
    .option('--dod-report <path>', 'Write DoD evidence report JSON (default: .kiro/specs/<master>/custom/dod-report.json)')
    .option('--no-dod-report', 'Disable automatic DoD report archive')
    .option('--resume <session-or-file>', 'Resume close-loop from a prior session id, "latest", "interrupted", or a JSON file path')
    .option('--session-id <id>', 'Set explicit close-loop session id for persistence')
    .option('--no-session', 'Disable close-loop session persistence')
    .option('--session-keep <n>', 'After close-loop, keep newest N session snapshots and prune older ones', parseInt)
    .option('--session-older-than-days <n>', 'Only prune sessions older than N days when session retention is enabled', parseInt)
    .option('--replan-strategy <strategy>', 'Replan budget strategy: fixed|adaptive (default: adaptive)')
    .option('--replan-attempts <n>', 'Maximum automatic replan cycles after failed orchestration (default: 1)', parseInt)
    .option('--replan-no-progress-window <n>', 'Stop replan when no progress is detected for N consecutive failed cycles (default: 3)', parseInt)
    .option('--no-replan', 'Disable automatic replan on orchestration failure')
    .option('--no-conflict-governance', 'Disable master/sub lease-conflict prediction and auto-reorder')
    .option('--no-ontology-guidance', 'Disable scene ontology agent-hints guidance for sub-spec scheduling')
    .option('--no-run', 'Generate portfolio and metadata only (skip orchestration run)')
    .option('--no-stream', 'Disable live orchestration status stream during execution')
    .option('--dry-run', 'Preview decomposition without writing files')
    .option('--json', 'Output machine-readable JSON');

  if (options.includeOut) {
    command.option('--out <path>', 'Write result JSON to file');
  }

  return command;
}

function normalizeBatchFormat(formatCandidate) {
  const normalized = typeof formatCandidate === 'string'
    ? formatCandidate.trim().toLowerCase()
    : 'auto';
  if (!['auto', 'json', 'lines'].includes(normalized)) {
    throw new Error('--format must be one of: auto, json, lines');
  }
  return normalized;
}

function parseGoalsFromJsonPayload(payload) {
  if (Array.isArray(payload)) {
    return payload;
  }
  if (payload && typeof payload === 'object' && Array.isArray(payload.goals)) {
    return payload.goals;
  }
  throw new Error('JSON goals file must be an array of strings or an object with a "goals" array.');
}

function parseGoalsFromLines(content) {
  return `${content || ''}`
    .split(/\r?\n/)
    .map(line => line.trim())
    .filter(line => line && !line.startsWith('#'));
}

async function loadCloseLoopBatchGoals(projectPath, goalsFile, formatCandidate) {
  const resolvedFile = path.isAbsolute(goalsFile)
    ? goalsFile
    : path.join(projectPath, goalsFile);
  if (!(await fs.pathExists(resolvedFile))) {
    throw new Error(`Goals file not found: ${resolvedFile}`);
  }

  const format = normalizeBatchFormat(formatCandidate);
  const isJsonByExtension = resolvedFile.toLowerCase().endsWith('.json');
  const useJson = format === 'json' || (format === 'auto' && isJsonByExtension);
  let goals = [];

  if (useJson) {
    let payload = null;
    try {
      payload = await fs.readJson(resolvedFile);
    } catch (error) {
      throw new Error(`Invalid JSON goals file: ${resolvedFile} (${error.message})`);
    }
    goals = parseGoalsFromJsonPayload(payload);
  } else {
    const content = await fs.readFile(resolvedFile, 'utf8');
    goals = parseGoalsFromLines(content);
  }

  const normalizedGoals = goals
    .map(item => `${item || ''}`.trim())
    .filter(Boolean);
  if (normalizedGoals.length === 0) {
    throw new Error(`No valid goals found in file: ${resolvedFile}`);
  }

  return {
    file: resolvedFile,
    goals: normalizedGoals
  };
}

const PROGRAM_CATEGORY_GOAL_LIBRARY = {
  closeLoop: 'Build automatic closed-loop progression without manual confirmation waits for the program scope.',
  decomposition: 'Split broad functional scope into coordinated master/sub specs with explicit dependency ownership.',
  orchestration: 'Harden orchestration scheduling, parallel execution, and shared resource governance for multi-spec delivery.',
  quality: 'Enforce quality gates, tests, and observability evidence across all autonomous execution tracks.',
  docs: 'Complete documentation and rollout guidance so autonomous workflows can be repeatedly operated at scale.'
};
const DEFAULT_PROGRAM_DECOMPOSITION_MIN_QUALITY_SCORE = 70;
const PROGRAM_GATE_PROFILE_POLICY = {
  default: {
    minSuccessRate: 100,
    maxRiskLevel: 'high',
    maxElapsedMinutes: null,
    maxAgentBudget: null,
    maxTotalSubSpecs: null
  },
  dev: {
    minSuccessRate: 80,
    maxRiskLevel: 'high',
    maxElapsedMinutes: 240,
    maxAgentBudget: 60,
    maxTotalSubSpecs: 500
  },
  staging: {
    minSuccessRate: 95,
    maxRiskLevel: 'medium',
    maxElapsedMinutes: 120,
    maxAgentBudget: 30,
    maxTotalSubSpecs: 300
  },
  prod: {
    minSuccessRate: 100,
    maxRiskLevel: 'low',
    maxElapsedMinutes: 60,
    maxAgentBudget: 12,
    maxTotalSubSpecs: 120
  }
};

function normalizeProgramGoalCount(programGoalsCandidate, fallbackCount) {
  if (programGoalsCandidate === undefined || programGoalsCandidate === null) {
    return fallbackCount;
  }

  const parsed = Number(programGoalsCandidate);
  if (!Number.isInteger(parsed) || parsed < 2 || parsed > 12) {
    throw new Error('--program-goals must be an integer between 2 and 12.');
  }
  return parsed;
}

function inferProgramGoalCount(semantic) {
  const clauseCount = Array.isArray(semantic && semantic.clauses) ? semantic.clauses.length : 0;
  const activeCategories = semantic && semantic.categoryScores
    ? Object.values(semantic.categoryScores).filter(score => score > 0).length
    : 0;

  if (clauseCount >= 8 || activeCategories >= 4) {
    return 5;
  }
  if (clauseCount >= 5 || activeCategories >= 3) {
    return 4;
  }
  return 3;
}

function normalizeProgramMinQualityScore(scoreCandidate) {
  if (scoreCandidate === undefined || scoreCandidate === null) {
    return DEFAULT_PROGRAM_DECOMPOSITION_MIN_QUALITY_SCORE;
  }
  const parsed = Number(scoreCandidate);
  if (Number.isNaN(parsed) || parsed < 0 || parsed > 100) {
    throw new Error('--program-min-quality-score must be a number between 0 and 100.');
  }
  return Number(parsed.toFixed(2));
}

function scoreProgramGoalClause(clause) {
  const text = `${clause || ''}`.trim().toLowerCase();
  if (!text) {
    return 0;
  }

  const words = text.split(/\s+/).filter(Boolean).length;
  const connectorSignals = (text.match(/,|;| and | with | plus |并且|以及|并行|同时/g) || []).length;
  const domainSignals = (text.match(
    /orchestrat|integration|migration|observability|quality|security|performance|resilience|compliance|governance|闭环|主从|并行|重规划/g
  ) || []).length;
  return words + (connectorSignals * 2) + (domainSignals * 3);
}

function buildProgramGoalDecompositionQuality(semantic, generatedGoals, targetGoalCount) {
  const goals = Array.isArray(generatedGoals) ? generatedGoals : [];
  const rankedCategories = Array.isArray(semantic && semantic.rankedCategories)
    ? semantic.rankedCategories
    : [];
  const categoryScores = semantic && semantic.categoryScores && typeof semantic.categoryScores === 'object'
    ? semantic.categoryScores
    : {};
  const activeCategoryCount = Object.values(categoryScores)
    .filter(value => Number(value) > 0)
    .length;
  const averageGoalWords = goals.length === 0
    ? 0
    : Number((
      goals
        .map(goal => `${goal || ''}`.trim().split(/\s+/).filter(Boolean).length)
        .reduce((sum, value) => sum + value, 0) / goals.length
    ).toFixed(2));
  const normalizedGoalSeeds = goals
    .map(goal => `${goal || ''}`.toLowerCase().replace(/[0-9]+/g, '#').replace(/[^a-z\u4e00-\u9fff# ]+/g, ' '))
    .map(goal => goal.split(/\s+/).filter(Boolean).slice(0, 8).join(' '))
    .filter(Boolean);
  const uniqueGoalSeeds = new Set(normalizedGoalSeeds);
  const diversityRatio = goals.length === 0
    ? 1
    : Math.min(1, uniqueGoalSeeds.size / goals.length);
  const coverageRatio = targetGoalCount <= 0
    ? 1
    : Math.min(1, goals.length / targetGoalCount);
  const categoryCoverageRatio = activeCategoryCount <= 0
    ? 1
    : Math.min(1, rankedCategories.length / activeCategoryCount);
  const warnings = [];
  if (goals.length < targetGoalCount) {
    warnings.push('under-produced-goals');
  }
  if (averageGoalWords < 6) {
    warnings.push('goals-too-short');
  }
  if (activeCategoryCount >= 3 && rankedCategories.length < 2) {
    warnings.push('category-coverage-low');
  }
  if (diversityRatio < 0.6) {
    warnings.push('goal-diversity-low');
  }

  const score = Number((
    (coverageRatio * 45) +
    (categoryCoverageRatio * 25) +
    (Math.min(1, averageGoalWords / 12) * 20) +
    (diversityRatio * 10)
  ).toFixed(2));
  return {
    score,
    coverage_ratio_percent: Number((coverageRatio * 100).toFixed(2)),
    category_coverage_ratio_percent: Number((categoryCoverageRatio * 100).toFixed(2)),
    diversity_ratio_percent: Number((diversityRatio * 100).toFixed(2)),
    average_goal_words: averageGoalWords,
    warnings
  };
}

function buildRefinedProgramGoalFromClause(clause, contextGoal) {
  const normalizedClause = `${clause || ''}`.replace(/\s+/g, ' ').trim().replace(/[.。;；]+$/g, '');
  if (!normalizedClause) {
    return null;
  }
  return (
    `Deliver ${normalizedClause} as a dedicated execution track with implementation tasks, ` +
    `automated validation, and rollout evidence aligned to: ${contextGoal}`
  );
}

function buildRefinedProgramGoalFromCategory(category, contextGoal) {
  const template = PROGRAM_CATEGORY_GOAL_LIBRARY[category];
  if (!template) {
    return null;
  }
  return (
    `${template} Ensure cross-spec coordination, measurable acceptance criteria, ` +
    `and audit-ready output for: ${contextGoal}`
  );
}

function shouldRefineProgramGoalQuality(quality, minQualityScore) {
  const safeQuality = quality && typeof quality === 'object' ? quality : {};
  const warnings = Array.isArray(safeQuality.warnings) ? safeQuality.warnings : [];
  const score = Number(safeQuality.score);
  if (Number.isFinite(score) && score < minQualityScore) {
    return true;
  }
  return warnings.includes('goals-too-short') || warnings.includes('under-produced-goals');
}

function buildCloseLoopBatchGoalsFromGoal(goalCandidate, programGoalsCandidate, settings = {}) {
  const normalizedGoal = `${goalCandidate || ''}`.trim();
  if (!normalizedGoal) {
    throw new Error('--decompose-goal requires a non-empty goal string.');
  }

  const semantic = analyzeGoalSemantics(normalizedGoal);
  const targetGoalCount = normalizeProgramGoalCount(
    programGoalsCandidate,
    inferProgramGoalCount(semantic)
  );
  const minQualityScore = normalizeProgramMinQualityScore(settings.minQualityScore);
  const enforceQualityGate = Boolean(settings.enforceQualityGate);

  const seenGoals = new Set();
  const generatedGoals = [];
  const pushGoal = goal => {
    const normalized = `${goal || ''}`.trim();
    if (!normalized) {
      return;
    }
    const dedupeKey = normalized.toLowerCase();
    if (seenGoals.has(dedupeKey)) {
      return;
    }
    seenGoals.add(dedupeKey);
    generatedGoals.push(normalized);
  };

  const scoredClauses = (semantic.clauses || [])
    .map(clause => `${clause || ''}`.trim())
    .filter(clause => clause.length >= 8)
    .map(clause => ({
      clause,
      score: scoreProgramGoalClause(clause)
    }))
    .sort((left, right) => right.score - left.score);

  for (const item of scoredClauses) {
    if (generatedGoals.length >= targetGoalCount) {
      break;
    }
    pushGoal(item.clause);
  }

  for (const category of semantic.rankedCategories || []) {
    if (generatedGoals.length >= targetGoalCount) {
      break;
    }

    const template = PROGRAM_CATEGORY_GOAL_LIBRARY[category];
    if (!template) {
      continue;
    }
    pushGoal(`${template} Program goal context: ${normalizedGoal}`);
  }

  if (generatedGoals.length === 0) {
    pushGoal(normalizedGoal);
  }
  let finalGoals = generatedGoals.slice(0, targetGoalCount);
  const initialQuality = buildProgramGoalDecompositionQuality(semantic, finalGoals, targetGoalCount);
  let finalQuality = initialQuality;
  let refinementApplied = false;
  let refinementReason = null;

  if (shouldRefineProgramGoalQuality(initialQuality, minQualityScore)) {
    refinementReason = Number(initialQuality.score) < minQualityScore
      ? 'score-below-threshold'
      : 'quality-warning-triggered';
    const refinedGoals = [];
    const refinedSeen = new Set();
    const pushRefinedGoal = goal => {
      const normalized = `${goal || ''}`.trim();
      if (!normalized) {
        return;
      }
      const dedupeKey = normalized.toLowerCase();
      if (refinedSeen.has(dedupeKey)) {
        return;
      }
      refinedSeen.add(dedupeKey);
      refinedGoals.push(normalized);
    };

    for (const item of scoredClauses) {
      if (refinedGoals.length >= targetGoalCount) {
        break;
      }
      pushRefinedGoal(buildRefinedProgramGoalFromClause(item.clause, normalizedGoal));
    }

    for (const category of semantic.rankedCategories || []) {
      if (refinedGoals.length >= targetGoalCount) {
        break;
      }
      pushRefinedGoal(buildRefinedProgramGoalFromCategory(category, normalizedGoal));
    }

    if (refinedGoals.length === 0) {
      pushRefinedGoal(
        `Execute ${normalizedGoal} with coordinated master/sub specs, quality gates, and completion evidence.`
      );
    }

    while (refinedGoals.length < targetGoalCount) {
      pushRefinedGoal(
        `Track ${refinedGoals.length + 1}: Deliver ${normalizedGoal} with implementation tasks, ` +
        'integration checks, and operational handoff evidence.'
      );
    }

    const refinedFinalGoals = refinedGoals.slice(0, targetGoalCount);
    const refinedQuality = buildProgramGoalDecompositionQuality(semantic, refinedFinalGoals, targetGoalCount);
    const refinedWarnings = Array.isArray(refinedQuality.warnings) ? refinedQuality.warnings.length : 0;
    const initialWarnings = Array.isArray(initialQuality.warnings) ? initialQuality.warnings.length : 0;
    if (
      Number(refinedQuality.score) > Number(initialQuality.score) ||
      (Number(refinedQuality.score) === Number(initialQuality.score) && refinedWarnings < initialWarnings)
    ) {
      finalGoals = refinedFinalGoals;
      finalQuality = refinedQuality;
      refinementApplied = true;
    }
  }

  const quality = {
    ...finalQuality,
    refinement: {
      attempted: shouldRefineProgramGoalQuality(initialQuality, minQualityScore),
      applied: refinementApplied,
      min_score: minQualityScore,
      reason: refinementReason,
      before_score: initialQuality.score,
      after_score: finalQuality.score,
      before_warnings: initialQuality.warnings,
      after_warnings: finalQuality.warnings
    }
  };
  if (enforceQualityGate && Number(quality.score) < minQualityScore) {
    const warningText = Array.isArray(quality.warnings) && quality.warnings.length > 0
      ? ` Warnings: ${quality.warnings.join(', ')}.`
      : '';
    throw new Error(
      `Decomposition quality score ${quality.score} is below required ${minQualityScore}.${warningText}`
    );
  }

  return {
    file: '(generated-from-goal)',
    goals: finalGoals,
    generatedFromGoal: {
      goal: normalizedGoal,
      strategy: 'semantic-clause-and-category',
      target_goal_count: targetGoalCount,
      produced_goal_count: finalGoals.length,
      clauses_considered: Array.isArray(semantic.clauses) ? semantic.clauses.length : 0,
      category_scores: semantic.categoryScores || {},
      ranked_categories: semantic.rankedCategories || [],
      quality
    }
  };
}

function normalizeResumeStrategy(resumeStrategyCandidate) {
  const normalized = typeof resumeStrategyCandidate === 'string'
    ? resumeStrategyCandidate.trim().toLowerCase()
    : 'pending';
  if (!['pending', 'failed-only'].includes(normalized)) {
    throw new Error('--resume-strategy must be one of: pending, failed-only');
  }
  return normalized;
}

function getCloseLoopBatchSummaryDir(projectPath) {
  return path.join(projectPath, '.kiro', 'auto', 'close-loop-batch-summaries');
}

async function resolveCloseLoopBatchSummaryFile(projectPath, summaryCandidate) {
  if (typeof summaryCandidate !== 'string' || !summaryCandidate.trim()) {
    throw new Error('--resume-from-summary requires a file path or "latest".');
  }

  const normalizedCandidate = summaryCandidate.trim();
  if (normalizedCandidate.toLowerCase() === 'latest') {
    const summaryDir = getCloseLoopBatchSummaryDir(projectPath);
    if (!(await fs.pathExists(summaryDir))) {
      throw new Error(`No batch summary sessions found in: ${summaryDir}`);
    }
    const candidates = (await fs.readdir(summaryDir))
      .filter(item => item.toLowerCase().endsWith('.json'));
    if (candidates.length === 0) {
      throw new Error(`No batch summary sessions found in: ${summaryDir}`);
    }

    const entries = [];
    for (const file of candidates) {
      const filePath = path.join(summaryDir, file);
      const stats = await fs.stat(filePath);
      entries.push({
        file: filePath,
        mtimeMs: stats.mtimeMs
      });
    }
    entries.sort((a, b) => b.mtimeMs - a.mtimeMs);
    return entries[0].file;
  }

  return path.isAbsolute(normalizedCandidate)
    ? normalizedCandidate
    : path.join(projectPath, normalizedCandidate);
}

async function loadCloseLoopBatchSummaryPayload(projectPath, summaryCandidate) {
  const summaryFile = await resolveCloseLoopBatchSummaryFile(projectPath, summaryCandidate);
  if (!(await fs.pathExists(summaryFile))) {
    throw new Error(`Batch summary file not found: ${summaryFile}`);
  }

  let payload = null;
  try {
    payload = await fs.readJson(summaryFile);
  } catch (error) {
    throw new Error(`Invalid batch summary JSON: ${summaryFile} (${error.message})`);
  }

  if (!payload || typeof payload !== 'object') {
    throw new Error(`Invalid batch summary payload: ${summaryFile}`);
  }

  return {
    file: summaryFile,
    payload
  };
}

function normalizeRecoveryActionIndex(actionCandidate, maxActions, optionLabel = '--use-action') {
  if (!Number.isInteger(maxActions) || maxActions <= 0) {
    return 1;
  }

  if (actionCandidate === undefined || actionCandidate === null) {
    return 1;
  }

  const parsed = Number(actionCandidate);
  const upperBound = Math.max(20, maxActions);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > upperBound) {
    throw new Error(`${optionLabel} must be an integer between 1 and ${upperBound}.`);
  }
  if (parsed > maxActions) {
    throw new Error(`${optionLabel} ${parsed} is out of range. Available remediation actions: 1-${maxActions}.`);
  }
  return parsed;
}

function getCloseLoopRecoveryMemoryFile(projectPath) {
  return path.join(projectPath, '.kiro', 'auto', 'close-loop-recovery-memory.json');
}

async function loadCloseLoopRecoveryMemory(projectPath) {
  const memoryFile = getCloseLoopRecoveryMemoryFile(projectPath);
  const fallbackPayload = {
    version: 1,
    signatures: {}
  };
  if (!(await fs.pathExists(memoryFile))) {
    return {
      file: memoryFile,
      payload: fallbackPayload
    };
  }

  let payload = null;
  try {
    payload = await fs.readJson(memoryFile);
  } catch (error) {
    return {
      file: memoryFile,
      payload: fallbackPayload
    };
  }

  if (!payload || typeof payload !== 'object') {
    return {
      file: memoryFile,
      payload: fallbackPayload
    };
  }

  return {
    file: memoryFile,
    payload: {
      version: Number(payload.version) || 1,
      signatures: payload.signatures && typeof payload.signatures === 'object'
        ? payload.signatures
        : {}
    }
  };
}

function normalizeRecoveryMemoryToken(value) {
  return `${value || ''}`
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .slice(0, 120);
}

async function resolveRecoveryMemoryScope(projectPath, scopeCandidate) {
  const explicitScope = `${scopeCandidate || ''}`.trim();
  if (explicitScope && explicitScope.toLowerCase() !== 'auto') {
    return normalizeRecoveryMemoryToken(explicitScope) || 'default-scope';
  }

  const projectToken = normalizeRecoveryMemoryToken(path.basename(path.resolve(projectPath || '.'))) || 'project';
  const branchToken = await resolveGitBranchToken(projectPath);
  return `${projectToken}|${branchToken || 'default'}`;
}

async function resolveGitBranchToken(projectPath) {
  try {
    const gitMetadataPath = path.join(projectPath, '.git');
    if (!(await fs.pathExists(gitMetadataPath))) {
      return 'no-git';
    }

    let gitDir = gitMetadataPath;
    const gitStat = await fs.stat(gitMetadataPath);
    if (gitStat.isFile()) {
      const pointer = await fs.readFile(gitMetadataPath, 'utf8');
      const match = pointer.match(/gitdir:\s*(.+)/i);
      if (match && match[1]) {
        gitDir = path.resolve(projectPath, match[1].trim());
      }
    }

    const headFile = path.join(gitDir, 'HEAD');
    if (!(await fs.pathExists(headFile))) {
      return 'no-head';
    }
    const headContent = `${await fs.readFile(headFile, 'utf8')}`.trim();
    const refMatch = headContent.match(/^ref:\s+refs\/heads\/(.+)$/i);
    if (refMatch && refMatch[1]) {
      return normalizeRecoveryMemoryToken(refMatch[1]) || 'unknown-branch';
    }
    if (/^[a-f0-9]{7,40}$/i.test(headContent)) {
      return `detached-${headContent.slice(0, 8).toLowerCase()}`;
    }
    return 'unknown-branch';
  } catch (error) {
    return 'unknown-branch';
  }
}

function buildRecoveryMemorySignature(summaryPayload, context = {}) {
  const safeSummary = summaryPayload && typeof summaryPayload === 'object'
    ? summaryPayload
    : {};
  const diagnostics = safeSummary.program_diagnostics && typeof safeSummary.program_diagnostics === 'object'
    ? safeSummary.program_diagnostics
    : buildProgramDiagnostics(safeSummary);
  const clusters = Array.isArray(diagnostics.failure_clusters)
    ? diagnostics.failure_clusters
    : [];
  const clusterSignature = clusters
    .slice(0, 3)
    .map(cluster => normalizeRecoveryMemoryToken(cluster && cluster.signature))
    .filter(Boolean)
    .join('|');
  const scopeToken = normalizeRecoveryMemoryToken(context.scope || 'default-scope') || 'default-scope';
  const modeToken = normalizeRecoveryMemoryToken(safeSummary.mode || 'unknown-mode');
  const failedCount = Number(safeSummary.failed_goals) || 0;
  const seed = clusterSignature || 'no-failure-cluster';
  return `scope-${scopeToken}|${modeToken}|failed-${failedCount}|${seed}`;
}

function getRecoveryActionMemoryKey(action, index) {
  const actionToken = normalizeRecoveryMemoryToken(action && action.action);
  const commandToken = normalizeRecoveryMemoryToken(action && action.suggested_command);
  const fallback = `action-${index}`;
  return actionToken || commandToken
    ? `${fallback}|${actionToken || 'none'}|${commandToken || 'none'}`
    : fallback;
}

function selectRecoveryActionFromMemory(availableActions, recoveryMemoryEntry) {
  if (
    !recoveryMemoryEntry ||
    typeof recoveryMemoryEntry !== 'object' ||
    !recoveryMemoryEntry.actions ||
    typeof recoveryMemoryEntry.actions !== 'object'
  ) {
    return null;
  }

  const candidates = [];
  for (let index = 1; index <= availableActions.length; index += 1) {
    const action = availableActions[index - 1];
    const key = getRecoveryActionMemoryKey(action, index);
    const stats = recoveryMemoryEntry.actions[key];
    if (!stats || typeof stats !== 'object') {
      continue;
    }
    const attempts = Number(stats.attempts) || 0;
    const successes = Number(stats.successes) || 0;
    if (attempts <= 0) {
      continue;
    }
    const successRate = successes / attempts;
    const score = (successRate * 100) + Math.min(25, attempts);
    candidates.push({
      index,
      key,
      score,
      attempts,
      successes,
      failures: Number(stats.failures) || 0,
      success_rate_percent: Number((successRate * 100).toFixed(2))
    });
  }

  if (candidates.length === 0) {
    return null;
  }
  candidates.sort((left, right) => {
    if (right.score !== left.score) {
      return right.score - left.score;
    }
    if (right.attempts !== left.attempts) {
      return right.attempts - left.attempts;
    }
    return left.index - right.index;
  });
  const best = candidates[0];
  return {
    ...best,
    selection_reason: 'highest memory score: success_rate_percent + bounded_attempt_bonus',
    top_candidates: candidates.slice(0, 5)
  };
}

function getRecoveryMemoryEntry(recoveryMemoryPayload, signature) {
  if (
    !recoveryMemoryPayload ||
    typeof recoveryMemoryPayload !== 'object' ||
    !recoveryMemoryPayload.signatures ||
    typeof recoveryMemoryPayload.signatures !== 'object'
  ) {
    return null;
  }
  const signatureKey = `${signature || ''}`.trim();
  if (!signatureKey) {
    return null;
  }
  const entry = recoveryMemoryPayload.signatures[signatureKey];
  return entry && typeof entry === 'object' ? entry : null;
}

async function updateCloseLoopRecoveryMemory(
  projectPath,
  recoveryMemory,
  signature,
  selectedIndex,
  selectedAction,
  finalStatus,
  metadata = {}
) {
  const memoryFile = recoveryMemory && typeof recoveryMemory.file === 'string'
    ? recoveryMemory.file
    : getCloseLoopRecoveryMemoryFile(projectPath);
  const memoryPayload = recoveryMemory && recoveryMemory.payload && typeof recoveryMemory.payload === 'object'
    ? recoveryMemory.payload
    : {
      version: 1,
      signatures: {}
    };
  if (!memoryPayload.signatures || typeof memoryPayload.signatures !== 'object') {
    memoryPayload.signatures = {};
  }

  const signatureKey = `${signature || ''}`.trim() || 'unknown-signature';
  const selected = Number.isInteger(selectedIndex) && selectedIndex > 0 ? selectedIndex : 1;
  const actionKey = getRecoveryActionMemoryKey(selectedAction || {}, selected);
  const now = new Date().toISOString();
  const scope = normalizeRecoveryMemoryToken(metadata.scope || '') || null;

  if (!memoryPayload.signatures[signatureKey] || typeof memoryPayload.signatures[signatureKey] !== 'object') {
    memoryPayload.signatures[signatureKey] = {
      attempts: 0,
      successes: 0,
      failures: 0,
      scope,
      last_used_at: null,
      last_selected_index: null,
      actions: {}
    };
  }

  const signatureEntry = memoryPayload.signatures[signatureKey];
  if (!signatureEntry.actions || typeof signatureEntry.actions !== 'object') {
    signatureEntry.actions = {};
  }
  if (!signatureEntry.actions[actionKey] || typeof signatureEntry.actions[actionKey] !== 'object') {
    signatureEntry.actions[actionKey] = {
      attempts: 0,
      successes: 0,
      failures: 0,
      last_status: null,
      last_used_at: null,
      last_selected_index: selected
    };
  }

  const actionEntry = signatureEntry.actions[actionKey];
  const succeeded = `${finalStatus || ''}`.trim().toLowerCase() === 'completed';

  signatureEntry.attempts = (Number(signatureEntry.attempts) || 0) + 1;
  signatureEntry.successes = (Number(signatureEntry.successes) || 0) + (succeeded ? 1 : 0);
  signatureEntry.failures = (Number(signatureEntry.failures) || 0) + (succeeded ? 0 : 1);
  signatureEntry.scope = signatureEntry.scope || scope;
  signatureEntry.last_used_at = now;
  signatureEntry.last_selected_index = selected;

  actionEntry.attempts = (Number(actionEntry.attempts) || 0) + 1;
  actionEntry.successes = (Number(actionEntry.successes) || 0) + (succeeded ? 1 : 0);
  actionEntry.failures = (Number(actionEntry.failures) || 0) + (succeeded ? 0 : 1);
  actionEntry.last_status = `${finalStatus || 'unknown'}`;
  actionEntry.last_used_at = now;
  actionEntry.last_selected_index = selected;

  await fs.ensureDir(path.dirname(memoryFile));
  await fs.writeJson(memoryFile, memoryPayload, { spaces: 2 });

  return {
    file: memoryFile,
    signature: signatureKey,
    action_key: actionKey,
    scope: signatureEntry.scope || scope,
    entry: actionEntry
  };
}

function summarizeRecoveryMemory(memoryPayload) {
  const signatures = memoryPayload && memoryPayload.signatures && typeof memoryPayload.signatures === 'object'
    ? memoryPayload.signatures
    : {};
  const signatureKeys = Object.keys(signatures);
  let actionCount = 0;
  const scopeCounts = {};
  for (const key of signatureKeys) {
    const entry = signatures[key];
    if (entry && entry.actions && typeof entry.actions === 'object') {
      actionCount += Object.keys(entry.actions).length;
    }
    const scope = normalizeRecoveryMemoryToken(entry && entry.scope ? entry.scope : 'default-scope') || 'default-scope';
    scopeCounts[scope] = (Number(scopeCounts[scope]) || 0) + 1;
  }
  return {
    signature_count: signatureKeys.length,
    action_count: actionCount,
    scope_count: Object.keys(scopeCounts).length,
    scopes: scopeCounts
  };
}

function filterRecoveryMemoryByScope(memoryPayload, scopeCandidate) {
  const normalizedScope = normalizeRecoveryMemoryToken(scopeCandidate);
  if (!normalizedScope) {
    return {
      scope: null,
      payload: memoryPayload
    };
  }

  const source = memoryPayload && typeof memoryPayload === 'object'
    ? memoryPayload
    : { version: 1, signatures: {} };
  const signatures = source.signatures && typeof source.signatures === 'object'
    ? source.signatures
    : {};
  const filteredSignatures = {};
  for (const [signature, entryRaw] of Object.entries(signatures)) {
    const entry = entryRaw && typeof entryRaw === 'object' ? entryRaw : null;
    if (!entry) {
      continue;
    }
    const entryScope = normalizeRecoveryMemoryToken(entry.scope || 'default-scope') || 'default-scope';
    if (entryScope !== normalizedScope) {
      continue;
    }
    filteredSignatures[signature] = entry;
  }

  return {
    scope: normalizedScope,
    payload: {
      version: Number(source.version) || 1,
      signatures: filteredSignatures
    }
  };
}

function buildRecoveryMemoryScopeStats(memoryPayload) {
  const signatures = memoryPayload && memoryPayload.signatures && typeof memoryPayload.signatures === 'object'
    ? memoryPayload.signatures
    : {};
  const aggregates = new Map();
  for (const entryRaw of Object.values(signatures)) {
    const entry = entryRaw && typeof entryRaw === 'object' ? entryRaw : null;
    if (!entry) {
      continue;
    }
    const scope = normalizeRecoveryMemoryToken(entry.scope || 'default-scope') || 'default-scope';
    if (!aggregates.has(scope)) {
      aggregates.set(scope, {
        scope,
        signature_count: 0,
        action_count: 0,
        attempts: 0,
        successes: 0,
        failures: 0
      });
    }
    const aggregate = aggregates.get(scope);
    aggregate.signature_count += 1;
    aggregate.attempts += Number(entry.attempts) || 0;
    aggregate.successes += Number(entry.successes) || 0;
    aggregate.failures += Number(entry.failures) || 0;
    if (entry.actions && typeof entry.actions === 'object') {
      aggregate.action_count += Object.keys(entry.actions).length;
    }
  }

  return [...aggregates.values()]
    .map(item => ({
      ...item,
      success_rate_percent: item.attempts > 0
        ? Number(((item.successes / item.attempts) * 100).toFixed(2))
        : 0
    }))
    .sort((left, right) => {
      if (right.signature_count !== left.signature_count) {
        return right.signature_count - left.signature_count;
      }
      return `${left.scope}`.localeCompare(`${right.scope}`);
    });
}

function isIsoTimestampOlderThan(timestamp, cutoffMs) {
  if (cutoffMs === null) {
    return false;
  }
  if (typeof timestamp !== 'string' || !timestamp.trim()) {
    return true;
  }
  const parsed = Date.parse(timestamp);
  if (Number.isNaN(parsed)) {
    return true;
  }
  return parsed < cutoffMs;
}

async function showCloseLoopRecoveryMemory(projectPath, options = {}) {
  const recoveryMemory = await loadCloseLoopRecoveryMemory(projectPath);
  const filtered = filterRecoveryMemoryByScope(recoveryMemory.payload, options.scope);
  return {
    mode: 'auto-recovery-memory-show',
    file: recoveryMemory.file,
    scope: filtered.scope,
    stats: summarizeRecoveryMemory(filtered.payload),
    payload: filtered.payload
  };
}

async function showCloseLoopRecoveryMemoryScopes(projectPath) {
  const recoveryMemory = await loadCloseLoopRecoveryMemory(projectPath);
  const scopes = buildRecoveryMemoryScopeStats(recoveryMemory.payload);
  return {
    mode: 'auto-recovery-memory-scopes',
    file: recoveryMemory.file,
    total_scopes: scopes.length,
    scopes
  };
}

async function pruneCloseLoopRecoveryMemory(projectPath, options = {}) {
  const olderThanDays = normalizeRecoveryMemoryTtlDays(options.olderThanDays === undefined ? 30 : options.olderThanDays);
  const scope = normalizeRecoveryMemoryToken(options.scope || '') || null;
  const dryRun = Boolean(options.dryRun);
  const recoveryMemory = await loadCloseLoopRecoveryMemory(projectPath);
  const memoryPayload = recoveryMemory.payload && typeof recoveryMemory.payload === 'object'
    ? recoveryMemory.payload
    : { version: 1, signatures: {} };
  if (!memoryPayload.signatures || typeof memoryPayload.signatures !== 'object') {
    memoryPayload.signatures = {};
  }

  const cutoffMs = olderThanDays === null
    ? null
    : Date.now() - (olderThanDays * 24 * 60 * 60 * 1000);
  const filteredBeforePayload = scope
    ? filterRecoveryMemoryByScope(memoryPayload, scope).payload
    : memoryPayload;
  const signaturesBefore = summarizeRecoveryMemory(filteredBeforePayload).signature_count;
  const actionBefore = summarizeRecoveryMemory(filteredBeforePayload).action_count;

  const retainedSignatures = {};
  for (const [signature, entryRaw] of Object.entries(memoryPayload.signatures)) {
    const entry = entryRaw && typeof entryRaw === 'object' ? { ...entryRaw } : null;
    if (!entry) {
      continue;
    }
    const entryScope = normalizeRecoveryMemoryToken(entry.scope || 'default-scope') || 'default-scope';
    if (scope && entryScope !== scope) {
      retainedSignatures[signature] = entry;
      continue;
    }
    const actions = entry.actions && typeof entry.actions === 'object' ? entry.actions : {};
    const retainedActions = {};
    for (const [actionKey, actionStatsRaw] of Object.entries(actions)) {
      const actionStats = actionStatsRaw && typeof actionStatsRaw === 'object' ? actionStatsRaw : null;
      if (!actionStats) {
        continue;
      }
      if (!isIsoTimestampOlderThan(actionStats.last_used_at, cutoffMs)) {
        retainedActions[actionKey] = actionStats;
      }
    }

    if (Object.keys(retainedActions).length > 0 || !isIsoTimestampOlderThan(entry.last_used_at, cutoffMs)) {
      retainedSignatures[signature] = {
        ...entry,
        actions: retainedActions
      };
    }
  }

  const nextPayload = {
    version: Number(memoryPayload.version) || 1,
    signatures: retainedSignatures
  };
  const filteredAfterPayload = scope
    ? filterRecoveryMemoryByScope(nextPayload, scope).payload
    : nextPayload;
  const signaturesAfter = summarizeRecoveryMemory(filteredAfterPayload).signature_count;
  const actionAfter = summarizeRecoveryMemory(filteredAfterPayload).action_count;
  if (!dryRun) {
    await fs.ensureDir(path.dirname(recoveryMemory.file));
    await fs.writeJson(recoveryMemory.file, nextPayload, { spaces: 2 });
  }

  return {
    mode: 'auto-recovery-memory-prune',
    file: recoveryMemory.file,
    scope,
    dry_run: dryRun,
    older_than_days: olderThanDays,
    signatures_before: signaturesBefore,
    signatures_after: signaturesAfter,
    actions_before: actionBefore,
    actions_after: actionAfter,
    signatures_removed: Math.max(0, signaturesBefore - signaturesAfter),
    actions_removed: Math.max(0, actionBefore - actionAfter)
  };
}

async function clearCloseLoopRecoveryMemory(projectPath) {
  const recoveryMemoryFile = getCloseLoopRecoveryMemoryFile(projectPath);
  const existed = await fs.pathExists(recoveryMemoryFile);
  if (existed) {
    await fs.remove(recoveryMemoryFile);
  }
  return {
    mode: 'auto-recovery-memory-clear',
    file: recoveryMemoryFile,
    existed,
    cleared: true
  };
}

function resolveRecoveryActionSelection(summaryPayload, actionCandidate, context = {}) {
  const diagnostics = summaryPayload && summaryPayload.program_diagnostics && typeof summaryPayload.program_diagnostics === 'object'
    ? summaryPayload.program_diagnostics
    : buildProgramDiagnostics(summaryPayload || {});
  const availableActions = Array.isArray(diagnostics.remediation_actions) && diagnostics.remediation_actions.length > 0
    ? diagnostics.remediation_actions
    : buildProgramRemediationActions(summaryPayload || {}, []);
  const optionLabel = typeof context.optionLabel === 'string' && context.optionLabel.trim()
    ? context.optionLabel.trim()
    : '--use-action';
  let selectedIndex = null;
  let selectionSource = 'default';
  let memorySelection = null;
  let selectionExplain = null;
  if (actionCandidate !== undefined && actionCandidate !== null) {
    selectedIndex = normalizeRecoveryActionIndex(actionCandidate, availableActions.length, optionLabel);
    selectionSource = 'explicit';
    selectionExplain = {
      mode: 'explicit',
      reason: `${optionLabel} provided`,
      selected_index: selectedIndex
    };
  } else {
    memorySelection = selectRecoveryActionFromMemory(availableActions, context.recoveryMemoryEntry);
    if (memorySelection) {
      selectedIndex = memorySelection.index;
      selectionSource = 'memory';
      selectionExplain = {
        mode: 'memory',
        reason: memorySelection.selection_reason,
        selected_index: selectedIndex,
        candidate_count: memorySelection.top_candidates.length,
        top_candidates: memorySelection.top_candidates
      };
    } else {
      selectedIndex = normalizeRecoveryActionIndex(undefined, availableActions.length);
      selectionExplain = {
        mode: 'default',
        reason: 'no matching memory entry found for current signature',
        selected_index: selectedIndex
      };
    }
  }
  const selectedAction = availableActions[selectedIndex - 1] || null;
  const appliedPatch = selectedAction && selectedAction.strategy_patch && typeof selectedAction.strategy_patch === 'object'
    ? { ...selectedAction.strategy_patch }
    : {};

  return {
    selectedIndex,
    selectedAction,
    availableActions,
    appliedPatch,
    selectionSource,
    memorySelection,
    selectionExplain
  };
}

function applyRecoveryActionPatch(options, selectedAction) {
  const baseOptions = { ...options };
  const patch = selectedAction && selectedAction.strategy_patch && typeof selectedAction.strategy_patch === 'object'
    ? selectedAction.strategy_patch
    : {};
  const merged = { ...baseOptions };

  if (patch.batchAutonomous !== undefined) {
    merged.batchAutonomous = Boolean(patch.batchAutonomous);
  }
  if (patch.continueOnError !== undefined && merged.continueOnError === undefined) {
    merged.continueOnError = Boolean(patch.continueOnError);
  }
  if (patch.batchParallel !== undefined && (merged.batchParallel === undefined || merged.batchParallel === null)) {
    merged.batchParallel = Number(patch.batchParallel);
  }
  if (patch.batchAgentBudget !== undefined && (merged.batchAgentBudget === undefined || merged.batchAgentBudget === null)) {
    merged.batchAgentBudget = Number(patch.batchAgentBudget);
  }
  if (patch.batchPriority !== undefined && (!merged.batchPriority || `${merged.batchPriority}`.trim().toLowerCase() === 'fifo')) {
    merged.batchPriority = patch.batchPriority;
  }
  if (patch.batchAgingFactor !== undefined && (merged.batchAgingFactor === undefined || merged.batchAgingFactor === null)) {
    merged.batchAgingFactor = Number(patch.batchAgingFactor);
  }
  if (patch.batchRetryRounds !== undefined && (merged.batchRetryRounds === undefined || merged.batchRetryRounds === null)) {
    merged.batchRetryRounds = Number(patch.batchRetryRounds);
  }
  if (patch.batchRetryUntilComplete !== undefined && merged.batchRetryUntilComplete === undefined) {
    merged.batchRetryUntilComplete = Boolean(patch.batchRetryUntilComplete);
  }
  if (patch.batchRetryMaxRounds !== undefined && (merged.batchRetryMaxRounds === undefined || merged.batchRetryMaxRounds === null)) {
    merged.batchRetryMaxRounds = Number(patch.batchRetryMaxRounds);
  }
  if (patch.dodTests !== undefined && !merged.dodTests) {
    merged.dodTests = patch.dodTests;
  }
  if (patch.dodTasksClosed !== undefined && merged.dodTasksClosed === undefined) {
    merged.dodTasksClosed = Boolean(patch.dodTasksClosed);
  }

  return merged;
}

async function buildCloseLoopBatchGoalsFromSummaryPayload(
  summary,
  summaryFile,
  projectPath,
  formatCandidate,
  resumeStrategyCandidate
) {
  const resumeStrategy = normalizeResumeStrategy(resumeStrategyCandidate);
  if (!summary || typeof summary !== 'object') {
    throw new Error(`Invalid batch summary payload: ${summaryFile}`);
  }
  if (!Array.isArray(summary.results)) {
    throw new Error(`Batch summary missing "results" array: ${summaryFile}`);
  }

  const retryStatuses = resumeStrategy === 'failed-only'
    ? new Set(['failed', 'error'])
    : new Set(['failed', 'error', 'unknown', 'stopped', 'planned', 'prepared']);
  const pendingByIndex = new Map();
  for (const item of summary.results) {
    if (!item || typeof item !== 'object') {
      continue;
    }
    const status = typeof item.status === 'string' ? item.status.trim().toLowerCase() : '';
    const goal = typeof item.goal === 'string' ? item.goal.trim() : '';
    const index = Number(item.index);
    if (!goal || !retryStatuses.has(status)) {
      continue;
    }
    if (Number.isInteger(index) && index > 0) {
      pendingByIndex.set(index, goal);
    } else {
      pendingByIndex.set(pendingByIndex.size + 1, goal);
    }
  }

  let sourceGoals = null;
  let resolvedGoalsFile = null;
  if (typeof summary.goals_file === 'string' && summary.goals_file.trim()) {
    const goalsFileCandidate = summary.goals_file.trim();
    const isSyntheticGoalsFile = goalsFileCandidate.startsWith('(') && goalsFileCandidate.endsWith(')');
    if (!isSyntheticGoalsFile) {
      const resolvedGoalsCandidate = path.isAbsolute(goalsFileCandidate)
        ? goalsFileCandidate
        : path.join(projectPath, goalsFileCandidate);
      if (await fs.pathExists(resolvedGoalsCandidate)) {
        const loadedSource = await loadCloseLoopBatchGoals(projectPath, goalsFileCandidate, formatCandidate);
        sourceGoals = loadedSource.goals;
        resolvedGoalsFile = loadedSource.file;
      }
    }
  }

  const totalGoals = Number(summary.total_goals);
  const processedGoals = Number(summary.processed_goals);
  if (
    resumeStrategy === 'pending' &&
    sourceGoals &&
    Number.isInteger(totalGoals) &&
    Number.isInteger(processedGoals) &&
    processedGoals < totalGoals
  ) {
    const seenIndexes = new Set(
      summary.results
        .map(item => Number(item && item.index))
        .filter(index => Number.isInteger(index) && index > 0)
    );
    for (let index = 1; index <= sourceGoals.length; index += 1) {
      if (!seenIndexes.has(index)) {
        pendingByIndex.set(index, sourceGoals[index - 1]);
      }
    }
  }

  const orderedPendingEntries = [...pendingByIndex.entries()]
    .sort((a, b) => a[0] - b[0])
    .map(([sourceIndex, goal]) => ({
      goal,
      sourceIndex: Math.max(0, sourceIndex - 1)
    }));
  if (orderedPendingEntries.length === 0) {
    throw new Error(`No pending goals found in batch summary: ${summaryFile}`);
  }

  return {
    file: resolvedGoalsFile || summary.goals_file || '(derived-from-summary)',
    goals: orderedPendingEntries.map(item => item.goal),
    goal_entries: orderedPendingEntries,
    resumedFromSummary: {
      file: summaryFile,
      strategy: resumeStrategy,
      previous_status: summary.status || null,
      previous_total_goals: Number.isInteger(totalGoals) ? totalGoals : null,
      previous_processed_goals: Number.isInteger(processedGoals) ? processedGoals : null
    }
  };
}

async function loadCloseLoopBatchGoalsFromSummary(
  projectPath,
  summaryCandidate,
  formatCandidate,
  resumeStrategyCandidate
) {
  const summaryFile = await resolveCloseLoopBatchSummaryFile(projectPath, summaryCandidate);
  if (!(await fs.pathExists(summaryFile))) {
    throw new Error(`Batch summary file not found: ${summaryFile}`);
  }

  let summary = null;
  try {
    summary = await fs.readJson(summaryFile);
  } catch (error) {
    throw new Error(`Invalid batch summary JSON: ${summaryFile} (${error.message})`);
  }

  return buildCloseLoopBatchGoalsFromSummaryPayload(
    summary,
    summaryFile,
    projectPath,
    formatCandidate,
    resumeStrategyCandidate
  );
}

function buildBatchRunOptions(options) {
  return {
    subs: options.subs,
    maxParallel: options.maxParallel,
    prefix: options.prefix,
    dodTests: options.dodTests,
    dodTestsTimeout: options.dodTestsTimeout,
    dodDocs: options.dodDocs,
    dodCollab: options.dodCollab,
    dodTasksClosed: options.dodTasksClosed,
    dod: options.dod,
    dodReport: options.dodReport,
    session: options.session,
    sessionKeep: options.sessionKeep,
    sessionOlderThanDays: options.sessionOlderThanDays,
    replanStrategy: options.replanStrategy,
    replanAttempts: options.replanAttempts,
    replanNoProgressWindow: options.replanNoProgressWindow,
    replan: options.replan,
    run: options.run,
    stream: false,
    dryRun: options.dryRun,
    quiet: true
  };
}

function resolveBatchAutonomousPolicy(options, goalsCount = 0) {
  const enabled = !options || options.batchAutonomous !== false;
  const baseOptions = { ...options };
  if (!enabled) {
    return {
      options: baseOptions,
      summary: {
        enabled: false
      }
    };
  }

  const computedParallel = Math.max(
    1,
    Math.min(4, Math.min(Number.isInteger(goalsCount) ? goalsCount : 1, 20))
  );
  const effective = { ...baseOptions };

  effective.continueOnError = true;
  if (effective.batchParallel === undefined || effective.batchParallel === null) {
    effective.batchParallel = computedParallel;
  }
  if (
    effective.batchPriority === undefined ||
    effective.batchPriority === null ||
    `${effective.batchPriority}`.trim().toLowerCase() === 'fifo'
  ) {
    effective.batchPriority = 'complex-first';
  }
  if (effective.batchAgingFactor === undefined || effective.batchAgingFactor === null) {
    effective.batchAgingFactor = 2;
  }

  const hasExplicitRetryRounds = effective.batchRetryRounds !== undefined && effective.batchRetryRounds !== null;
  if (!hasExplicitRetryRounds && !effective.batchRetryUntilComplete) {
    effective.batchRetryUntilComplete = true;
  }

  return {
    options: effective,
    summary: {
      enabled: true,
      profile: 'closed-loop',
      auto_overrides: {
        continue_on_error: true,
        batch_parallel: effective.batchParallel,
        batch_priority: effective.batchPriority,
        batch_aging_factor: effective.batchAgingFactor,
        batch_retry_until_complete: Boolean(effective.batchRetryUntilComplete)
      }
    }
  };
}

function normalizeBatchParallel(batchParallelCandidate) {
  if (batchParallelCandidate === undefined || batchParallelCandidate === null) {
    return 1;
  }

  const parsed = Number(batchParallelCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 20) {
    throw new Error('--batch-parallel must be an integer between 1 and 20.');
  }
  return parsed;
}

function normalizeBatchAgentBudget(batchAgentBudgetCandidate) {
  if (batchAgentBudgetCandidate === undefined || batchAgentBudgetCandidate === null) {
    return null;
  }

  const parsed = Number(batchAgentBudgetCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 500) {
    throw new Error('--batch-agent-budget must be an integer between 1 and 500.');
  }
  return parsed;
}

function normalizeBatchPriorityStrategy(batchPriorityCandidate) {
  const normalized = typeof batchPriorityCandidate === 'string'
    ? batchPriorityCandidate.trim().toLowerCase()
    : 'fifo';
  if (!['fifo', 'complex-first', 'complex-last', 'critical-first'].includes(normalized)) {
    throw new Error('--batch-priority must be one of: fifo, complex-first, complex-last, critical-first.');
  }
  return normalized;
}

function normalizeBatchAgingFactor(batchAgingFactorCandidate) {
  if (batchAgingFactorCandidate === undefined || batchAgingFactorCandidate === null) {
    return 0;
  }

  const parsed = Number(batchAgingFactorCandidate);
  if (!Number.isInteger(parsed) || parsed < 0 || parsed > 100) {
    throw new Error('--batch-aging-factor must be an integer between 0 and 100.');
  }
  return parsed;
}

function normalizeBatchRetryRounds(batchRetryRoundsCandidate) {
  if (batchRetryRoundsCandidate === undefined || batchRetryRoundsCandidate === null) {
    return 0;
  }

  const parsed = Number(batchRetryRoundsCandidate);
  if (!Number.isInteger(parsed) || parsed < 0 || parsed > 5) {
    throw new Error('--batch-retry-rounds must be an integer between 0 and 5.');
  }
  return parsed;
}

function normalizeBatchRetryMaxRounds(batchRetryMaxRoundsCandidate) {
  if (batchRetryMaxRoundsCandidate === undefined || batchRetryMaxRoundsCandidate === null) {
    return 10;
  }

  const parsed = Number(batchRetryMaxRoundsCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 20) {
    throw new Error('--batch-retry-max-rounds must be an integer between 1 and 20.');
  }
  return parsed;
}

function normalizeRecoverMaxRounds(recoverMaxRoundsCandidate) {
  if (recoverMaxRoundsCandidate === undefined || recoverMaxRoundsCandidate === null) {
    return 5;
  }

  const parsed = Number(recoverMaxRoundsCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 20) {
    throw new Error('--recover-max-rounds must be an integer between 1 and 20.');
  }
  return parsed;
}

function normalizeRecoverMaxMinutes(recoverMaxMinutesCandidate, flagName = '--recover-max-minutes') {
  if (recoverMaxMinutesCandidate === undefined || recoverMaxMinutesCandidate === null) {
    return null;
  }

  const parsed = Number(recoverMaxMinutesCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 10080) {
    throw new Error(`${flagName} must be an integer between 1 and 10080.`);
  }
  return parsed;
}

function normalizeRecoveryMemoryTtlDays(daysCandidate) {
  if (daysCandidate === undefined || daysCandidate === null) {
    return null;
  }
  const parsed = Number(daysCandidate);
  if (!Number.isInteger(parsed) || parsed < 0 || parsed > 36500) {
    throw new Error('--recovery-memory-ttl-days must be an integer between 0 and 36500.');
  }
  return parsed;
}

function normalizeProgramMinSuccessRate(rateCandidate) {
  if (rateCandidate === undefined || rateCandidate === null) {
    return 100;
  }
  const parsed = Number(rateCandidate);
  if (Number.isNaN(parsed) || parsed < 0 || parsed > 100) {
    throw new Error('--program-min-success-rate must be a number between 0 and 100.');
  }
  return Number(parsed.toFixed(2));
}

function normalizeProgramGateProfile(profileCandidate) {
  const normalized = typeof profileCandidate === 'string'
    ? profileCandidate.trim().toLowerCase()
    : 'default';
  if (!PROGRAM_GATE_PROFILE_POLICY[normalized]) {
    throw new Error('--program-gate-profile must be one of: default, dev, staging, prod.');
  }
  return normalized;
}

function normalizeProgramGateFallbackProfile(profileCandidate) {
  const normalized = typeof profileCandidate === 'string'
    ? profileCandidate.trim().toLowerCase()
    : 'none';
  if (normalized === 'none') {
    return 'none';
  }
  if (!PROGRAM_GATE_PROFILE_POLICY[normalized]) {
    throw new Error('--program-gate-fallback-profile must be one of: none, default, dev, staging, prod.');
  }
  return normalized;
}

function normalizeProgramGateFallbackChain(chainCandidate) {
  if (chainCandidate === undefined || chainCandidate === null) {
    return null;
  }
  const raw = `${chainCandidate}`.trim();
  if (!raw) {
    return [];
  }
  const tokens = raw
    .split(',')
    .map(item => item.trim().toLowerCase())
    .filter(Boolean);
  if (tokens.length === 0) {
    return [];
  }
  if (tokens.includes('none')) {
    if (tokens.length > 1) {
      throw new Error('--program-gate-fallback-chain cannot mix "none" with other profiles.');
    }
    return [];
  }
  const normalized = [];
  const seen = new Set();
  for (const token of tokens) {
    if (!PROGRAM_GATE_PROFILE_POLICY[token]) {
      throw new Error('--program-gate-fallback-chain must contain only: none, default, dev, staging, prod.');
    }
    if (seen.has(token)) {
      continue;
    }
    seen.add(token);
    normalized.push(token);
  }
  return normalized;
}

function resolveProgramGateFallbackChain(chainCandidate, fallbackProfileCandidate) {
  const parsedChain = normalizeProgramGateFallbackChain(chainCandidate);
  if (Array.isArray(parsedChain)) {
    return parsedChain;
  }
  const normalizedSingle = normalizeProgramGateFallbackProfile(fallbackProfileCandidate);
  return normalizedSingle === 'none' ? [] : [normalizedSingle];
}

function normalizeProgramRiskLevel(levelCandidate) {
  const normalized = typeof levelCandidate === 'string'
    ? levelCandidate.trim().toLowerCase()
    : 'high';
  if (!['low', 'medium', 'high'].includes(normalized)) {
    throw new Error('--program-max-risk-level must be one of: low, medium, high.');
  }
  return normalized;
}

function normalizeProgramMaxElapsedMinutes(minutesCandidate) {
  if (minutesCandidate === undefined || minutesCandidate === null) {
    return null;
  }
  const parsed = Number(minutesCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 10080) {
    throw new Error('--program-max-elapsed-minutes must be an integer between 1 and 10080.');
  }
  return parsed;
}

function normalizeProgramMaxAgentBudget(budgetCandidate) {
  if (budgetCandidate === undefined || budgetCandidate === null) {
    return null;
  }
  const parsed = Number(budgetCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 500) {
    throw new Error('--program-max-agent-budget must be an integer between 1 and 500.');
  }
  return parsed;
}

function normalizeProgramMaxTotalSubSpecs(countCandidate) {
  if (countCandidate === undefined || countCandidate === null) {
    return null;
  }
  const parsed = Number(countCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 500000) {
    throw new Error('--program-max-total-sub-specs must be an integer between 1 and 500000.');
  }
  return parsed;
}

function normalizeProgramGovernMaxRounds(roundsCandidate) {
  if (roundsCandidate === undefined || roundsCandidate === null) {
    return 3;
  }
  const parsed = Number(roundsCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 20) {
    throw new Error('--program-govern-max-rounds must be an integer between 1 and 20.');
  }
  return parsed;
}

function normalizeProgramGovernMaxMinutes(minutesCandidate) {
  if (minutesCandidate === undefined || minutesCandidate === null) {
    return 60;
  }
  const parsed = Number(minutesCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 10080) {
    throw new Error('--program-govern-max-minutes must be an integer between 1 and 10080.');
  }
  return parsed;
}

function normalizeProgramGovernAnomalyWeeks(weeksCandidate) {
  if (weeksCandidate === undefined || weeksCandidate === null) {
    return 8;
  }
  const parsed = Number(weeksCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 260) {
    throw new Error('--program-govern-anomaly-weeks must be an integer between 1 and 260.');
  }
  return parsed;
}

function normalizeProgramGovernUseAction(actionCandidate) {
  if (actionCandidate === undefined || actionCandidate === null) {
    return null;
  }
  const parsed = Number(actionCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 20) {
    throw new Error('--program-govern-use-action must be an integer between 1 and 20.');
  }
  return parsed;
}

function normalizeControllerDequeueLimit(limitCandidate) {
  if (limitCandidate === undefined || limitCandidate === null) {
    return null;
  }
  const parsed = Number(limitCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 100) {
    throw new Error('--dequeue-limit must be an integer between 1 and 100.');
  }
  return parsed;
}

function normalizeControllerPollSeconds(secondsCandidate) {
  if (secondsCandidate === undefined || secondsCandidate === null) {
    return 30;
  }
  const parsed = Number(secondsCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 3600) {
    throw new Error('--poll-seconds must be an integer between 1 and 3600.');
  }
  return parsed;
}

function normalizeControllerMaxCycles(cyclesCandidate) {
  if (cyclesCandidate === undefined || cyclesCandidate === null) {
    return 1000;
  }
  const parsed = Number(cyclesCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 100000) {
    throw new Error('--max-cycles must be an integer between 1 and 100000.');
  }
  return parsed;
}

function normalizeControllerMaxMinutes(minutesCandidate) {
  if (minutesCandidate === undefined || minutesCandidate === null) {
    return 120;
  }
  const parsed = Number(minutesCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 10080) {
    throw new Error('--max-minutes must be an integer between 1 and 10080.');
  }
  return parsed;
}

function normalizeControllerLockTtlSeconds(secondsCandidate) {
  if (secondsCandidate === undefined || secondsCandidate === null) {
    return 1800;
  }
  const parsed = Number(secondsCandidate);
  if (!Number.isInteger(parsed) || parsed < 10 || parsed > 86400) {
    throw new Error('--controller-lock-ttl-seconds must be an integer between 10 and 86400.');
  }
  return parsed;
}

function normalizeControllerSessionKeep(keepCandidate) {
  if (keepCandidate === undefined || keepCandidate === null) {
    return null;
  }
  const parsed = Number(keepCandidate);
  if (!Number.isInteger(parsed) || parsed < 0 || parsed > 1000) {
    throw new Error('--controller-session-keep must be an integer between 0 and 1000.');
  }
  return parsed;
}

function normalizeControllerSessionOlderThanDays(daysCandidate) {
  if (daysCandidate === undefined || daysCandidate === null) {
    return null;
  }
  const parsed = Number(daysCandidate);
  if (!Number.isInteger(parsed) || parsed < 0 || parsed > 36500) {
    throw new Error('--controller-session-older-than-days must be an integer between 0 and 36500.');
  }
  return parsed;
}

function resolveProgramGatePolicy(policy = {}) {
  const profile = normalizeProgramGateProfile(policy.profile);
  const profilePolicy = PROGRAM_GATE_PROFILE_POLICY[profile];
  const minSuccessRate = policy.minSuccessRate === undefined || policy.minSuccessRate === null
    ? normalizeProgramMinSuccessRate(profilePolicy.minSuccessRate)
    : normalizeProgramMinSuccessRate(policy.minSuccessRate);
  const maxRiskLevel = policy.maxRiskLevel === undefined || policy.maxRiskLevel === null
    ? normalizeProgramRiskLevel(profilePolicy.maxRiskLevel)
    : normalizeProgramRiskLevel(policy.maxRiskLevel);
  const maxElapsedMinutes = policy.maxElapsedMinutes === undefined || policy.maxElapsedMinutes === null
    ? normalizeProgramMaxElapsedMinutes(profilePolicy.maxElapsedMinutes)
    : normalizeProgramMaxElapsedMinutes(policy.maxElapsedMinutes);
  const maxAgentBudget = policy.maxAgentBudget === undefined || policy.maxAgentBudget === null
    ? normalizeProgramMaxAgentBudget(profilePolicy.maxAgentBudget)
    : normalizeProgramMaxAgentBudget(policy.maxAgentBudget);
  const maxTotalSubSpecs = policy.maxTotalSubSpecs === undefined || policy.maxTotalSubSpecs === null
    ? normalizeProgramMaxTotalSubSpecs(profilePolicy.maxTotalSubSpecs)
    : normalizeProgramMaxTotalSubSpecs(policy.maxTotalSubSpecs);
  return {
    profile,
    minSuccessRate,
    maxRiskLevel,
    maxElapsedMinutes,
    maxAgentBudget,
    maxTotalSubSpecs
  };
}

function normalizeBatchRetryStrategy(batchRetryStrategyCandidate) {
  const normalized = typeof batchRetryStrategyCandidate === 'string'
    ? batchRetryStrategyCandidate.trim().toLowerCase()
    : 'adaptive';
  if (!['adaptive', 'strict'].includes(normalized)) {
    throw new Error('--batch-retry-strategy must be one of: adaptive, strict.');
  }
  return normalized;
}

function resolveRequestedGoalMaxParallel(runOptions) {
  const parsed = Number(runOptions && runOptions.maxParallel);
  return Number.isInteger(parsed) && parsed > 0 ? parsed : null;
}

function estimateGoalComplexityWeight(goal, runOptions = {}) {
  const explicitSubs = Number(runOptions.subs);
  if (Number.isInteger(explicitSubs) && explicitSubs > 0) {
    if (explicitSubs >= 5) {
      return 3;
    }
    if (explicitSubs >= 3) {
      return 2;
    }
    return 1;
  }

  const text = `${goal || ''}`.trim().toLowerCase();
  if (!text) {
    return 1;
  }

  const words = text.split(/\s+/).filter(Boolean).length;
  const clauseSignals = (text.match(/,|;| and | plus | with |并且|以及|并行|同时/g) || []).length;
  const domainSignals = (text.match(
    /orchestrat|integration|migration|observability|quality|security|performance|resilience|compliance|governance|闭环|主从|并行|重规划/g
  ) || []).length;

  let score = 0;
  if (words >= 25) {
    score += 2;
  } else if (words >= 12) {
    score += 1;
  }

  if (clauseSignals >= 4) {
    score += 2;
  } else if (clauseSignals >= 2) {
    score += 1;
  }

  if (domainSignals >= 4) {
    score += 1;
  }

  if (score >= 4) {
    return 3;
  }
  if (score >= 2) {
    return 2;
  }
  return 1;
}

function estimateGoalCriticalityWeight(goal) {
  const text = `${goal || ''}`.trim().toLowerCase();
  if (!text) {
    return 1;
  }

  const strongSignals = (text.match(
    /foundation|core|platform|infra|schema|migration|dependency|contract|baseline|bootstrap|关键路径|核心|基础|依赖|主干/g
  ) || []).length;
  const mediumSignals = (text.match(
    /orchestrat|integration|security|compliance|quality|governance|observability|性能|稳定|编排/g
  ) || []).length;
  if (strongSignals >= 2 || (strongSignals >= 1 && mediumSignals >= 1)) {
    return 3;
  }
  if (strongSignals >= 1 || mediumSignals >= 2) {
    return 2;
  }
  return 1;
}

function resolveGoalBasePriority(priorityStrategy, complexityWeight, criticalityWeight, index) {
  const inverseIndex = 100000 - index;
  if (priorityStrategy === 'critical-first') {
    return (criticalityWeight * 100000) + (complexityWeight * 1000) + inverseIndex;
  }
  if (priorityStrategy === 'complex-first') {
    return (complexityWeight * 10000) + inverseIndex;
  }
  if (priorityStrategy === 'complex-last') {
    return ((10 - complexityWeight) * 10000) + inverseIndex;
  }
  return inverseIndex;
}

function buildGoalExecutionPlans(goals, runOptions, agentBudget, priorityStrategy, goalEntriesCandidate = null) {
  const goalEntries = Array.isArray(goalEntriesCandidate) && goalEntriesCandidate.length === goals.length
    ? goalEntriesCandidate
    : goals.map((goal, index) => ({
      goal,
      sourceIndex: index,
      attempt: 1
    }));

  return goals.map((goal, index) => {
    const entry = goalEntries[index] || {};
    const sourceIndex = Number.isInteger(entry.sourceIndex) && entry.sourceIndex >= 0
      ? entry.sourceIndex
      : index;
    const attempt = Number.isInteger(entry.attempt) && entry.attempt > 0
      ? entry.attempt
      : 1;
    const complexityWeight = estimateGoalComplexityWeight(goal, runOptions);
    const criticalityWeight = estimateGoalCriticalityWeight(goal);
    const schedulingWeight = agentBudget === null
      ? 1
      : Math.max(1, Math.min(agentBudget, complexityWeight));
    const basePriority = resolveGoalBasePriority(priorityStrategy, complexityWeight, criticalityWeight, index);

    return {
      index,
      goal,
      source_index: sourceIndex,
      attempt,
      complexity_weight: complexityWeight,
      criticality_weight: criticalityWeight,
      scheduling_weight: schedulingWeight,
      base_priority: basePriority,
      wait_ticks: 0
    };
  });
}

function resolveEffectiveGoalParallel(baseParallel, slotBudget, goalPlans) {
  if (goalPlans.length === 0) {
    return 0;
  }

  if (!Number.isFinite(slotBudget)) {
    return Math.min(baseParallel, goalPlans.length);
  }

  const sortedWeights = goalPlans
    .map(plan => plan.scheduling_weight)
    .sort((a, b) => a - b);

  let used = 0;
  let count = 0;
  for (const weight of sortedWeights) {
    if (count >= baseParallel) {
      break;
    }
    if (used + weight > slotBudget) {
      break;
    }
    used += weight;
    count += 1;
  }

  return Math.max(1, Math.min(baseParallel, goalPlans.length, count));
}

function resolvePerGoalMaxParallel(requestedGoalMaxParallel, agentBudget, effectiveParallel) {
  if (agentBudget === null) {
    return requestedGoalMaxParallel;
  }

  const budgetBased = Math.max(1, Math.floor(agentBudget / Math.max(1, effectiveParallel)));
  if (requestedGoalMaxParallel === null) {
    return budgetBased;
  }

  return Math.max(1, Math.min(requestedGoalMaxParallel, budgetBased));
}

function parseSpecPrefixFromId(specId) {
  const match = `${specId || ''}`.match(/^(\d+)-\d{2}-/);
  if (!match) {
    return null;
  }
  const parsed = Number(match[1]);
  return Number.isInteger(parsed) && parsed > 0 ? parsed : null;
}

async function resolveNextBatchGoalPrefix(projectPath) {
  const specs = await readSpecSessionEntries(projectPath);
  let maxPrefix = 0;
  for (const spec of specs) {
    const parsed = parseSpecPrefixFromId(spec && spec.id);
    if (parsed !== null && parsed > maxPrefix) {
      maxPrefix = parsed;
    }
  }
  return maxPrefix + 1;
}

async function allocateBatchGoalPrefixes(projectPath, goalCount, prefixCandidate) {
  if (!Number.isInteger(goalCount) || goalCount <= 0) {
    return [];
  }

  let startPrefix;
  if (prefixCandidate !== undefined && prefixCandidate !== null) {
    const parsed = Number(prefixCandidate);
    if (!Number.isInteger(parsed) || parsed < 1) {
      throw new Error('--prefix must be a positive integer');
    }
    startPrefix = parsed;
  } else {
    startPrefix = await resolveNextBatchGoalPrefix(projectPath);
  }

  return Array.from({ length: goalCount }, (_item, index) => startPrefix + index);
}

function buildBatchResourcePlan(context) {
  const weights = context.goalPlans.map(plan => plan.scheduling_weight);
  const complexityWeights = context.goalPlans.map(plan => plan.complexity_weight);
  const criticalityWeights = context.goalPlans.map(plan => plan.criticality_weight || 1);
  const avgWeight = weights.length === 0
    ? 0
    : Number((weights.reduce((sum, item) => sum + item, 0) / weights.length).toFixed(2));
  const avgComplexityWeight = complexityWeights.length === 0
    ? 0
    : Number((complexityWeights.reduce((sum, item) => sum + item, 0) / complexityWeights.length).toFixed(2));
  const avgCriticalityWeight = criticalityWeights.length === 0
    ? 0
    : Number((criticalityWeights.reduce((sum, item) => sum + item, 0) / criticalityWeights.length).toFixed(2));

  return {
    agent_budget: context.agentBudget,
    weighted_scheduling_enabled: context.agentBudget !== null,
    scheduling_strategy: context.priorityStrategy,
    aging_factor: context.agingFactor,
    slot_budget: Number.isFinite(context.slotBudget) ? context.slotBudget : null,
    requested_goal_max_parallel: context.requestedGoalMaxParallel,
    per_goal_max_parallel: context.perGoalMaxParallel,
    base_goal_parallel: context.baseParallel,
    effective_goal_parallel: context.effectiveParallel,
    goal_weight_summary: {
      min: weights.length === 0 ? 0 : Math.min(...weights),
      max: weights.length === 0 ? 0 : Math.max(...weights),
      average: avgWeight
    },
    goal_complexity_summary: {
      min: complexityWeights.length === 0 ? 0 : Math.min(...complexityWeights),
      max: complexityWeights.length === 0 ? 0 : Math.max(...complexityWeights),
      average: avgComplexityWeight
    },
    goal_criticality_summary: {
      min: criticalityWeights.length === 0 ? 0 : Math.min(...criticalityWeights),
      max: criticalityWeights.length === 0 ? 0 : Math.max(...criticalityWeights),
      average: avgCriticalityWeight
    },
    max_wait_ticks: 0,
    starvation_wait_events: 0,
    max_used_slots: 0,
    max_concurrent_goals: 0
  };
}

function toBatchResultItem(index, goal, runResult, errorMessage = null, goalPlan = null) {
  const status = runResult && typeof runResult.status === 'string'
    ? runResult.status
    : errorMessage
      ? 'error'
      : 'unknown';
  const subSpecs = runResult && runResult.portfolio && Array.isArray(runResult.portfolio.sub_specs)
    ? runResult.portfolio.sub_specs
    : [];
  const sourceIndex = goalPlan && Number.isInteger(goalPlan.source_index)
    ? goalPlan.source_index
    : index;
  const attempt = goalPlan && Number.isInteger(goalPlan.attempt) && goalPlan.attempt > 0
    ? goalPlan.attempt
    : 1;
  const rateLimitTelemetry = extractBatchRateLimitTelemetry(runResult);

  return {
    index: sourceIndex + 1,
    source_index: sourceIndex,
    goal,
    status,
    master_spec: runResult && runResult.portfolio ? runResult.portfolio.master_spec : null,
    sub_spec_count: subSpecs.length,
    goal_weight: goalPlan && Number.isInteger(goalPlan.complexity_weight) ? goalPlan.complexity_weight : 1,
    criticality_weight: goalPlan && Number.isInteger(goalPlan.criticality_weight) ? goalPlan.criticality_weight : 1,
    scheduling_weight: goalPlan && Number.isInteger(goalPlan.scheduling_weight) ? goalPlan.scheduling_weight : 1,
    base_priority: goalPlan && Number.isFinite(goalPlan.base_priority) ? goalPlan.base_priority : null,
    wait_ticks: goalPlan && Number.isInteger(goalPlan.wait_ticks) ? goalPlan.wait_ticks : 0,
    batch_attempt: attempt,
    replan_cycles: runResult && runResult.replan ? Number(runResult.replan.performed || 0) : 0,
    rate_limit_signals: rateLimitTelemetry.signalCount,
    rate_limit_backoff_ms: rateLimitTelemetry.totalBackoffMs,
    rate_limit_launch_hold_ms: rateLimitTelemetry.lastLaunchHoldMs,
    error: errorMessage
  };
}

function extractBatchRateLimitTelemetry(runResult) {
  const orchestration = runResult && runResult.orchestration && typeof runResult.orchestration === 'object'
    ? runResult.orchestration
    : null;
  const rateLimit = orchestration && orchestration.rateLimit && typeof orchestration.rateLimit === 'object'
    ? orchestration.rateLimit
    : (
      orchestration &&
      orchestration.telemetry &&
      orchestration.telemetry.rateLimit &&
      typeof orchestration.telemetry.rateLimit === 'object'
        ? orchestration.telemetry.rateLimit
        : null
    );
  const signalCount = Number(rateLimit && rateLimit.signalCount);
  const totalBackoffMs = Number(rateLimit && rateLimit.totalBackoffMs);
  const lastLaunchHoldMs = Number(rateLimit && rateLimit.lastLaunchHoldMs);

  return {
    signalCount: Number.isFinite(signalCount) && signalCount > 0 ? Math.round(signalCount) : 0,
    totalBackoffMs: Number.isFinite(totalBackoffMs) && totalBackoffMs > 0 ? Math.round(totalBackoffMs) : 0,
    lastLaunchHoldMs: Number.isFinite(lastLaunchHoldMs) && lastLaunchHoldMs > 0 ? Math.round(lastLaunchHoldMs) : 0
  };
}

function toBatchUnprocessedResultItem(entry, attempt, reason) {
  const sourceIndex = Number.isInteger(entry && entry.sourceIndex) ? entry.sourceIndex : 0;
  const goal = entry && typeof entry.goal === 'string' ? entry.goal : '';
  return {
    index: sourceIndex + 1,
    source_index: sourceIndex,
    goal,
    status: 'stopped',
    master_spec: null,
    sub_spec_count: 0,
    goal_weight: 1,
    criticality_weight: 1,
    scheduling_weight: 1,
    base_priority: null,
    wait_ticks: 0,
    batch_attempt: attempt,
    replan_cycles: 0,
    rate_limit_signals: 0,
    rate_limit_backoff_ms: 0,
    rate_limit_launch_hold_ms: 0,
    error: reason
  };
}

function mergeBatchResourcePlans(base, incoming) {
  if (!base) {
    return incoming ? { ...incoming } : null;
  }
  if (!incoming) {
    return { ...base };
  }

  return {
    ...base,
    max_wait_ticks: Math.max(Number(base.max_wait_ticks) || 0, Number(incoming.max_wait_ticks) || 0),
    starvation_wait_events: (Number(base.starvation_wait_events) || 0) + (Number(incoming.starvation_wait_events) || 0),
    max_used_slots: Math.max(Number(base.max_used_slots) || 0, Number(incoming.max_used_slots) || 0),
    max_concurrent_goals: Math.max(Number(base.max_concurrent_goals) || 0, Number(incoming.max_concurrent_goals) || 0)
  };
}

function buildBatchMetrics(results, totalGoals) {
  const statusBreakdown = {};
  let totalSubSpecs = 0;
  let totalReplanCycles = 0;
  let totalGoalWeight = 0;
  let totalRateLimitSignals = 0;
  let totalRateLimitBackoffMs = 0;
  let maxRateLimitLaunchHoldMs = 0;
  for (const item of results) {
    const status = item && typeof item.status === 'string' ? item.status : 'unknown';
    statusBreakdown[status] = (statusBreakdown[status] || 0) + 1;
    totalSubSpecs += Number(item && item.sub_spec_count) || 0;
    totalReplanCycles += Number(item && item.replan_cycles) || 0;
    totalGoalWeight += Number(item && item.goal_weight) || 0;
    totalRateLimitSignals += Number(item && item.rate_limit_signals) || 0;
    totalRateLimitBackoffMs += Number(item && item.rate_limit_backoff_ms) || 0;
    maxRateLimitLaunchHoldMs = Math.max(maxRateLimitLaunchHoldMs, Number(item && item.rate_limit_launch_hold_ms) || 0);
  }

  const processedGoals = results.length;
  const completedGoals = statusBreakdown.completed || 0;
  const denominator = Number.isInteger(totalGoals) && totalGoals > 0 ? totalGoals : processedGoals || 1;
  const successRatePercent = Number(((completedGoals / denominator) * 100).toFixed(2));
  return {
    status_breakdown: statusBreakdown,
    success_rate_percent: successRatePercent,
    total_sub_specs: totalSubSpecs,
    average_sub_specs_per_goal: Number((totalSubSpecs / (processedGoals || 1)).toFixed(2)),
    total_goal_weight: totalGoalWeight,
    average_goal_weight: Number((totalGoalWeight / (processedGoals || 1)).toFixed(2)),
    total_replan_cycles: totalReplanCycles,
    average_replan_cycles_per_goal: Number((totalReplanCycles / (processedGoals || 1)).toFixed(2)),
    total_rate_limit_signals: totalRateLimitSignals,
    average_rate_limit_signals_per_goal: Number((totalRateLimitSignals / (processedGoals || 1)).toFixed(2)),
    total_rate_limit_backoff_ms: totalRateLimitBackoffMs,
    average_rate_limit_backoff_ms_per_goal: Number((totalRateLimitBackoffMs / (processedGoals || 1)).toFixed(2)),
    max_rate_limit_launch_hold_ms: maxRateLimitLaunchHoldMs
  };
}

async function runCloseLoopBatchGoals(goals, options) {
  const continueOnError = Boolean(options.continueOnError);
  const batchParallel = normalizeBatchParallel(options.batchParallel);
  const baseParallel = continueOnError ? batchParallel : 1;
  const agentBudget = normalizeBatchAgentBudget(options.batchAgentBudget);
  const priorityStrategy = normalizeBatchPriorityStrategy(options.batchPriority);
  const agingFactor = normalizeBatchAgingFactor(options.batchAgingFactor);
  const runOptions = options.runOptions || {};
  const batchAttempt = Number.isInteger(options.batchAttempt) && options.batchAttempt > 0
    ? options.batchAttempt
    : 1;
  const projectPath = typeof options.projectPath === 'string' && options.projectPath.trim()
    ? options.projectPath
    : process.cwd();
  const requestedGoalMaxParallel = resolveRequestedGoalMaxParallel(runOptions);
  const slotBudget = agentBudget === null ? Number.POSITIVE_INFINITY : agentBudget;
  const goalPlans = buildGoalExecutionPlans(
    goals,
    runOptions,
    agentBudget,
    priorityStrategy,
    options.goalEntries
  );
  const effectiveParallel = resolveEffectiveGoalParallel(baseParallel, slotBudget, goalPlans);
  const perGoalMaxParallel = resolvePerGoalMaxParallel(requestedGoalMaxParallel, agentBudget, effectiveParallel);
  const effectiveRunOptions = { ...runOptions };
  if (perGoalMaxParallel !== null) {
    effectiveRunOptions.maxParallel = perGoalMaxParallel;
  }
  const allocatedPrefixes = await allocateBatchGoalPrefixes(
    projectPath,
    goalPlans.length,
    effectiveRunOptions.prefix
  );
  const goalPlansByIndex = goalPlans.map(plan => ({
    ...plan,
    attempt: batchAttempt,
    run_options: {
      ...effectiveRunOptions,
      prefix: allocatedPrefixes[plan.index]
    }
  }));
  const resourcePlan = buildBatchResourcePlan({
    goalPlans: goalPlansByIndex,
    agentBudget,
    slotBudget,
    requestedGoalMaxParallel,
    perGoalMaxParallel,
    baseParallel,
    effectiveParallel,
    priorityStrategy,
    agingFactor
  });
  const results = new Array(goals.length);
  const pendingIndexes = new Set(goalPlansByIndex.map(plan => plan.index));
  const activeRuns = new Map();
  let usedSlots = 0;
  let stopLaunch = false;

  const scoreGoalPlan = plan => {
    return plan.base_priority + (plan.wait_ticks * agingFactor);
  };

  const pickHighestPriorityPendingPlan = () => {
    const candidates = goalPlansByIndex
      .filter(plan => pendingIndexes.has(plan.index));
    if (candidates.length === 0) {
      return null;
    }

    candidates.sort((left, right) => {
      const scoreDelta = scoreGoalPlan(right) - scoreGoalPlan(left);
      if (scoreDelta !== 0) {
        return scoreDelta;
      }
      const indexDelta = left.index - right.index;
      if (indexDelta !== 0) {
        return indexDelta;
      }
      return right.scheduling_weight - left.scheduling_weight;
    });

    return candidates[0];
  };

  const pickNextGoalPlan = () => {
    if (stopLaunch) {
      return {
        plan: null,
        blockedByBudget: false
      };
    }

    const topPlan = pickHighestPriorityPendingPlan();
    if (!topPlan) {
      return {
        plan: null,
        blockedByBudget: false
      };
    }

    if (usedSlots + topPlan.scheduling_weight <= slotBudget) {
      return {
        plan: topPlan,
        blockedByBudget: false
      };
    }

    return {
      plan: null,
      blockedByBudget: true
    };
  };

  const agePendingGoalPlans = () => {
    for (const plan of goalPlansByIndex) {
      if (pendingIndexes.has(plan.index)) {
        plan.wait_ticks += 1;
      }
    }
    const pendingWaits = goalPlansByIndex
      .filter(plan => pendingIndexes.has(plan.index))
      .map(plan => plan.wait_ticks);
    if (pendingWaits.length > 0) {
      resourcePlan.max_wait_ticks = Math.max(resourcePlan.max_wait_ticks, ...pendingWaits);
    }
  };

  const launchGoal = plan => {
    pendingIndexes.delete(plan.index);
    usedSlots += plan.scheduling_weight;
    resourcePlan.max_used_slots = Math.max(resourcePlan.max_used_slots, usedSlots);
    resourcePlan.max_concurrent_goals = Math.max(resourcePlan.max_concurrent_goals, activeRuns.size + 1);

    const runPromise = (async () => {
      try {
        const runResult = await runAutoCloseLoop(plan.goal, { ...plan.run_options });
        results[plan.index] = toBatchResultItem(plan.index, plan.goal, runResult, null, plan);
        if (runResult.status === 'failed' && !continueOnError) {
          stopLaunch = true;
        }
      } catch (error) {
        results[plan.index] = toBatchResultItem(plan.index, plan.goal, null, error.message, plan);
        if (!continueOnError) {
          stopLaunch = true;
        }
      } finally {
        usedSlots = Math.max(0, usedSlots - plan.scheduling_weight);
        activeRuns.delete(plan.index);
      }
    })();

    activeRuns.set(plan.index, runPromise);
  };

  while (true) {
    while (activeRuns.size < effectiveParallel) {
      const next = pickNextGoalPlan();
      if (!next.plan) {
        if (next.blockedByBudget && activeRuns.size > 0) {
          resourcePlan.starvation_wait_events += 1;
        }
        break;
      }
      launchGoal(next.plan);
    }

    if (activeRuns.size === 0) {
      break;
    }

    await Promise.race([...activeRuns.values()]);
    agePendingGoalPlans();
  }

  const compactResults = results
    .filter(Boolean)
    .sort((left, right) => {
      const leftIndex = Number.isInteger(left && left.source_index) ? left.source_index : Number(left && left.index) - 1;
      const rightIndex = Number.isInteger(right && right.source_index) ? right.source_index : Number(right && right.index) - 1;
      return leftIndex - rightIndex;
    });
  return {
    effectiveParallel,
    resourcePlan,
    results: compactResults,
    raw_results: results,
    stoppedEarly: !continueOnError && compactResults.length < goals.length
  };
}

async function runCloseLoopBatchWithRetries(goals, options) {
  const retryUntilComplete = Boolean(options.batchRetryUntilComplete);
  const configuredRetryRounds = normalizeBatchRetryRounds(options.batchRetryRounds);
  const retryMaxRounds = retryUntilComplete
    ? normalizeBatchRetryMaxRounds(options.batchRetryMaxRounds)
    : configuredRetryRounds;
  const retryStrategy = normalizeBatchRetryStrategy(options.batchRetryStrategy);
  const initialContinueOnError = Boolean(options.continueOnError);
  const failedStatuses = new Set(['failed', 'error', 'unknown', 'stopped']);
  const finalResultsBySource = new Map();
  const retryHistory = [];
  let aggregateResourcePlan = null;
  let effectiveParallel = 0;
  let stoppedEarly = false;
  const configuredBatchParallel = normalizeBatchParallel(options.batchParallel);
  const configuredBatchAgentBudget = normalizeBatchAgentBudget(options.batchAgentBudget);
  let adaptiveBatchParallel = configuredBatchParallel;
  let adaptiveBatchAgentBudget = configuredBatchAgentBudget;

  let round = 0;
  let pendingEntries = Array.isArray(options.goalEntries) && options.goalEntries.length > 0
    ? options.goalEntries
      .map((entry, index) => ({
        goal: entry && typeof entry.goal === 'string' ? entry.goal : goals[index],
        sourceIndex: Number.isInteger(entry && entry.sourceIndex) && entry.sourceIndex >= 0
          ? entry.sourceIndex
          : index,
        attempt: 1
      }))
      .filter(entry => typeof entry.goal === 'string' && entry.goal.trim().length > 0)
    : goals.map((goal, index) => ({
      goal,
      sourceIndex: index,
      attempt: 1
    }));
  let exhausted = false;

  while (pendingEntries.length > 0) {
    const batchAttempt = round + 1;
    const roundContinueOnError = round === 0
      ? initialContinueOnError
      : retryStrategy === 'adaptive'
        ? true
        : initialContinueOnError;
    const run = await runCloseLoopBatchGoals(
      pendingEntries.map(entry => entry.goal),
      {
        ...options,
        batchParallel: adaptiveBatchParallel,
        batchAgentBudget: adaptiveBatchAgentBudget,
        continueOnError: roundContinueOnError,
        goalEntries: pendingEntries,
        batchAttempt
      }
    );

    effectiveParallel = Math.max(effectiveParallel, Number(run.effectiveParallel) || 0);
    aggregateResourcePlan = mergeBatchResourcePlans(aggregateResourcePlan, run.resourcePlan);
    stoppedEarly = stoppedEarly || Boolean(run.stoppedEarly);

    const retryEntries = [];
    let failedCount = 0;
    let unprocessedCount = 0;
    for (let localIndex = 0; localIndex < pendingEntries.length; localIndex += 1) {
      const entry = pendingEntries[localIndex];
      const runItemRaw = Array.isArray(run.raw_results) ? run.raw_results[localIndex] : null;
      const runItem = runItemRaw
        ? {
          ...runItemRaw,
          index: entry.sourceIndex + 1,
          source_index: entry.sourceIndex,
          goal: entry.goal,
          batch_attempt: batchAttempt
        }
        : null;
      if (!runItem) {
        unprocessedCount += 1;
        retryEntries.push({
          goal: entry.goal,
          sourceIndex: entry.sourceIndex,
          attempt: batchAttempt + 1
        });
        continue;
      }

      const status = typeof runItem.status === 'string' ? runItem.status : 'unknown';
      finalResultsBySource.set(entry.sourceIndex, runItem);
      if (failedStatuses.has(status)) {
        failedCount += 1;
        retryEntries.push({
          goal: entry.goal,
          sourceIndex: entry.sourceIndex,
          attempt: batchAttempt + 1
        });
      }
    }

    const roundMetrics = buildBatchMetrics(run.results, pendingEntries.length);
    const roundRateLimitSignals = Number(roundMetrics.total_rate_limit_signals) || 0;
    const roundRateLimitBackoffMs = Number(roundMetrics.total_rate_limit_backoff_ms) || 0;
    const roundMaxLaunchHoldMs = Number(roundMetrics.max_rate_limit_launch_hold_ms) || 0;
    let nextBatchParallel = adaptiveBatchParallel;
    let nextBatchAgentBudget = adaptiveBatchAgentBudget;
    let adaptiveBackpressureApplied = false;
    const hasRateLimitPressure = roundRateLimitSignals > 0 || roundRateLimitBackoffMs > 0 || roundMaxLaunchHoldMs > 0;
    if (retryStrategy === 'adaptive' && retryEntries.length > 0 && hasRateLimitPressure) {
      if (nextBatchParallel > 1) {
        nextBatchParallel -= 1;
        adaptiveBackpressureApplied = true;
      }
      if (nextBatchAgentBudget !== null && nextBatchAgentBudget > 1) {
        nextBatchAgentBudget -= 1;
        adaptiveBackpressureApplied = true;
      }
    }

    retryHistory.push({
      round: batchAttempt,
      continue_on_error: roundContinueOnError,
      applied_batch_parallel: adaptiveBatchParallel,
      applied_batch_agent_budget: adaptiveBatchAgentBudget,
      input_goals: pendingEntries.length,
      processed_goals: run.results.length,
      failed_goals: failedCount,
      unprocessed_goals: unprocessedCount,
      stopped_early: Boolean(run.stoppedEarly),
      rate_limit_signals: roundRateLimitSignals,
      rate_limit_backoff_ms: roundRateLimitBackoffMs,
      rate_limit_launch_hold_ms: roundMaxLaunchHoldMs,
      adaptive_backpressure_applied: adaptiveBackpressureApplied,
      next_batch_parallel: nextBatchParallel,
      next_batch_agent_budget: nextBatchAgentBudget
    });

    if (retryEntries.length === 0) {
      break;
    }

    if (round >= retryMaxRounds) {
      exhausted = true;
      for (const entry of retryEntries) {
        if (!finalResultsBySource.has(entry.sourceIndex)) {
          finalResultsBySource.set(
            entry.sourceIndex,
            toBatchUnprocessedResultItem(
              entry,
              batchAttempt,
              'Goal was not processed before batch retry budget was exhausted.'
            )
          );
        }
      }
      break;
    }

    round += 1;
    pendingEntries = retryEntries;
    adaptiveBatchParallel = nextBatchParallel;
    adaptiveBatchAgentBudget = nextBatchAgentBudget;
  }

  const orderedResults = goals
    .map((goal, index) => finalResultsBySource.get(index) || toBatchUnprocessedResultItem(
      { goal, sourceIndex: index },
      round + 1,
      'Goal was not processed.'
    ));
  const effectivePerformedRounds = Math.min(retryMaxRounds, Math.max(0, retryHistory.length - 1));

  return {
    effectiveParallel,
    resourcePlan: aggregateResourcePlan,
    results: orderedResults,
    stoppedEarly: stoppedEarly && exhausted,
    retry: {
      enabled: retryMaxRounds > 0,
      strategy: retryStrategy,
      until_complete: retryUntilComplete,
      configured_rounds: configuredRetryRounds,
      max_rounds: retryMaxRounds,
      performed_rounds: effectivePerformedRounds,
      exhausted,
      history: retryHistory
    }
  };
}

function normalizeGoalFingerprint(goal) {
  return `${goal || ''}`.trim().toLowerCase().replace(/\s+/g, ' ');
}

function buildGoalInputGuard(goals, options = {}) {
  const sourceGoals = Array.isArray(goals) ? goals : [];
  const maxDuplicateGoals = normalizeSpecSessionMaxDuplicateGoals(options.specSessionMaxDuplicateGoals);
  const goalCounts = new Map();
  for (const goal of sourceGoals) {
    const fingerprint = normalizeGoalFingerprint(goal);
    if (!fingerprint) {
      continue;
    }
    goalCounts.set(fingerprint, (goalCounts.get(fingerprint) || 0) + 1);
  }
  const duplicates = [];
  let duplicateGoals = 0;
  for (const [goal, count] of goalCounts.entries()) {
    if (count <= 1) {
      continue;
    }
    duplicates.push({ goal, count });
    duplicateGoals += (count - 1);
  }
  duplicates.sort((left, right) => right.count - left.count || left.goal.localeCompare(right.goal));
  const overLimit = maxDuplicateGoals !== null && duplicateGoals > maxDuplicateGoals;
  return {
    enabled: maxDuplicateGoals !== null,
    max_duplicate_goals: maxDuplicateGoals,
    duplicate_goals: duplicateGoals,
    unique_goals: goalCounts.size,
    duplicate_examples: duplicates.slice(0, 20),
    over_limit: overLimit,
    hard_fail_triggered: Boolean(options.specSessionBudgetHardFail && overLimit)
  };
}

function buildSpecSessionGrowthGuard(summary, options = {}) {
  const maxCreated = normalizeSpecSessionMaxCreated(options.specSessionMaxCreated);
  const maxCreatedPerGoal = normalizeSpecSessionMaxCreatedPerGoal(options.specSessionMaxCreatedPerGoal);
  const budget = summary && summary.spec_session_budget && summary.spec_session_budget.enabled
    ? summary.spec_session_budget
    : null;
  const estimatedCreated = Number(budget && budget.estimated_created) || 0;
  const processedGoals = Number(summary && summary.processed_goals) || 0;
  const createdPerGoal = processedGoals > 0
    ? Number((estimatedCreated / processedGoals).toFixed(2))
    : (estimatedCreated > 0 ? estimatedCreated : 0);
  const reasons = [];
  if (maxCreated !== null && estimatedCreated > maxCreated) {
    reasons.push(`estimated_created ${estimatedCreated} exceeds allowed ${maxCreated}`);
  }
  if (maxCreatedPerGoal !== null && createdPerGoal > maxCreatedPerGoal) {
    reasons.push(`estimated_created_per_goal ${createdPerGoal} exceeds allowed ${maxCreatedPerGoal}`);
  }
  return {
    enabled: maxCreated !== null || maxCreatedPerGoal !== null,
    max_created: maxCreated,
    max_created_per_goal: maxCreatedPerGoal,
    estimated_created: estimatedCreated,
    estimated_created_per_goal: createdPerGoal,
    over_limit: reasons.length > 0,
    reasons,
    hard_fail_triggered: Boolean(options.specSessionBudgetHardFail && reasons.length > 0)
  };
}

function isSpecSessionGrowthGuardHardFailure(summary) {
  return Boolean(
    summary &&
    summary.spec_session_growth_guard &&
    summary.spec_session_growth_guard.enabled &&
    summary.spec_session_growth_guard.hard_fail_triggered
  );
}

async function startSpecSessionBudgetEvaluation(projectPath, options = {}) {
  const maxTotal = normalizeSpecSessionMaxTotal(options.specSessionMaxTotal);
  const maxCreated = normalizeSpecSessionMaxCreated(options.specSessionMaxCreated);
  const maxCreatedPerGoal = normalizeSpecSessionMaxCreatedPerGoal(options.specSessionMaxCreatedPerGoal);
  if (maxTotal === null && maxCreated === null && maxCreatedPerGoal === null) {
    return null;
  }
  const specs = await readSpecSessionEntries(projectPath);
  const totalBefore = specs.length;
  const overLimitBefore = maxTotal !== null ? totalBefore > maxTotal : false;
  return {
    enabled: true,
    max_total: maxTotal,
    max_created: maxCreated,
    max_created_per_goal: maxCreatedPerGoal,
    hard_fail: Boolean(options.specSessionBudgetHardFail),
    total_before: totalBefore,
    over_limit_before: overLimitBefore
  };
}

async function finalizeSpecSessionBudgetEvaluation(projectPath, budgetSnapshot, pruneSummary = null) {
  if (!budgetSnapshot || !budgetSnapshot.enabled) {
    return null;
  }
  const specsAfter = await readSpecSessionEntries(projectPath);
  const totalAfter = specsAfter.length;
  const prunedCount = Number(pruneSummary && pruneSummary.deleted_count) || 0;
  const estimatedCreated = Math.max(0, totalAfter + prunedCount - budgetSnapshot.total_before);
  const overLimitAfter = budgetSnapshot.max_total !== null
    ? totalAfter > budgetSnapshot.max_total
    : false;
  return {
    ...budgetSnapshot,
    total_after: totalAfter,
    pruned_count: prunedCount,
    estimated_created: estimatedCreated,
    over_limit_after: overLimitAfter,
    hard_fail_triggered: Boolean(budgetSnapshot.hard_fail && overLimitAfter)
  };
}

function isSpecSessionBudgetHardFailure(summary) {
  return Boolean(
    summary &&
    summary.spec_session_budget &&
    summary.spec_session_budget.enabled &&
    summary.spec_session_budget.hard_fail_triggered
  );
}

async function executeCloseLoopBatch(goalsResult, options, projectPath, mode = 'auto-close-loop-batch') {
  const goalInputGuard = buildGoalInputGuard(goalsResult && goalsResult.goals, options);
  if (goalInputGuard.over_limit && goalInputGuard.hard_fail_triggered) {
    throw new Error(
      `Goal input duplicate guard exceeded: ${goalInputGuard.duplicate_goals} > ${goalInputGuard.max_duplicate_goals}. ` +
      'Reduce duplicated goals or raise --spec-session-max-duplicate-goals.'
    );
  }
  const specSessionBudget = await startSpecSessionBudgetEvaluation(projectPath, options);
  if (specSessionBudget && specSessionBudget.hard_fail && specSessionBudget.over_limit_before) {
    throw new Error(
      `Spec session budget exceeded before run: ${specSessionBudget.total_before} > ${specSessionBudget.max_total}. ` +
      'Run "kse auto spec-session prune ..." or raise --spec-session-max-total.'
    );
  }
  const batchAutonomousPolicy = resolveBatchAutonomousPolicy(options, goalsResult.goals.length);
  const effectiveBatchOptions = batchAutonomousPolicy.options;
  const batchParallel = normalizeBatchParallel(effectiveBatchOptions.batchParallel);
  const batchRun = await runCloseLoopBatchWithRetries(goalsResult.goals, {
    projectPath,
    continueOnError: Boolean(effectiveBatchOptions.continueOnError),
    batchParallel,
    batchAgentBudget: effectiveBatchOptions.batchAgentBudget,
    batchPriority: effectiveBatchOptions.batchPriority,
    batchAgingFactor: effectiveBatchOptions.batchAgingFactor,
    batchRetryRounds: effectiveBatchOptions.batchRetryRounds,
    batchRetryStrategy: effectiveBatchOptions.batchRetryStrategy,
    batchRetryUntilComplete: effectiveBatchOptions.batchRetryUntilComplete,
    batchRetryMaxRounds: effectiveBatchOptions.batchRetryMaxRounds,
    goalEntries: Array.isArray(goalsResult.goal_entries) ? goalsResult.goal_entries : null,
    runOptions: buildBatchRunOptions(effectiveBatchOptions)
  });

  const results = batchRun.results;
  const stoppedEarly = batchRun.stoppedEarly;
  const failedStatuses = new Set(['failed', 'error', 'unknown', 'stopped']);
  const failedGoals = results.filter(item => failedStatuses.has(item.status)).length;
  const completedGoals = results.length - failedGoals;
  const status = failedGoals === 0
    ? 'completed'
    : completedGoals === 0
      ? 'failed'
      : 'partial-failed';
  const metrics = buildBatchMetrics(results, goalsResult.goals.length);

  const summary = {
    mode,
    status,
    goals_file: goalsResult.file,
    resumed_from_summary: goalsResult.resumedFromSummary || null,
    generated_from_goal: goalsResult.generatedFromGoal || null,
    total_goals: goalsResult.goals.length,
    processed_goals: results.length,
    completed_goals: completedGoals,
    failed_goals: failedGoals,
    batch_parallel: batchRun.effectiveParallel,
    autonomous_policy: batchAutonomousPolicy.summary,
    resource_plan: batchRun.resourcePlan,
    batch_retry: batchRun.retry,
    stopped_early: stoppedEarly,
    metrics,
    goal_input_guard: goalInputGuard,
    results
  };

  const currentRunSpecNames = collectSpecNamesFromBatchSummary(summary);
  summary.spec_session_prune = await maybePruneSpecSessionsWithPolicy(
    projectPath,
    options,
    currentRunSpecNames
  );
  summary.spec_session_budget = await finalizeSpecSessionBudgetEvaluation(
    projectPath,
    specSessionBudget,
    summary.spec_session_prune
  );
  summary.spec_session_growth_guard = buildSpecSessionGrowthGuard(summary, options);

  if (mode === 'auto-close-loop-program' || mode === 'auto-close-loop-recover') {
    summary.program_kpi = buildProgramKpiSnapshot(summary);
    summary.program_diagnostics = buildProgramDiagnostics(summary);
    summary.program_coordination = buildProgramCoordinationSnapshot(summary);
    await maybeWriteProgramKpi(summary, options.programKpiOut, projectPath);
  }

  await maybePersistCloseLoopBatchSummary(summary, options, projectPath);
  await maybeWriteOutput(summary, options.out, projectPath);

  return summary;
}

async function executeCloseLoopProgramGoal(goal, options = {}, context = {}) {
  const programStartedAt = Date.now();
  const projectPath = context.projectPath || process.cwd();
  const shouldPrintSummary = context.printSummary !== false;
  const writeOutputs = context.writeOutputs !== false;
  const programAutonomousEnabled = options.batchAutonomous !== false;
  const programAutoRecoverEnabled = options.programAutoRecover !== false;
  const programRecoverMaxRounds = normalizeRecoverMaxRounds(options.programRecoverMaxRounds);
  const programRecoverMaxMinutes = normalizeRecoverMaxMinutes(options.programRecoverMaxMinutes, '--program-recover-max-minutes');
  const programRecoverResumeStrategy = normalizeResumeStrategy(options.programRecoverResumeStrategy);
  const programGovernUntilStable = Boolean(options.programGovernUntilStable);
  const programGovernMaxRounds = normalizeProgramGovernMaxRounds(options.programGovernMaxRounds);
  const programGovernMaxMinutes = normalizeProgramGovernMaxMinutes(options.programGovernMaxMinutes);
  const programGovernAnomalyEnabled = options.programGovernAnomaly !== false;
  const programGovernAnomalyWeeks = normalizeProgramGovernAnomalyWeeks(options.programGovernAnomalyWeeks);
  const programGovernAnomalyPeriod = normalizeAutoKpiTrendPeriod(options.programGovernAnomalyPeriod);
  const programGovernUseAction = normalizeProgramGovernUseAction(options.programGovernUseAction);
  const programGovernAutoActionEnabled = options.programGovernAutoAction !== false;
  const programGatePolicy = resolveProgramGatePolicy({
    profile: options.programGateProfile,
    minSuccessRate: options.programMinSuccessRate,
    maxRiskLevel: options.programMaxRiskLevel,
    maxElapsedMinutes: options.programMaxElapsedMinutes,
    maxAgentBudget: options.programMaxAgentBudget,
    maxTotalSubSpecs: options.programMaxTotalSubSpecs
  });
  const gateFallbackProfile = normalizeProgramGateFallbackProfile(options.programGateFallbackProfile);
  const gateFallbackChain = resolveProgramGateFallbackChain(options.programGateFallbackChain, gateFallbackProfile);
  const recoveryMemoryScope = await resolveRecoveryMemoryScope(projectPath, options.recoveryMemoryScope);
  if (options.resume) {
    throw new Error('--resume is not supported in close-loop-program. Use close-loop --resume or remove --resume.');
  }
  if (options.sessionId) {
    throw new Error('--session-id is not supported in close-loop-program. Session ids are generated per goal.');
  }
  if (
    options.batchRetryMaxRounds !== undefined &&
    options.batchRetryMaxRounds !== null &&
    !options.batchRetryUntilComplete &&
    !programAutonomousEnabled
  ) {
    throw new Error('--batch-retry-max-rounds requires --batch-retry-until-complete.');
  }
  if (options.batchRetryMaxRounds !== undefined && options.batchRetryMaxRounds !== null) {
    normalizeBatchRetryMaxRounds(options.batchRetryMaxRounds);
  }
  if (options.batchSessionKeep !== undefined && options.batchSessionKeep !== null) {
    normalizeBatchSessionKeep(options.batchSessionKeep);
  }
  if (options.batchSessionOlderThanDays !== undefined && options.batchSessionOlderThanDays !== null) {
    normalizeBatchSessionOlderThanDays(options.batchSessionOlderThanDays);
  }
  if (options.specSessionKeep !== undefined && options.specSessionKeep !== null) {
    normalizeSpecKeep(options.specSessionKeep);
  }
  if (options.specSessionOlderThanDays !== undefined && options.specSessionOlderThanDays !== null) {
    normalizeOlderThanDays(options.specSessionOlderThanDays);
  }
  if (options.specSessionProtectWindowDays !== undefined && options.specSessionProtectWindowDays !== null) {
    normalizeSpecSessionProtectWindowDays(options.specSessionProtectWindowDays);
  }
  if (options.specSessionMaxTotal !== undefined && options.specSessionMaxTotal !== null) {
    normalizeSpecSessionMaxTotal(options.specSessionMaxTotal);
  }
  if (options.specSessionMaxCreated !== undefined && options.specSessionMaxCreated !== null) {
    normalizeSpecSessionMaxCreated(options.specSessionMaxCreated);
  }
  if (options.specSessionMaxCreatedPerGoal !== undefined && options.specSessionMaxCreatedPerGoal !== null) {
    normalizeSpecSessionMaxCreatedPerGoal(options.specSessionMaxCreatedPerGoal);
  }
  if (options.specSessionMaxDuplicateGoals !== undefined && options.specSessionMaxDuplicateGoals !== null) {
    normalizeSpecSessionMaxDuplicateGoals(options.specSessionMaxDuplicateGoals);
  }
  if (options.batchSessionId !== undefined && options.batchSessionId !== null) {
    const sanitizedBatchSessionId = sanitizeBatchSessionId(options.batchSessionId);
    if (!sanitizedBatchSessionId) {
      throw new Error('--batch-session-id is invalid after sanitization.');
    }
  }

  const goalsResult = buildCloseLoopBatchGoalsFromGoal(goal, options.programGoals, {
    minQualityScore: options.programMinQualityScore,
    enforceQualityGate: Boolean(options.programQualityGate)
  });
  const programOptions = {
    ...options,
    batchAutonomous: programAutonomousEnabled
  };
  const initialSummary = await executeCloseLoopBatch(goalsResult, programOptions, projectPath, 'auto-close-loop-program');
  let summary = {
    ...initialSummary,
    auto_recovery: {
      enabled: programAutoRecoverEnabled,
      triggered: false,
      converged: initialSummary.status === 'completed',
      source_status: initialSummary.status
    }
  };

  if (programAutoRecoverEnabled && initialSummary.status !== 'completed') {
    const recoveryResult = await executeCloseLoopRecoveryCycle({
      projectPath,
      sourceSummary: {
        file: initialSummary.batch_session && initialSummary.batch_session.file
          ? initialSummary.batch_session.file
          : '(auto-close-loop-program-in-memory)',
        payload: initialSummary
      },
      baseOptions: {
        ...programOptions,
        useAction: options.programRecoverUseAction
      },
      recoverAutonomousEnabled: true,
      resumeStrategy: programRecoverResumeStrategy,
      recoverUntilComplete: true,
      recoverMaxRounds: programRecoverMaxRounds,
      recoverMaxDurationMs: programRecoverMaxMinutes === null ? null : programRecoverMaxMinutes * 60 * 1000,
      recoveryMemoryScope,
      actionCandidate: options.programRecoverUseAction
    });

    summary = mergeProgramRecoveryIntoProgramSummary(
      initialSummary,
      recoveryResult.summary,
      {
        enabled: true,
        triggered: true,
        recover_until_complete: true,
        recover_max_rounds: programRecoverMaxRounds,
        recover_max_minutes: programRecoverMaxMinutes,
        resume_strategy: programRecoverResumeStrategy
      }
    );
    summary.program_kpi = buildProgramKpiSnapshot(summary);
    summary.program_diagnostics = buildProgramDiagnostics(summary);
    summary.program_coordination = buildProgramCoordinationSnapshot(summary);
    if (writeOutputs) {
      await maybeWriteProgramKpi(summary, options.programKpiOut, projectPath);
      await maybeWriteOutput(summary, options.out, projectPath);
    }
    if (programOptions.batchSession !== false) {
      await maybePersistCloseLoopBatchSummary(summary, programOptions, projectPath);
    }
  }

  const programCompletedAt = Date.now();
  summary.program_started_at = new Date(programStartedAt).toISOString();
  summary.program_completed_at = new Date(programCompletedAt).toISOString();
  summary.program_elapsed_ms = Math.max(0, programCompletedAt - programStartedAt);

  await applyProgramGateOutcome(summary, {
    projectPath,
    options: programOptions,
    programGatePolicy,
    gateFallbackChain,
    enableAutoRemediation: options.programGateAutoRemediate !== false
  });

  if (programGovernUntilStable) {
    const governanceResult = await runProgramGovernanceLoop({
      enabled: true,
      summary,
      projectPath,
      programOptions,
      baseGoalsResult: goalsResult,
      maxRounds: programGovernMaxRounds,
      maxMinutes: programGovernMaxMinutes,
      anomalyEnabled: programGovernAnomalyEnabled,
      anomalyWeeks: programGovernAnomalyWeeks,
      anomalyPeriod: programGovernAnomalyPeriod,
      programGatePolicy,
      gateFallbackChain,
      recoveryMemoryScope,
      recoverResumeStrategy: programRecoverResumeStrategy,
      recoverMaxRounds: programRecoverMaxRounds,
      recoverMaxMinutes: programRecoverMaxMinutes,
      programRecoverUseAction: options.programRecoverUseAction,
      programGateAutoRemediate: options.programGateAutoRemediate !== false,
      governUseAction: programGovernUseAction,
      governAutoActionEnabled: programGovernAutoActionEnabled
    });
    summary = governanceResult.summary;
    summary.program_governance = governanceResult.governance;
  } else {
    summary.program_governance = {
      enabled: false,
      anomaly_enabled: programGovernAnomalyEnabled,
      anomaly_weeks: programGovernAnomalyWeeks,
      anomaly_period: programGovernAnomalyPeriod,
      auto_action_enabled: programGovernAutoActionEnabled,
      action_selection_enabled: false,
      pinned_action_index: programGovernUseAction,
      max_rounds: programGovernMaxRounds,
      max_minutes: programGovernMaxMinutes,
      performed_rounds: 0,
      converged: Boolean(
        summary &&
        summary.program_gate_effective &&
        summary.program_gate_effective.passed &&
        !isSpecSessionBudgetHardFailure(summary) &&
        !isSpecSessionGrowthGuardHardFailure(summary)
      ),
      exhausted: false,
      stop_reason: 'disabled',
      history: []
    };
  }

  const finalProgramCompletedAt = Date.now();
  summary.program_completed_at = new Date(finalProgramCompletedAt).toISOString();
  summary.program_elapsed_ms = Math.max(0, finalProgramCompletedAt - programStartedAt);

  if (writeOutputs) {
    await maybeWriteProgramKpi(summary, options.programKpiOut, projectPath);
    await maybeWriteOutput(summary, options.out, projectPath);
    await maybeWriteProgramAudit(summary, options.programAuditOut, projectPath);
  }

  if (shouldPrintSummary) {
    printCloseLoopBatchSummary(summary, programOptions);
  }

  const exitCode = (
    summary.status !== 'completed' ||
    !summary.program_gate_effective.passed ||
    isSpecSessionBudgetHardFailure(summary) ||
    isSpecSessionGrowthGuardHardFailure(summary)
  ) ? 1 : 0;

  return {
    summary,
    options: programOptions,
    exitCode
  };
}

function resolveResultSourceIndex(item, fallbackIndex = 0) {
  if (Number.isInteger(item && item.source_index) && item.source_index >= 0) {
    return item.source_index;
  }
  const fromIndex = Number(item && item.index);
  if (Number.isInteger(fromIndex) && fromIndex > 0) {
    return fromIndex - 1;
  }
  return Math.max(0, fallbackIndex);
}

function getBatchFailureStatusSet() {
  return new Set(['failed', 'error', 'unknown', 'stopped']);
}

function buildProgramCoordinationSnapshot(summary) {
  const results = Array.isArray(summary && summary.results) ? summary.results : [];
  const failedStatuses = getBatchFailureStatusSet();
  const unresolvedIndexes = [];
  const masterSpecs = new Set();
  let totalSubSpecs = 0;
  for (const item of results) {
    const status = `${item && item.status ? item.status : ''}`.trim().toLowerCase();
    if (failedStatuses.has(status)) {
      unresolvedIndexes.push(resolveResultSourceIndex(item) + 1);
    }
    const masterSpec = item && typeof item.master_spec === 'string' ? item.master_spec.trim() : '';
    if (masterSpec) {
      masterSpecs.add(masterSpec);
    }
    totalSubSpecs += Number(item && item.sub_spec_count) || 0;
  }

  return {
    topology: 'master-sub',
    master_spec_count: masterSpecs.size,
    sub_spec_count: totalSubSpecs,
    unresolved_goal_count: unresolvedIndexes.length,
    unresolved_goal_indexes: unresolvedIndexes.slice(0, 50),
    scheduler: {
      batch_parallel: Number(summary && summary.batch_parallel) || 0,
      agent_budget: summary && summary.resource_plan && summary.resource_plan.agent_budget !== undefined
        ? summary.resource_plan.agent_budget
        : null,
      priority: summary && summary.resource_plan ? summary.resource_plan.scheduling_strategy : null,
      aging_factor: summary && summary.resource_plan ? summary.resource_plan.aging_factor : null
    }
  };
}

function mergeProgramRecoveryIntoProgramSummary(initialSummary, recoverySummary, metadata = {}) {
  const baseSummary = initialSummary && typeof initialSummary === 'object' ? initialSummary : {};
  const recovery = recoverySummary && typeof recoverySummary === 'object' ? recoverySummary : {};
  const failedStatuses = getBatchFailureStatusSet();
  const mergedBySource = new Map();

  const initialResults = Array.isArray(baseSummary.results) ? baseSummary.results : [];
  for (let index = 0; index < initialResults.length; index += 1) {
    const item = initialResults[index];
    const sourceIndex = resolveResultSourceIndex(item, index);
    mergedBySource.set(sourceIndex, {
      ...item,
      source_index: sourceIndex,
      index: sourceIndex + 1
    });
  }

  const recoveryResults = Array.isArray(recovery.results) ? recovery.results : [];
  for (let index = 0; index < recoveryResults.length; index += 1) {
    const item = recoveryResults[index];
    const sourceIndex = resolveResultSourceIndex(item, index);
    mergedBySource.set(sourceIndex, {
      ...item,
      source_index: sourceIndex,
      index: sourceIndex + 1,
      recovered_by_program: true
    });
  }

  const orderedResults = [...mergedBySource.entries()]
    .sort((a, b) => a[0] - b[0])
    .map(([, item]) => item);
  const totalGoals = Number(baseSummary.total_goals) || orderedResults.length;
  const failedGoals = orderedResults.filter(item => failedStatuses.has(`${item && item.status ? item.status : ''}`.trim().toLowerCase())).length;
  const completedGoals = orderedResults.length - failedGoals;
  const status = failedGoals === 0
    ? 'completed'
    : completedGoals === 0
      ? 'failed'
      : 'partial-failed';
  const mergedResourcePlan = mergeBatchResourcePlans(baseSummary.resource_plan || null, recovery.resource_plan || null);

  return {
    ...baseSummary,
    status,
    total_goals: totalGoals,
    processed_goals: orderedResults.length,
    completed_goals: completedGoals,
    failed_goals: failedGoals,
    batch_parallel: Math.max(Number(baseSummary.batch_parallel) || 0, Number(recovery.batch_parallel) || 0),
    resource_plan: mergedResourcePlan,
    metrics: buildBatchMetrics(orderedResults, totalGoals),
    results: orderedResults,
    auto_recovery: {
      ...metadata,
      source_status: baseSummary.status || null,
      recovery_status: recovery.status || null,
      converged: recovery.status === 'completed',
      selected_action_index: recovery.recovered_from_summary
        ? recovery.recovered_from_summary.selected_action_index
        : null,
      selection_source: recovery.recovery_plan ? recovery.recovery_plan.selection_source : null,
      recovery_cycle: recovery.recovery_cycle || null,
      recovery_memory: recovery.recovery_memory || null
    }
  };
}

async function executeCloseLoopRecoveryCycle({
  projectPath,
  sourceSummary,
  baseOptions,
  recoverAutonomousEnabled,
  resumeStrategy,
  recoverUntilComplete,
  recoverMaxRounds,
  recoverMaxDurationMs,
  recoveryMemoryTtlDays,
  recoveryMemoryScope,
  actionCandidate
}) {
  let resolvedSourceSummary = sourceSummary && typeof sourceSummary === 'object'
    ? {
      file: typeof sourceSummary.file === 'string' && sourceSummary.file.trim()
        ? sourceSummary.file
        : '(in-memory-summary)',
      payload: sourceSummary.payload && typeof sourceSummary.payload === 'object'
        ? sourceSummary.payload
        : {}
    }
    : {
      file: '(in-memory-summary)',
      payload: {}
    };

  if (recoveryMemoryTtlDays !== null && recoveryMemoryTtlDays !== undefined) {
    await pruneCloseLoopRecoveryMemory(projectPath, {
      olderThanDays: recoveryMemoryTtlDays,
      dryRun: false
    });
  }
  const recoveryMemory = await loadCloseLoopRecoveryMemory(projectPath);
  const resolvedRecoveryScope = normalizeRecoveryMemoryToken(recoveryMemoryScope || '') || 'default-scope';
  const recoverySignature = buildRecoveryMemorySignature(resolvedSourceSummary.payload, {
    scope: resolvedRecoveryScope
  });
  const recoveryMemoryEntry = getRecoveryMemoryEntry(recoveryMemory.payload, recoverySignature);
  const pinnedActionSelection = resolveRecoveryActionSelection(
    resolvedSourceSummary.payload,
    actionCandidate,
    { recoveryMemoryEntry }
  );

  let finalSummary = null;
  let finalRecoveryOptions = null;
  const recoveryHistory = [];
  const recoveryStartedAt = Date.now();
  let budgetExhausted = false;
  for (let round = 1; round <= recoverMaxRounds; round += 1) {
    if (recoverMaxDurationMs !== null && recoverMaxDurationMs !== undefined) {
      const elapsedBeforeRound = Date.now() - recoveryStartedAt;
      if (elapsedBeforeRound >= recoverMaxDurationMs && finalSummary) {
        budgetExhausted = true;
        break;
      }
    }

    const recoveryOptions = applyRecoveryActionPatch({
      ...baseOptions,
      batchAutonomous: recoverAutonomousEnabled
    }, pinnedActionSelection.selectedAction);

    if (
      recoverUntilComplete &&
      typeof recoveryOptions.batchSessionId === 'string' &&
      recoveryOptions.batchSessionId.trim()
    ) {
      recoveryOptions.batchSessionId = `${recoveryOptions.batchSessionId.trim()}-r${round}`;
    }

    const goalsResult = await buildCloseLoopBatchGoalsFromSummaryPayload(
      resolvedSourceSummary.payload,
      resolvedSourceSummary.file,
      projectPath,
      'auto',
      resumeStrategy
    );
    const summary = await executeCloseLoopBatch(
      goalsResult,
      recoveryOptions,
      projectPath,
      'auto-close-loop-recover'
    );

    summary.recovered_from_summary = {
      file: resolvedSourceSummary.file,
      source_mode: resolvedSourceSummary.payload.mode || null,
      source_status: resolvedSourceSummary.payload.status || null,
      resume_strategy: resumeStrategy,
      selected_action_index: pinnedActionSelection.selectedIndex,
      selected_action: pinnedActionSelection.selectedAction || null,
      round
    };
    summary.recovery_plan = {
      remediation_actions: pinnedActionSelection.availableActions,
      applied_patch: pinnedActionSelection.appliedPatch,
      selection_source: pinnedActionSelection.selectionSource,
      selection_explain: pinnedActionSelection.selectionExplain || null
    };

    recoveryHistory.push({
      round,
      source_summary: resolvedSourceSummary.file,
      status: summary.status,
      processed_goals: summary.processed_goals,
      completed_goals: summary.completed_goals,
      failed_goals: summary.failed_goals,
      batch_session_file: summary.batch_session && summary.batch_session.file
        ? summary.batch_session.file
        : null
    });

    finalSummary = summary;
    finalRecoveryOptions = recoveryOptions;

    if (!recoverUntilComplete || summary.status === 'completed') {
      break;
    }

    resolvedSourceSummary = summary.batch_session && summary.batch_session.file
      ? await loadCloseLoopBatchSummaryPayload(projectPath, summary.batch_session.file)
      : {
        file: '(derived-from-summary)',
        payload: summary
      };
  }

  if (!finalSummary) {
    throw new Error('Recovery cycle did not produce a summary.');
  }

  finalSummary.recovery_cycle = {
    enabled: recoverUntilComplete,
    max_rounds: recoverMaxRounds,
    performed_rounds: recoveryHistory.length,
    converged: finalSummary.status === 'completed',
    exhausted: (
      (recoverUntilComplete && recoveryHistory.length >= recoverMaxRounds && finalSummary.status !== 'completed') ||
      budgetExhausted
    ),
    time_budget_minutes: recoverMaxDurationMs ? Number((recoverMaxDurationMs / 60000).toFixed(2)) : null,
    elapsed_ms: Date.now() - recoveryStartedAt,
    budget_exhausted: budgetExhausted,
    history: recoveryHistory
  };

  const memoryUpdate = await updateCloseLoopRecoveryMemory(
    projectPath,
    recoveryMemory,
    recoverySignature,
    pinnedActionSelection.selectedIndex,
    pinnedActionSelection.selectedAction,
    finalSummary.status,
    { scope: resolvedRecoveryScope }
  );
  finalSummary.recovery_memory = {
    file: memoryUpdate.file,
    signature: memoryUpdate.signature,
    scope: memoryUpdate.scope,
    action_key: memoryUpdate.action_key,
    selected_action_index: pinnedActionSelection.selectedIndex,
    selection_source: pinnedActionSelection.selectionSource,
    selection_explain: pinnedActionSelection.selectionExplain || null,
    action_stats: memoryUpdate.entry
  };

  return {
    summary: finalSummary,
    options: finalRecoveryOptions || baseOptions,
    pinnedActionSelection
  };
}

function resolveControllerQueueFile(projectPath, queueFileCandidate) {
  const normalized = typeof queueFileCandidate === 'string' && queueFileCandidate.trim()
    ? queueFileCandidate.trim()
    : '.kiro/auto/close-loop-controller-goals.lines';
  return path.isAbsolute(normalized)
    ? normalized
    : path.join(projectPath, normalized);
}

function resolveControllerQueueFormat(resolvedQueueFile, formatCandidate) {
  const normalized = normalizeBatchFormat(formatCandidate);
  if (normalized !== 'auto') {
    return normalized;
  }
  return `${resolvedQueueFile}`.toLowerCase().endsWith('.json')
    ? 'json'
    : 'lines';
}

function dedupeControllerGoals(goals) {
  const uniqueGoals = [];
  const seen = new Set();
  let duplicateCount = 0;
  for (const item of Array.isArray(goals) ? goals : []) {
    const normalized = `${item || ''}`.trim();
    if (!normalized) {
      continue;
    }
    const fingerprint = normalized.toLowerCase();
    if (seen.has(fingerprint)) {
      duplicateCount += 1;
      continue;
    }
    seen.add(fingerprint);
    uniqueGoals.push(normalized);
  }
  return {
    goals: uniqueGoals,
    duplicate_count: duplicateCount
  };
}

async function loadControllerGoalQueue(projectPath, queueFileCandidate, formatCandidate, options = {}) {
  const file = resolveControllerQueueFile(projectPath, queueFileCandidate);
  const format = resolveControllerQueueFormat(file, formatCandidate);
  const dedupe = options.dedupe === true;
  if (!(await fs.pathExists(file))) {
    await fs.ensureDir(path.dirname(file));
    if (format === 'json') {
      await fs.writeJson(file, { goals: [] }, { spaces: 2 });
    } else {
      await fs.writeFile(file, '', 'utf8');
    }
  }

  let goals = [];
  if (format === 'json') {
    let payload = null;
    try {
      payload = await fs.readJson(file);
    } catch (error) {
      throw new Error(`Invalid controller queue JSON: ${file} (${error.message})`);
    }
    goals = parseGoalsFromJsonPayload(payload || {});
  } else {
    const content = await fs.readFile(file, 'utf8');
    goals = parseGoalsFromLines(content);
  }

  const normalizedGoals = goals
    .map(item => `${item || ''}`.trim())
    .filter(Boolean);
  const dedupeResult = dedupe
    ? dedupeControllerGoals(normalizedGoals)
    : {
      goals: normalizedGoals,
      duplicate_count: 0
    };

  return {
    file,
    format,
    goals: dedupeResult.goals,
    duplicate_count: dedupeResult.duplicate_count,
    dedupe_applied: dedupe
  };
}

async function writeControllerGoalQueue(file, format, goals) {
  const normalizedGoals = Array.isArray(goals)
    ? goals.map(item => `${item || ''}`.trim()).filter(Boolean)
    : [];
  await fs.ensureDir(path.dirname(file));
  if (format === 'json') {
    await fs.writeJson(file, { goals: normalizedGoals }, { spaces: 2 });
    return;
  }
  const content = normalizedGoals.length > 0
    ? `${normalizedGoals.join('\n')}\n`
    : '';
  await fs.writeFile(file, content, 'utf8');
}

async function appendControllerGoalArchive(fileCandidate, projectPath, goal, metadata = {}) {
  if (!fileCandidate) {
    return null;
  }
  const resolvedFile = path.isAbsolute(fileCandidate)
    ? fileCandidate
    : path.join(projectPath, fileCandidate);
  await fs.ensureDir(path.dirname(resolvedFile));
  const timestamp = new Date().toISOString();
  const normalizedGoal = `${goal || ''}`.replace(/\r?\n/g, ' ').trim();
  const fields = [
    timestamp,
    `${metadata.status || ''}`.trim() || 'unknown',
    `${metadata.program_status || ''}`.trim() || 'unknown',
    `${metadata.gate_passed === true ? 'gate-pass' : 'gate-fail'}`,
    normalizedGoal
  ];
  await fs.appendFile(resolvedFile, `${fields.join('\t')}\n`, 'utf8');
  return resolvedFile;
}

async function sleepForMs(durationMs) {
  return new Promise(resolve => {
    setTimeout(resolve, Math.max(0, durationMs));
  });
}

function resolveControllerLockFile(projectPath, queueFilePath, lockFileCandidate) {
  const normalized = typeof lockFileCandidate === 'string' && lockFileCandidate.trim()
    ? lockFileCandidate.trim()
    : `${queueFilePath}.lock`;
  return path.isAbsolute(normalized)
    ? normalized
    : path.join(projectPath, normalized);
}

async function readControllerLockPayload(lockFile) {
  if (!(await fs.pathExists(lockFile))) {
    return null;
  }
  try {
    return await fs.readJson(lockFile);
  } catch (error) {
    return null;
  }
}

function buildControllerLockPayload(lockToken) {
  return {
    token: lockToken,
    pid: process.pid,
    host: process.env.COMPUTERNAME || process.env.HOSTNAME || null,
    acquired_at: new Date().toISOString(),
    touched_at: new Date().toISOString()
  };
}

async function writeControllerLockPayload(lockFile, payload, mode = 'overwrite') {
  await fs.ensureDir(path.dirname(lockFile));
  if (mode === 'create') {
    await fs.writeFile(lockFile, JSON.stringify(payload, null, 2), {
      encoding: 'utf8',
      flag: 'wx'
    });
    return;
  }
  await fs.writeJson(lockFile, payload, { spaces: 2 });
}

function isControllerLockStale(stats, ttlSeconds) {
  const mtimeMs = Number(stats && stats.mtimeMs) || 0;
  const ttlMs = Math.max(1, ttlSeconds) * 1000;
  return mtimeMs > 0 && (Date.now() - mtimeMs) > ttlMs;
}

async function acquireControllerLock(projectPath, queueFilePath, options = {}) {
  if (options.controllerLock === false) {
    return null;
  }

  const ttlSeconds = normalizeControllerLockTtlSeconds(options.controllerLockTtlSeconds);
  const lockFile = resolveControllerLockFile(projectPath, queueFilePath, options.controllerLockFile);
  const token = `${Date.now()}-${process.pid}-${Math.random().toString(36).slice(2, 10)}`;
  const payload = buildControllerLockPayload(token);

  const attemptAcquire = async () => {
    await writeControllerLockPayload(lockFile, payload, 'create');
    return {
      file: lockFile,
      token,
      ttl_seconds: ttlSeconds
    };
  };

  try {
    return await attemptAcquire();
  } catch (error) {
    if (!error || error.code !== 'EEXIST') {
      throw new Error(`Failed to acquire controller lock: ${lockFile} (${error.message})`);
    }
  }

  let lockStats = null;
  try {
    lockStats = await fs.stat(lockFile);
  } catch (error) {
    return attemptAcquire();
  }

  if (isControllerLockStale(lockStats, ttlSeconds)) {
    try {
      await fs.remove(lockFile);
      return await attemptAcquire();
    } catch (error) {
      throw new Error(`Failed to take over stale controller lock: ${lockFile} (${error.message})`);
    }
  }

  const holder = await readControllerLockPayload(lockFile);
  const holderPid = holder && holder.pid ? holder.pid : 'unknown';
  const holderHost = holder && holder.host ? holder.host : 'unknown-host';
  throw new Error(
    `Controller lock is held by pid=${holderPid} host=${holderHost}: ${lockFile}. ` +
    'Use --no-controller-lock only if you intentionally allow concurrent controllers.'
  );
}

async function refreshControllerLock(lockState) {
  if (!lockState || !lockState.file) {
    return;
  }
  const payload = await readControllerLockPayload(lockState.file);
  if (!payload || payload.token !== lockState.token) {
    throw new Error(`Controller lock ownership lost: ${lockState.file}`);
  }
  payload.touched_at = new Date().toISOString();
  await writeControllerLockPayload(lockState.file, payload, 'overwrite');
}

async function releaseControllerLock(lockState) {
  if (!lockState || !lockState.file) {
    return;
  }
  const payload = await readControllerLockPayload(lockState.file);
  if (!payload || payload.token !== lockState.token) {
    return;
  }
  await fs.remove(lockState.file);
}

async function runCloseLoopController(queueFile, options = {}, context = {}) {
  const projectPath = context.projectPath || process.cwd();
  const resumedSession = context.resumedSession || null;
  const queueInput = typeof queueFile === 'string' && queueFile.trim()
    ? queueFile.trim()
    : resumedSession && resumedSession.payload && typeof resumedSession.payload.queue_file === 'string'
      ? resumedSession.payload.queue_file
      : null;
  const queueFormatCandidate = (
    options.queueFormat === 'auto' &&
    resumedSession &&
    resumedSession.payload &&
    typeof resumedSession.payload.queue_format === 'string' &&
    resumedSession.payload.queue_format.trim()
  )
    ? resumedSession.payload.queue_format
    : options.queueFormat;
  const queuePayload = await loadControllerGoalQueue(projectPath, queueInput, queueFormatCandidate, {
    dedupe: options.controllerDedupe !== false
  });
  const maxCycles = normalizeControllerMaxCycles(options.maxCycles);
  const maxMinutes = normalizeControllerMaxMinutes(options.maxMinutes);
  const maxDurationMs = maxMinutes * 60 * 1000;
  const pollSeconds = normalizeControllerPollSeconds(options.pollSeconds);
  const dequeueLimit = normalizeControllerDequeueLimit(options.dequeueLimit);
  const waitOnEmpty = Boolean(options.waitOnEmpty);
  const stopOnGoalFailure = Boolean(options.stopOnGoalFailure);
  const startedAt = Date.now();
  const history = [];
  const results = [];
  let performedCycles = 0;
  let stopReason = 'completed';
  let exhausted = false;
  let haltRequested = false;
  let doneArchiveFile = null;
  let failedArchiveFile = null;
  let dedupeDroppedGoals = Number(queuePayload.duplicate_count) || 0;
  let lockState = null;

  if (options.controllerDedupe !== false && queuePayload.duplicate_count > 0) {
    await writeControllerGoalQueue(queuePayload.file, queuePayload.format, queuePayload.goals);
  }

  lockState = await acquireControllerLock(projectPath, queuePayload.file, options);

  try {
    for (let cycle = 1; cycle <= maxCycles; cycle += 1) {
      if ((Date.now() - startedAt) >= maxDurationMs) {
        exhausted = true;
        stopReason = 'time-budget-exhausted';
        break;
      }

      await refreshControllerLock(lockState);

      const currentQueue = await loadControllerGoalQueue(projectPath, queuePayload.file, queuePayload.format, {
        dedupe: options.controllerDedupe !== false
      });
      const pendingGoals = currentQueue.goals;
      dedupeDroppedGoals += Number(currentQueue.duplicate_count) || 0;

      if (options.controllerDedupe !== false && currentQueue.duplicate_count > 0) {
        await writeControllerGoalQueue(currentQueue.file, currentQueue.format, pendingGoals);
      }

      if (pendingGoals.length === 0) {
        history.push({
          cycle,
          queue_before: 0,
          dequeued: 0,
          queue_after: 0,
          status: waitOnEmpty ? 'idle-wait' : 'empty-stop'
        });
        performedCycles += 1;
        if (!waitOnEmpty) {
          stopReason = 'queue-empty';
          break;
        }
        await sleepForMs(pollSeconds * 1000);
        continue;
      }

      const effectiveDequeueLimit = dequeueLimit === null ? pendingGoals.length : dequeueLimit;
      const dequeuedGoals = pendingGoals.slice(0, effectiveDequeueLimit);
      const remainingGoals = pendingGoals.slice(dequeuedGoals.length);
      await writeControllerGoalQueue(currentQueue.file, currentQueue.format, remainingGoals);

      const cycleRecord = {
        cycle,
        queue_before: pendingGoals.length,
        dequeued: dequeuedGoals.length,
        queue_after: remainingGoals.length,
        processed: 0,
        completed: 0,
        failed: 0,
        status: 'processed'
      };

      for (let index = 0; index < dequeuedGoals.length; index += 1) {
        const goal = dequeuedGoals[index];
        const goalStartedAt = Date.now();
        let goalResult = {
          cycle,
          queue_index: index + 1,
          goal,
          status: 'failed',
          error: null
        };

        try {
          const perGoalOptions = {
            ...options,
            out: null,
            programKpiOut: null,
            programAuditOut: null,
            json: false
          };
          const programResult = await executeCloseLoopProgramGoal(goal, perGoalOptions, {
            projectPath,
            printSummary: options.controllerPrintProgramSummary === true,
            writeOutputs: false
          });
          const programSummary = programResult.summary || {};
          const failed = programResult.exitCode !== 0;
          goalResult = {
            ...goalResult,
            status: failed ? 'failed' : 'completed',
            program_status: programSummary.status || null,
            program_gate_passed: Boolean(
              programSummary.program_gate_effective &&
              programSummary.program_gate_effective.passed
            ),
            governance_stop_reason: programSummary.program_governance
              ? programSummary.program_governance.stop_reason
              : null,
            batch_session_file: programSummary.batch_session && programSummary.batch_session.file
              ? programSummary.batch_session.file
              : null
          };
        } catch (error) {
          goalResult.error = error.message;
        }

        goalResult.elapsed_ms = Math.max(0, Date.now() - goalStartedAt);
        results.push(goalResult);
        cycleRecord.processed += 1;

        if (goalResult.status === 'completed') {
          cycleRecord.completed += 1;
          doneArchiveFile = await appendControllerGoalArchive(
            options.controllerDoneFile,
            projectPath,
            goal,
            {
              status: 'completed',
              program_status: goalResult.program_status,
              gate_passed: goalResult.program_gate_passed
            }
          ) || doneArchiveFile;
        } else {
          cycleRecord.failed += 1;
          failedArchiveFile = await appendControllerGoalArchive(
            options.controllerFailedFile,
            projectPath,
            goal,
            {
              status: 'failed',
              program_status: goalResult.program_status,
              gate_passed: goalResult.program_gate_passed
            }
          ) || failedArchiveFile;
          if (stopOnGoalFailure) {
            haltRequested = true;
          }
        }

        if (haltRequested) {
          break;
        }
      }

      if (haltRequested) {
        cycleRecord.status = 'stopped-on-goal-failure';
        stopReason = 'goal-failure';
      }
      history.push(cycleRecord);
      performedCycles += 1;

      if (haltRequested) {
        break;
      }
    }
  } finally {
    await releaseControllerLock(lockState);
  }

  const finalQueue = await loadControllerGoalQueue(projectPath, queuePayload.file, queuePayload.format, {
    dedupe: options.controllerDedupe !== false
  });
  const pendingGoals = finalQueue.goals.length;
  dedupeDroppedGoals += Number(finalQueue.duplicate_count) || 0;
  if (options.controllerDedupe !== false && finalQueue.duplicate_count > 0) {
    await writeControllerGoalQueue(finalQueue.file, finalQueue.format, finalQueue.goals);
  }

  if (!exhausted && stopReason === 'completed') {
    if (performedCycles >= maxCycles && (pendingGoals > 0 || waitOnEmpty)) {
      exhausted = true;
      stopReason = 'cycle-limit-reached';
    } else if (pendingGoals === 0 && results.length === 0) {
      stopReason = 'queue-empty';
    }
  }

  const completedGoals = results.filter(item => item.status === 'completed').length;
  const failedGoals = results.filter(item => item.status !== 'completed').length;
  const status = failedGoals === 0
    ? 'completed'
    : completedGoals === 0
      ? 'failed'
      : 'partial-failed';
  const summary = {
    mode: 'auto-close-loop-controller',
    status,
    queue_file: queuePayload.file,
    queue_format: queuePayload.format,
    started_at: new Date(startedAt).toISOString(),
    completed_at: new Date().toISOString(),
    elapsed_ms: Math.max(0, Date.now() - startedAt),
    wait_on_empty: waitOnEmpty,
    poll_seconds: pollSeconds,
    dequeue_limit: dequeueLimit === null ? 'all' : dequeueLimit,
    max_cycles: maxCycles,
    max_minutes: maxMinutes,
    cycles_performed: performedCycles,
    exhausted,
    stop_reason: stopReason,
    processed_goals: results.length,
    completed_goals: completedGoals,
    failed_goals: failedGoals,
    pending_goals: pendingGoals,
    dedupe_enabled: options.controllerDedupe !== false,
    dedupe_dropped_goals: dedupeDroppedGoals,
    lock_enabled: options.controllerLock !== false,
    lock_file: lockState && lockState.file ? lockState.file : null,
    lock_ttl_seconds: lockState && Number.isInteger(lockState.ttl_seconds) ? lockState.ttl_seconds : null,
    resumed_from_controller_session: resumedSession
      ? {
        id: resumedSession.id,
        file: resumedSession.file,
        status: resumedSession.payload && resumedSession.payload.status
          ? resumedSession.payload.status
          : null
      }
      : null,
    history,
    results,
    done_archive_file: doneArchiveFile,
    failed_archive_file: failedArchiveFile
  };

  await maybePersistCloseLoopControllerSummary(summary, options, projectPath);
  await maybeWriteOutput(summary, options.controllerOut, projectPath);
  return summary;
}

function printCloseLoopControllerSummary(summary) {
  console.log(chalk.blue('Autonomous close-loop controller summary'));
  console.log(chalk.gray(`  Status: ${summary.status}`));
  console.log(chalk.gray(`  Cycles: ${summary.cycles_performed}/${summary.max_cycles}`));
  console.log(chalk.gray(`  Processed goals: ${summary.processed_goals}`));
  console.log(chalk.gray(`  Completed: ${summary.completed_goals}`));
  console.log(chalk.gray(`  Failed: ${summary.failed_goals}`));
  console.log(chalk.gray(`  Pending queue goals: ${summary.pending_goals}`));
  if (summary.dedupe_enabled) {
    console.log(chalk.gray(`  Dedupe dropped: ${summary.dedupe_dropped_goals || 0}`));
  }
  console.log(chalk.gray(`  Stop reason: ${summary.stop_reason}`));
  if (summary.lock_enabled && summary.lock_file) {
    console.log(chalk.gray(`  Lock: ${summary.lock_file}`));
  }
  if (summary.controller_session && summary.controller_session.file) {
    console.log(chalk.gray(`  Session: ${summary.controller_session.file}`));
  }
  if (summary.done_archive_file) {
    console.log(chalk.gray(`  Done archive: ${summary.done_archive_file}`));
  }
  if (summary.failed_archive_file) {
    console.log(chalk.gray(`  Failed archive: ${summary.failed_archive_file}`));
  }
  if (summary.output_file) {
    console.log(chalk.gray(`  Output: ${summary.output_file}`));
  }
}

function printCloseLoopBatchSummary(summary, options) {
  if (options.json) {
    console.log(JSON.stringify(summary, null, 2));
    return;
  }

  const title = summary.mode === 'auto-close-loop-program'
    ? 'Autonomous close-loop program summary'
    : summary.mode === 'auto-close-loop-recover'
      ? 'Autonomous close-loop recovery summary'
    : 'Autonomous close-loop batch summary';
  console.log(chalk.blue(title));
  console.log(chalk.gray(`  Status: ${summary.status}`));
  console.log(chalk.gray(`  Processed: ${summary.processed_goals}/${summary.total_goals}`));
  console.log(chalk.gray(`  Completed: ${summary.completed_goals}`));
  console.log(chalk.gray(`  Failed: ${summary.failed_goals}`));
  console.log(chalk.gray(`  Batch parallel: ${summary.batch_parallel}`));
  if (summary.autonomous_policy && summary.autonomous_policy.enabled) {
    console.log(chalk.gray(`  Autonomous policy: ${summary.autonomous_policy.profile}`));
  }
  if (summary.batch_retry && summary.batch_retry.performed_rounds > 0) {
    console.log(chalk.gray(
      `  Batch retry: ${summary.batch_retry.performed_rounds}/${summary.batch_retry.configured_rounds} extra rounds`
    ));
  }
  if (summary.resource_plan.agent_budget !== null) {
    console.log(chalk.gray(
      `  Agent budget: ${summary.resource_plan.agent_budget} ` +
      `(per-goal maxParallel=${summary.resource_plan.per_goal_max_parallel})`
    ));
  }
  console.log(chalk.gray(`  Success rate: ${summary.metrics.success_rate_percent}%`));
  if (summary.program_kpi) {
    console.log(chalk.gray(
      `  Program KPI: ${summary.program_kpi.convergence_state}, ` +
      `risk=${summary.program_kpi.risk_level}, ` +
      `retry-recovery=${summary.program_kpi.retry_recovery_rate_percent}%`
    ));
  }
  if (summary.program_gate) {
    console.log(chalk.gray(
      `  Program gate: ${summary.program_gate.passed ? 'passed' : 'failed'} ` +
      `(profile=${summary.program_gate.policy.profile || 'default'}, ` +
      `min-success=${summary.program_gate.policy.min_success_rate_percent}%, ` +
      `max-risk=${summary.program_gate.policy.max_risk_level})`
    ));
    const gatePolicy = summary.program_gate.policy || {};
    const gateActual = summary.program_gate.actual || {};
    if (
      gatePolicy.max_elapsed_minutes !== null ||
      gatePolicy.max_agent_budget !== null ||
      gatePolicy.max_total_sub_specs !== null
    ) {
      console.log(chalk.gray(
        `  Program budget gate: elapsed=${gateActual.elapsed_minutes ?? 'n/a'}/${gatePolicy.max_elapsed_minutes ?? 'n/a'} min, ` +
        `agent=${gateActual.agent_budget ?? 'n/a'}/${gatePolicy.max_agent_budget ?? 'n/a'}, ` +
        `sub-specs=${gateActual.total_sub_specs ?? 'n/a'}/${gatePolicy.max_total_sub_specs ?? 'n/a'}`
      ));
    }
    if (
      summary.program_gate_effective &&
      summary.program_gate_effective.source !== 'primary' &&
      summary.program_gate_effective.fallback_profile
    ) {
      console.log(chalk.gray(
        `  Program gate fallback accepted: profile=${summary.program_gate_effective.fallback_profile}`
      ));
    }
  }
  if (
    summary.program_diagnostics &&
    Array.isArray(summary.program_diagnostics.remediation_actions) &&
    summary.program_diagnostics.remediation_actions.length > 0
  ) {
    const topAction = summary.program_diagnostics.remediation_actions[0];
    console.log(chalk.gray(`  Top remediation: ${topAction.action}`));
  }
  if (summary.recovery_cycle && summary.recovery_cycle.enabled) {
    console.log(chalk.gray(
      `  Recovery rounds: ${summary.recovery_cycle.performed_rounds}/${summary.recovery_cycle.max_rounds}`
    ));
    if (summary.recovery_cycle.budget_exhausted) {
      console.log(chalk.gray('  Recovery time budget exhausted before convergence.'));
    }
  }
  if (summary.auto_recovery && summary.auto_recovery.triggered) {
    console.log(chalk.gray(
      `  Program auto-recovery: ${summary.auto_recovery.recovery_status} ` +
      `(action ${summary.auto_recovery.selected_action_index || 'n/a'}, ` +
      `source=${summary.auto_recovery.selection_source || 'default'})`
    ));
  }
  if (summary.program_governance && summary.program_governance.enabled) {
    console.log(chalk.gray(
      `  Program governance: ${summary.program_governance.performed_rounds}/` +
      `${summary.program_governance.max_rounds} rounds, stop=${summary.program_governance.stop_reason}`
    ));
    if (summary.program_governance.action_selection_enabled) {
      console.log(chalk.gray(
        `  Governance action selection: ` +
        `${summary.program_governance.auto_action_enabled ? 'auto' : 'manual-only'}, ` +
        `pinned=${summary.program_governance.pinned_action_index || 'none'}`
      ));
    }
    if (Array.isArray(summary.program_governance.history) && summary.program_governance.history.length > 0) {
      const latestRound = summary.program_governance.history[summary.program_governance.history.length - 1];
      if (latestRound && latestRound.selected_action) {
        console.log(chalk.gray(
          `  Governance selected action: #${latestRound.selected_action_index || 'n/a'} ${latestRound.selected_action}`
        ));
      }
    }
    if (summary.program_governance.exhausted) {
      console.log(chalk.yellow('  Program governance exhausted before reaching stable state.'));
    }
  }
  if (Array.isArray(summary.program_kpi_anomalies) && summary.program_kpi_anomalies.length > 0) {
    const highCount = summary.program_kpi_anomalies
      .filter(item => `${item && item.severity ? item.severity : ''}`.trim().toLowerCase() === 'high')
      .length;
    console.log(chalk.gray(
      `  Program KPI anomalies: total=${summary.program_kpi_anomalies.length}, high=${highCount}`
    ));
  }
  if (summary.program_coordination) {
    console.log(chalk.gray(
      `  Master/Sub sync: masters=${summary.program_coordination.master_spec_count}, ` +
      `sub-specs=${summary.program_coordination.sub_spec_count}, ` +
      `unresolved=${summary.program_coordination.unresolved_goal_count}`
    ));
  }
  if (summary.batch_session && summary.batch_session.file) {
    console.log(chalk.gray(`  Batch session: ${summary.batch_session.file}`));
  }
  if (summary.goal_input_guard && summary.goal_input_guard.enabled) {
    console.log(chalk.gray(
      `  Goal duplicate guard: duplicates=${summary.goal_input_guard.duplicate_goals}/` +
      `${summary.goal_input_guard.max_duplicate_goals}`
    ));
    if (summary.goal_input_guard.over_limit) {
      console.log(chalk.yellow('  Goal duplicate guard exceeded.'));
    }
  }
  if (summary.spec_session_prune && summary.spec_session_prune.enabled) {
    console.log(chalk.gray(
      `  Spec prune: deleted=${summary.spec_session_prune.deleted_count}, ` +
      `protected=${summary.spec_session_prune.protected_count}`
    ));
  }
  if (summary.spec_session_budget && summary.spec_session_budget.enabled) {
    console.log(chalk.gray(
      `  Spec budget: ${summary.spec_session_budget.total_after}/${summary.spec_session_budget.max_total} ` +
      `(created~${summary.spec_session_budget.estimated_created}, pruned=${summary.spec_session_budget.pruned_count})`
    ));
    if (summary.spec_session_budget.over_limit_after) {
      console.log(chalk.yellow(
        `  Spec budget exceeded (${summary.spec_session_budget.total_after} > ${summary.spec_session_budget.max_total})`
      ));
    }
  }
  if (summary.spec_session_growth_guard && summary.spec_session_growth_guard.enabled) {
    console.log(chalk.gray(
      `  Spec growth guard: created~${summary.spec_session_growth_guard.estimated_created}` +
      ` (per-goal=${summary.spec_session_growth_guard.estimated_created_per_goal})`
    ));
    if (summary.spec_session_growth_guard.over_limit) {
      console.log(chalk.yellow(`  Spec growth guard exceeded: ${summary.spec_session_growth_guard.reasons.join('; ')}`));
    }
  }
  if (summary.program_gate_auto_remediation && summary.program_gate_auto_remediation.enabled) {
    const autoRemediationActions = Array.isArray(summary.program_gate_auto_remediation.actions)
      ? summary.program_gate_auto_remediation.actions
      : [];
    console.log(chalk.gray(
      `  Program auto-remediation: actions=${autoRemediationActions.length}, ` +
      `next-patch=${summary.program_gate_auto_remediation.next_run_patch ? 'yes' : 'no'}`
    ));
  }
  if (summary.program_kpi_file) {
    console.log(chalk.gray(`  Program KPI file: ${summary.program_kpi_file}`));
  }
  if (summary.program_audit_file) {
    console.log(chalk.gray(`  Program audit file: ${summary.program_audit_file}`));
  }
  if (summary.output_file) {
    console.log(chalk.gray(`  Output: ${summary.output_file}`));
  }
}

async function maybeWriteOutput(result, outCandidate, projectPath) {
  if (!outCandidate) {
    return;
  }

  const outputPath = path.isAbsolute(outCandidate)
    ? outCandidate
    : path.join(projectPath, outCandidate);
  await fs.ensureDir(path.dirname(outputPath));
  await fs.writeJson(outputPath, result, { spaces: 2 });
  result.output_file = outputPath;
}

async function maybeWriteTextOutput(result, content, outCandidate, projectPath) {
  if (!outCandidate) {
    return;
  }

  const outputPath = path.isAbsolute(outCandidate)
    ? outCandidate
    : path.join(projectPath, outCandidate);
  await fs.ensureDir(path.dirname(outputPath));
  await fs.writeFile(outputPath, content, 'utf8');
  result.output_file = outputPath;
}

function normalizeAutoHandoffManifestPath(projectPath, manifestCandidate) {
  const candidate = typeof manifestCandidate === 'string'
    ? manifestCandidate.trim()
    : '';
  if (!candidate) {
    throw new Error('handoff manifest path is required');
  }
  return path.isAbsolute(candidate)
    ? candidate
    : path.join(projectPath, candidate);
}

function toAutoHandoffCliPath(projectPath, absolutePath) {
  const relative = path.relative(projectPath, absolutePath);
  if (relative && !relative.startsWith('..') && !path.isAbsolute(relative)) {
    return relative.split(path.sep).join('/');
  }
  return absolutePath;
}

function quoteCliArg(value) {
  const raw = `${value || ''}`;
  if (raw.length === 0) {
    return '""';
  }
  if (!/[\s"'`]/.test(raw)) {
    return raw;
  }
  return `"${raw.replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"`;
}

function normalizeHandoffText(value) {
  if (typeof value === 'string') {
    const normalized = value.trim();
    return normalized.length > 0 ? normalized : null;
  }
  if (typeof value === 'number' && Number.isFinite(value)) {
    return `${value}`;
  }
  return null;
}

function readHandoffPathValue(input, keyPath) {
  if (!input || typeof input !== 'object') {
    return null;
  }
  const parts = String(keyPath || '')
    .split('.')
    .map(part => part.trim())
    .filter(Boolean);
  if (parts.length === 0) {
    return null;
  }
  let cursor = input;
  for (const part of parts) {
    if (!cursor || typeof cursor !== 'object' || !(part in cursor)) {
      return null;
    }
    cursor = cursor[part];
  }
  return cursor;
}

function readHandoffFirstPathValue(input, keyPaths = []) {
  const paths = Array.isArray(keyPaths) ? keyPaths : [];
  for (const keyPath of paths) {
    const value = readHandoffPathValue(input, keyPath);
    if (value !== null && value !== undefined) {
      return value;
    }
  }
  return null;
}

function normalizeHandoffNumber(value, options = {}) {
  if (value === null || value === undefined || value === '') {
    return null;
  }
  const candidate = Number(value);
  if (!Number.isFinite(candidate)) {
    return null;
  }
  const min = Number.isFinite(options.min) ? Number(options.min) : null;
  const max = Number.isFinite(options.max) ? Number(options.max) : null;
  if (min !== null && candidate < min) {
    return null;
  }
  if (max !== null && candidate > max) {
    return null;
  }
  if (options.integer === true) {
    return Math.trunc(candidate);
  }
  const precision = Number.isInteger(options.precision) && options.precision >= 0
    ? options.precision
    : null;
  if (precision === null) {
    return candidate;
  }
  return Number(candidate.toFixed(precision));
}

function normalizeHandoffOntologyCollection(rawCollection) {
  if (Array.isArray(rawCollection)) {
    return rawCollection.filter(item => item && typeof item === 'object' && !Array.isArray(item));
  }
  if (!rawCollection || typeof rawCollection !== 'object' || Array.isArray(rawCollection)) {
    return [];
  }

  const listCandidate = rawCollection.items || rawCollection.values || rawCollection.list || rawCollection.nodes;
  if (Array.isArray(listCandidate)) {
    return listCandidate.filter(item => item && typeof item === 'object' && !Array.isArray(item));
  }

  return Object.values(rawCollection)
    .filter(item => item && typeof item === 'object' && !Array.isArray(item));
}

function normalizeHandoffOntologyModel(payload) {
  const modelRoot = readHandoffFirstPathValue(payload, [
    'model',
    'ontology_model',
    'semantic_model',
    'ontology.model'
  ]) || payload || {};

  const entityItems = normalizeHandoffOntologyCollection(
    readHandoffFirstPathValue(modelRoot, ['entities', 'entity_model.entities', 'entity_relations.entities'])
  );
  const relationItems = normalizeHandoffOntologyCollection(
    readHandoffFirstPathValue(modelRoot, ['relations', 'entity_relations.relations', 'relation_model.relations'])
  );
  const ruleItems = normalizeHandoffOntologyCollection(
    readHandoffFirstPathValue(modelRoot, ['business_rules', 'rules', 'governance.business_rules'])
  );
  const decisionItems = normalizeHandoffOntologyCollection(
    readHandoffFirstPathValue(modelRoot, ['decision_logic', 'decisions', 'governance.decision_logic'])
  );

  const entities = entityItems.map(item => ({
    id: normalizeHandoffIdentifier(item, ['id', 'ref', 'name', 'entity', 'code']) || null,
    type: normalizeHandoffText(item.type) || null
  }));

  const relations = relationItems.map(item => ({
    source: normalizeHandoffIdentifier(item, ['source', 'from', 'src', 'left', 'parent']) || null,
    target: normalizeHandoffIdentifier(item, ['target', 'to', 'dst', 'right', 'child']) || null,
    type: normalizeHandoffText(item.type || item.relation || item.relation_type) || null
  }));

  const rules = ruleItems.map(item => {
    const statusText = normalizeHandoffText(item.status || item.state || item.result || item.verdict);
    const statusToken = statusText ? statusText.toLowerCase() : null;
    const mapped = item.mapped === true
      || item.bound === true
      || Boolean(
        normalizeHandoffIdentifier(item, [
          'entity',
          'entity_ref',
          'target_ref',
          'bind_to',
          'applies_to',
          'scope_ref'
        ])
      );
    const passed = item.passed === true
      || item.valid === true
      || item.success === true
      || (statusToken
        ? ['passed', 'active', 'implemented', 'enforced', 'success', 'ok', 'valid'].includes(statusToken)
        : false);

    return {
      id: normalizeHandoffIdentifier(item, ['id', 'rule_id', 'name', 'ref']) || null,
      mapped,
      passed
    };
  });

  const decisions = decisionItems.map(item => {
    const statusText = normalizeHandoffText(item.status || item.state || item.result || item.outcome);
    const statusToken = statusText ? statusText.toLowerCase() : null;
    const resolved = item.resolved === true
      || item.applied === true
      || item.decided === true
      || item.completed === true
      || (statusToken
        ? ['resolved', 'decided', 'implemented', 'completed', 'active', 'success'].includes(statusToken)
        : false);
    const automated = item.automated === true
      || item.tested === true
      || item.simulated === true;

    return {
      id: normalizeHandoffIdentifier(item, ['id', 'decision_id', 'name', 'ref']) || null,
      resolved,
      automated
    };
  });

  return {
    entities,
    relations,
    business_rules: rules,
    decision_logic: decisions
  };
}

function normalizeHandoffIdentifier(entry, fieldCandidates = []) {
  const directText = normalizeHandoffText(entry);
  if (directText) {
    return directText;
  }
  if (!entry || typeof entry !== 'object' || Array.isArray(entry)) {
    return null;
  }

  for (const field of fieldCandidates) {
    const value = readHandoffPathValue(entry, field);
    const normalized = normalizeHandoffText(value);
    if (normalized) {
      return normalized;
    }
  }

  return null;
}

function collectUniqueIdentifiers(rawEntries, fieldCandidates, label) {
  const warnings = [];
  if (rawEntries === undefined || rawEntries === null) {
    return { values: [], warnings };
  }
  if (!Array.isArray(rawEntries)) {
    return {
      values: [],
      warnings: [`${label} must be an array`]
    };
  }

  const values = [];
  const seen = new Set();
  rawEntries.forEach((entry, index) => {
    const normalized = normalizeHandoffIdentifier(entry, fieldCandidates);
    if (!normalized) {
      warnings.push(`${label}[${index}] is invalid and was ignored`);
      return;
    }
    if (seen.has(normalized)) {
      return;
    }
    seen.add(normalized);
    values.push(normalized);
  });

  return { values, warnings };
}

function normalizeHandoffDependencyEntry(entry) {
  return normalizeHandoffIdentifier(entry, [
    'name',
    'spec',
    'spec_name',
    'spec_id',
    'id',
    'spec.name',
    'spec.id'
  ]);
}

function normalizeHandoffDependencyList(entry) {
  if (!entry || typeof entry !== 'object' || Array.isArray(entry)) {
    return [];
  }
  const raw =
    readHandoffPathValue(entry, 'depends_on')
    || readHandoffPathValue(entry, 'dependsOn')
    || readHandoffPathValue(entry, 'dependencies')
    || readHandoffPathValue(entry, 'depends')
    || readHandoffPathValue(entry, 'requires')
    || null;
  if (!raw) {
    return [];
  }

  let candidates = [];
  if (Array.isArray(raw)) {
    candidates = raw;
  } else if (typeof raw === 'string') {
    candidates = raw
      .split(',')
      .map(item => item.trim())
      .filter(Boolean);
  } else {
    candidates = [raw];
  }

  const values = [];
  const seen = new Set();
  for (const item of candidates) {
    const normalized = normalizeHandoffDependencyEntry(item);
    if (!normalized || seen.has(normalized)) {
      continue;
    }
    seen.add(normalized);
    values.push(normalized);
  }
  return values;
}

function collectHandoffSpecDescriptors(rawEntries) {
  const warnings = [];
  if (rawEntries === undefined || rawEntries === null) {
    return {
      values: [],
      descriptors: [],
      warnings: ['specs must be an array']
    };
  }
  if (!Array.isArray(rawEntries)) {
    return {
      values: [],
      descriptors: [],
      warnings: ['specs must be an array']
    };
  }

  const values = [];
  const descriptors = [];
  const seen = new Set();
  const descriptorMap = new Map();

  rawEntries.forEach((entry, index) => {
    const name = normalizeHandoffIdentifier(entry, [
      'name',
      'spec',
      'spec_name',
      'spec_id',
      'id',
      'spec.name',
      'spec.id'
    ]);
    if (!name) {
      warnings.push(`specs[${index}] is invalid and was ignored`);
      return;
    }
    const dependsOn = normalizeHandoffDependencyList(entry);
    if (!seen.has(name)) {
      seen.add(name);
      values.push(name);
      const descriptor = {
        name,
        depends_on: dependsOn
      };
      descriptors.push(descriptor);
      descriptorMap.set(name, descriptor);
      return;
    }

    const existing = descriptorMap.get(name);
    const existingSet = new Set(existing.depends_on);
    for (const dep of dependsOn) {
      if (!existingSet.has(dep)) {
        existingSet.add(dep);
        existing.depends_on.push(dep);
      }
    }
  });

  const specSet = new Set(values);
  descriptors.forEach(item => {
    const filtered = [];
    const seenDeps = new Set();
    item.depends_on.forEach(dep => {
      if (dep === item.name) {
        warnings.push(`spec ${item.name} dependency "${dep}" ignored (self reference)`);
        return;
      }
      if (!specSet.has(dep)) {
        warnings.push(`spec ${item.name} dependency "${dep}" ignored (not found in specs list)`);
        return;
      }
      if (seenDeps.has(dep)) {
        return;
      }
      seenDeps.add(dep);
      filtered.push(dep);
    });
    item.depends_on = filtered;
  });

  return { values, descriptors, warnings };
}

function buildAutoHandoffDependencyBatches(specDescriptors = []) {
  const normalized = Array.isArray(specDescriptors)
    ? specDescriptors
      .filter(item => item && typeof item.name === 'string' && item.name.trim().length > 0)
      .map(item => ({
        name: item.name.trim(),
        depends_on: Array.isArray(item.depends_on)
          ? item.depends_on
            .map(dep => `${dep || ''}`.trim())
            .filter(Boolean)
          : []
      }))
    : [];
  const warnings = [];
  if (normalized.length === 0) {
    return {
      enabled: true,
      batch_count: 0,
      batches: [],
      warnings,
      cyclic: false
    };
  }

  const nodeMap = new Map();
  normalized.forEach(item => nodeMap.set(item.name, item));
  normalized.forEach(item => {
    item.depends_on = item.depends_on.filter(dep => nodeMap.has(dep) && dep !== item.name);
  });

  const remaining = new Set(normalized.map(item => item.name));
  const batches = [];
  let cyclic = false;
  while (remaining.size > 0) {
    const ready = [];
    for (const name of remaining) {
      const node = nodeMap.get(name);
      const blocked = node.depends_on.some(dep => remaining.has(dep));
      if (!blocked) {
        ready.push(name);
      }
    }

    if (ready.length === 0) {
      cyclic = true;
      const fallback = Array.from(remaining).sort();
      warnings.push('spec dependency cycle detected; fallback to one final merged batch');
      batches.push({
        index: batches.length + 1,
        specs: fallback
      });
      break;
    }

    ready.sort();
    batches.push({
      index: batches.length + 1,
      specs: ready
    });
    ready.forEach(name => remaining.delete(name));
  }

  return {
    enabled: true,
    batch_count: batches.length,
    batches,
    warnings,
    cyclic
  };
}

function collectKnownGaps(rawKnownGaps) {
  const warnings = [];
  if (rawKnownGaps === undefined || rawKnownGaps === null) {
    return { gaps: [], warnings };
  }
  if (!Array.isArray(rawKnownGaps)) {
    return {
      gaps: [],
      warnings: ['known_gaps must be an array']
    };
  }

  const gaps = [];
  rawKnownGaps.forEach((entry, index) => {
    const normalized = normalizeHandoffIdentifier(entry, [
      'gap',
      'title',
      'description',
      'message',
      'name',
      'id'
    ]);
    if (!normalized) {
      warnings.push(`known_gaps[${index}] is invalid and was ignored`);
      return;
    }
    gaps.push(normalized);
  });
  return { gaps, warnings };
}

function normalizeAutoHandoffManifest(payload = {}) {
  const validationErrors = [];
  const validationWarnings = [];

  if (!payload || typeof payload !== 'object' || Array.isArray(payload)) {
    throw new Error('handoff manifest must be a JSON object');
  }

  const sourceProject = normalizeHandoffText(payload.source_project);
  if (!sourceProject) {
    validationWarnings.push('source_project is missing');
  }

  const timestamp = normalizeHandoffText(payload.timestamp);
  if (!timestamp) {
    validationWarnings.push('timestamp is missing');
  }

  const specsCollected = collectHandoffSpecDescriptors(payload.specs);
  validationWarnings.push(...specsCollected.warnings);
  if (specsCollected.values.length === 0) {
    validationErrors.push('specs must include at least one valid spec identifier');
  }
  const dependencyBatches = buildAutoHandoffDependencyBatches(specsCollected.descriptors);
  validationWarnings.push(...dependencyBatches.warnings);

  const templatesCollected = collectUniqueIdentifiers(
    payload.templates,
    ['name', 'template', 'template_name', 'id', 'template.id', 'template.name'],
    'templates'
  );
  validationWarnings.push(...templatesCollected.warnings);
  if (templatesCollected.values.length === 0) {
    validationWarnings.push('templates is empty');
  }

  const capabilitiesCollected = collectUniqueIdentifiers(
    payload.capabilities,
    ['name', 'capability', 'capability_name', 'id', 'capability.id', 'capability.name'],
    'capabilities'
  );
  validationWarnings.push(...capabilitiesCollected.warnings);
  if (capabilitiesCollected.values.length === 0) {
    validationWarnings.push('capabilities is empty; capability coverage gate will be skipped unless capabilities are declared');
  }

  const knownGapCollected = collectKnownGaps(payload.known_gaps);
  validationWarnings.push(...knownGapCollected.warnings);

  const ontologyValidation = payload.ontology_validation && typeof payload.ontology_validation === 'object'
    ? payload.ontology_validation
    : null;
  if (!ontologyValidation) {
    validationWarnings.push('ontology_validation is missing');
  }

  const nextBatch = payload.next_batch && typeof payload.next_batch === 'object'
    ? payload.next_batch
    : null;

  return {
    source_project: sourceProject,
    timestamp,
    specs: specsCollected.values,
    spec_descriptors: specsCollected.descriptors,
    dependency_batches: dependencyBatches,
    templates: templatesCollected.values,
    capabilities: capabilitiesCollected.values,
    known_gaps: knownGapCollected.gaps,
    ontology_validation: ontologyValidation,
    next_batch: nextBatch,
    validation: {
      errors: validationErrors,
      warnings: validationWarnings
    }
  };
}

async function loadAutoHandoffManifest(projectPath, manifestCandidate) {
  const manifestPath = normalizeAutoHandoffManifestPath(projectPath, manifestCandidate);
  if (!await fs.pathExists(manifestPath)) {
    throw new Error(`handoff manifest not found: ${manifestPath}`);
  }

  let payload;
  try {
    payload = await fs.readJson(manifestPath);
  } catch (error) {
    throw new Error(`invalid handoff manifest JSON: ${manifestPath} (${error.message})`);
  }

  const normalized = normalizeAutoHandoffManifest(payload);
  return {
    manifest_path: manifestPath,
    manifest_file: toAutoHandoffCliPath(projectPath, manifestPath),
    ...normalized
  };
}

function buildAutoHandoffPhaseCommands(projectPath, manifestPath, specs = []) {
  const manifestCli = quoteCliArg(toAutoHandoffCliPath(projectPath, manifestPath));
  const phases = [];

  phases.push({
    id: 'precheck',
    title: 'Precheck',
    goal: 'Validate handoff manifest integrity and repository readiness',
    commands: [
      `kse auto handoff plan --manifest ${manifestCli} --json`,
      'kse auto governance stats --json'
    ]
  });

  const specCommands = [];
  for (const specName of specs) {
    const specArg = quoteCliArg(specName);
    const specPackagePath = quoteCliArg(`.kiro/specs/${specName}/custom`);
    specCommands.push(`kse auto spec status ${specArg} --json`);
    specCommands.push(`kse auto spec instructions ${specArg} --json`);
    specCommands.push(`kse scene package-validate --spec ${specArg} --spec-package custom/scene-package.json --strict --json`);
    specCommands.push(`kse scene ontology validate --package ${specPackagePath} --json`);
  }
  phases.push({
    id: 'spec-validation',
    title: 'Spec Validation',
    goal: 'Validate spec docs, tasks, scene package contract, and ontology consistency',
    commands: specCommands
  });

  const queueCli = quoteCliArg(AUTO_HANDOFF_DEFAULT_QUEUE_FILE);
  phases.push({
    id: 'execution',
    title: 'Autonomous Execution',
    goal: 'Generate queue goals and run autonomous close-loop batch integration',
    commands: [
      `kse auto handoff queue --manifest ${manifestCli} --out ${queueCli} --json`,
      `kse auto close-loop-batch ${queueCli} --format lines --json`
    ]
  });

  phases.push({
    id: 'observability',
    title: 'Observability and Governance',
    goal: 'Snapshot integration evidence and plan remaining governance actions',
    commands: [
      'kse auto observability snapshot --json',
      'kse auto governance maintain --session-keep 50 --batch-session-keep 50 --controller-session-keep 50 --json'
    ]
  });

  return phases;
}

async function buildAutoHandoffPlan(projectPath, options = {}) {
  const handoff = await loadAutoHandoffManifest(projectPath, options.manifest);
  const validationErrors = Array.isArray(handoff.validation.errors) ? handoff.validation.errors : [];
  const validationWarnings = Array.isArray(handoff.validation.warnings) ? handoff.validation.warnings : [];

  if (options.strict && validationErrors.length > 0) {
    throw new Error(`handoff plan validation failed: ${validationErrors.join('; ')}`);
  }
  if (options.strictWarnings && validationWarnings.length > 0) {
    throw new Error(`handoff plan validation warnings: ${validationWarnings.join('; ')}`);
  }

  const phases = buildAutoHandoffPhaseCommands(projectPath, handoff.manifest_path, handoff.specs);
  return {
    mode: 'auto-handoff-plan',
    generated_at: new Date().toISOString(),
    manifest_path: handoff.manifest_path,
    source_project: handoff.source_project,
    handoff: {
      timestamp: handoff.timestamp,
      spec_count: handoff.specs.length,
      template_count: handoff.templates.length,
      capability_count: Array.isArray(handoff.capabilities) ? handoff.capabilities.length : 0,
      known_gap_count: handoff.known_gaps.length,
      specs: handoff.specs,
      spec_descriptors: handoff.spec_descriptors,
      dependency_batches: handoff.dependency_batches,
      templates: handoff.templates,
      capabilities: handoff.capabilities,
      known_gaps: handoff.known_gaps,
      ontology_validation: handoff.ontology_validation,
      next_batch: handoff.next_batch
    },
    validation: {
      is_valid: validationErrors.length === 0,
      errors: validationErrors,
      warnings: validationWarnings
    },
    phases,
    recommendations: [
      `kse auto handoff queue --manifest ${quoteCliArg(handoff.manifest_file)} --out ${quoteCliArg(AUTO_HANDOFF_DEFAULT_QUEUE_FILE)} --json`,
      `kse auto close-loop-batch ${quoteCliArg(AUTO_HANDOFF_DEFAULT_QUEUE_FILE)} --format lines --json`
    ]
  };
}

function buildAutoHandoffQueueGoals(handoff, options = {}) {
  const includeKnownGaps = options.includeKnownGaps !== false;
  const goals = [];
  const seen = new Set();
  const pushGoal = value => {
    const normalized = normalizeHandoffText(value);
    if (!normalized || seen.has(normalized)) {
      return;
    }
    seen.add(normalized);
    goals.push(normalized);
  };

  for (const specName of handoff.specs) {
    pushGoal(`integrate handoff spec ${specName} with scene package validation, ontology consistency checks, and close-loop completion`);
  }

  for (const templateName of handoff.templates) {
    pushGoal(`validate handoff template ${templateName} for template registry compatibility and release readiness`);
  }

  if (includeKnownGaps) {
    for (const gap of handoff.known_gaps) {
      pushGoal(`remediate handoff known gap: ${gap}`);
    }
  }

  pushGoal('generate unified observability snapshot and governance follow-up recommendations for this handoff batch');
  return goals;
}

async function buildAutoHandoffQueue(projectPath, options = {}) {
  const handoff = await loadAutoHandoffManifest(projectPath, options.manifest);
  const validationErrors = Array.isArray(handoff.validation.errors) ? handoff.validation.errors : [];
  if (validationErrors.length > 0) {
    throw new Error(`handoff queue validation failed: ${validationErrors.join('; ')}`);
  }

  const includeKnownGaps = options.includeKnownGaps !== false;
  const goals = buildAutoHandoffQueueGoals(handoff, { includeKnownGaps });
  if (goals.length === 0) {
    throw new Error('handoff queue produced no goals');
  }

  return {
    mode: 'auto-handoff-queue',
    generated_at: new Date().toISOString(),
    manifest_path: handoff.manifest_path,
    dry_run: Boolean(options.dryRun),
    append: Boolean(options.append),
    include_known_gaps: includeKnownGaps,
    goal_count: goals.length,
    goals,
    validation: {
      errors: handoff.validation.errors,
      warnings: handoff.validation.warnings
    },
    recommendations: [
      `kse auto close-loop-batch ${quoteCliArg(options.out || AUTO_HANDOFF_DEFAULT_QUEUE_FILE)} --format lines --json`
    ]
  };
}

async function writeAutoHandoffQueueFile(projectPath, queueResult, options = {}) {
  const outCandidate = typeof options.out === 'string' && options.out.trim().length > 0
    ? options.out.trim()
    : AUTO_HANDOFF_DEFAULT_QUEUE_FILE;
  const outputPath = path.isAbsolute(outCandidate)
    ? outCandidate
    : path.join(projectPath, outCandidate);
  await fs.ensureDir(path.dirname(outputPath));

  const content = `${queueResult.goals.join('\n')}\n`;
  if (options.append && await fs.pathExists(outputPath)) {
    const existing = await fs.readFile(outputPath, 'utf8');
    const separator = existing.length > 0 && !existing.endsWith('\n') ? '\n' : '';
    await fs.appendFile(outputPath, `${separator}${content}`, 'utf8');
  } else {
    await fs.writeFile(outputPath, content, 'utf8');
  }

  queueResult.output_file = outputPath;
}

async function listDirectoryNamesIfExists(baseDir) {
  if (!await fs.pathExists(baseDir)) {
    return [];
  }
  const entries = await fs.readdir(baseDir);
  const names = [];
  for (const entry of entries) {
    const fullPath = path.join(baseDir, entry);
    try {
      const stats = await fs.stat(fullPath);
      if (stats.isDirectory()) {
        names.push(entry);
      }
    } catch (error) {
      // Ignore ephemeral or unreadable entries.
    }
  }
  return names;
}

function collectTemplateNamesFromPayload(payload, sink = new Set(), depth = 0) {
  if (depth > 6 || payload === null || payload === undefined) {
    return sink;
  }
  if (Array.isArray(payload)) {
    payload.forEach(item => collectTemplateNamesFromPayload(item, sink, depth + 1));
    return sink;
  }
  if (typeof payload !== 'object') {
    return sink;
  }

  const directName = normalizeHandoffIdentifier(payload, [
    'name',
    'template',
    'template_name',
    'template.id',
    'template.name'
  ]);
  if (directName) {
    sink.add(directName);
  }

  const candidateKeys = [
    'templates',
    'items',
    'entries',
    'packages',
    'registry',
    'values',
    'data'
  ];
  candidateKeys.forEach(key => {
    if (key in payload) {
      collectTemplateNamesFromPayload(payload[key], sink, depth + 1);
    }
  });

  return sink;
}

async function collectLocalTemplateNames(projectPath) {
  const names = new Set();
  const templateRoot = path.join(projectPath, '.kiro', 'templates');
  const exportRoot = path.join(templateRoot, 'exports');
  const sceneTemplateRoot = path.join(templateRoot, 'scene-packages');
  const registryFile = path.join(sceneTemplateRoot, 'registry.json');

  (await listDirectoryNamesIfExists(templateRoot))
    .filter(name => !['exports', 'scene-packages'].includes(name))
    .forEach(name => names.add(name));

  (await listDirectoryNamesIfExists(exportRoot)).forEach(name => names.add(name));
  (await listDirectoryNamesIfExists(sceneTemplateRoot))
    .filter(name => name !== 'archives')
    .forEach(name => names.add(name));

  if (await fs.pathExists(registryFile)) {
    try {
      const payload = await fs.readJson(registryFile);
      collectTemplateNamesFromPayload(payload, names);
    } catch (error) {
      // Ignore parse failures; template diff should still work with filesystem signals.
    }
  }

  return Array.from(names).sort((left, right) => left.localeCompare(right));
}

async function buildAutoHandoffTemplateDiff(projectPath, options = {}) {
  const handoff = options.handoff && typeof options.handoff === 'object'
    ? options.handoff
    : await loadAutoHandoffManifest(projectPath, options.manifest);
  const manifestTemplates = Array.isArray(handoff.templates)
    ? handoff.templates.map(item => `${item || ''}`.trim()).filter(Boolean)
    : [];
  const localTemplates = await collectLocalTemplateNames(projectPath);

  const manifestSet = new Set(manifestTemplates);
  const localSet = new Set(localTemplates);
  const missingInLocal = manifestTemplates.filter(item => !localSet.has(item));
  const extraInLocal = localTemplates.filter(item => !manifestSet.has(item));
  const matched = manifestTemplates.filter(item => localSet.has(item));
  const compatibility = missingInLocal.length === 0 ? 'ready' : 'needs-sync';

  return {
    mode: 'auto-handoff-template-diff',
    generated_at: new Date().toISOString(),
    manifest_path: handoff.manifest_path || null,
    manifest: {
      template_count: manifestTemplates.length,
      templates: manifestTemplates
    },
    local: {
      template_count: localTemplates.length,
      templates: localTemplates
    },
    diff: {
      matched,
      missing_in_local: missingInLocal,
      extra_in_local: extraInLocal
    },
    compatibility,
    recommendations: compatibility === 'ready'
      ? []
      : [
        'sync missing templates from handoff source into .kiro/templates/exports or scene-packages registry',
        're-run `kse auto handoff template-diff --manifest <path> --json` after sync'
      ]
  };
}

function buildAutoHandoffSpecGoalLookup(handoff, queueGoals = []) {
  const specs = Array.isArray(handoff && handoff.specs)
    ? handoff.specs.map(item => `${item || ''}`.trim()).filter(Boolean)
    : [];
  const goals = Array.isArray(queueGoals) ? queueGoals : [];
  const goalMap = new Map();
  const usedGoalIndexes = new Set();
  const warnings = [];

  specs.forEach(specName => {
    const prefix = `integrate handoff spec ${specName}`.toLowerCase();
    const goalIndex = goals.findIndex((goal, index) => {
      if (usedGoalIndexes.has(index)) {
        return false;
      }
      const normalizedGoal = `${goal || ''}`.trim().toLowerCase();
      return normalizedGoal.startsWith(prefix);
    });
    if (goalIndex < 0) {
      warnings.push(`spec goal not found in queue for ${specName}`);
      return;
    }
    usedGoalIndexes.add(goalIndex);
    goalMap.set(specName, goals[goalIndex]);
  });

  return {
    goal_map: goalMap,
    used_goal_indexes: usedGoalIndexes,
    warnings
  };
}

function buildAutoHandoffExecutionBatches(handoff, queueGoals = [], dependencyBatching = true) {
  const dependencyPlan = handoff && handoff.dependency_batches && handoff.dependency_batches.enabled
    ? handoff.dependency_batches
    : buildAutoHandoffDependencyBatches(Array.isArray(handoff && handoff.spec_descriptors) ? handoff.spec_descriptors : []);
  const lookup = buildAutoHandoffSpecGoalLookup(handoff, queueGoals);
  const queue = Array.isArray(queueGoals) ? queueGoals : [];
  const used = new Set(lookup.used_goal_indexes);
  const batches = [];

  if (dependencyBatching) {
    const sourceBatches = Array.isArray(dependencyPlan.batches) ? dependencyPlan.batches : [];
    sourceBatches.forEach(batch => {
      const specs = Array.isArray(batch && batch.specs) ? batch.specs : [];
      const goals = specs
        .map(spec => lookup.goal_map.get(spec))
        .filter(Boolean);
      if (goals.length === 0) {
        return;
      }
      batches.push({
        id: `spec-batch-${batch.index}`,
        type: 'spec',
        title: `Spec dependency batch ${batch.index}`,
        specs,
        goals
      });
    });
  } else {
    const allSpecGoals = Array.from(lookup.goal_map.values());
    if (allSpecGoals.length > 0) {
      batches.push({
        id: 'spec-batch-1',
        type: 'spec',
        title: 'Spec integration batch',
        specs: Array.from(lookup.goal_map.keys()),
        goals: allSpecGoals
      });
    }
  }

  const remainingGoals = queue.filter((goal, index) => !used.has(index));
  if (remainingGoals.length > 0) {
    batches.push({
      id: 'post-spec-batch',
      type: 'post-spec',
      title: 'Template, known-gap, and observability goals',
      specs: [],
      goals: remainingGoals
    });
  }

  if (batches.length === 0 && queue.length > 0) {
    batches.push({
      id: 'fallback-batch',
      type: 'fallback',
      title: 'Fallback full queue batch',
      specs: [],
      goals: queue
    });
  }

  return {
    dependency_batching: dependencyBatching,
    dependency_plan: dependencyPlan,
    batches,
    warnings: lookup.warnings
  };
}

function mergeAutoHandoffBatchSummaries(batchSummaries = [], mode = 'auto-handoff-run') {
  const summaries = Array.isArray(batchSummaries) ? batchSummaries.filter(Boolean) : [];
  if (summaries.length === 0) {
    return {
      mode,
      status: 'completed',
      goals_file: null,
      total_goals: 0,
      processed_goals: 0,
      completed_goals: 0,
      failed_goals: 0,
      batch_parallel: 0,
      resource_plan: null,
      batch_retry: {
        enabled: false,
        strategy: 'adaptive',
        until_complete: false,
        configured_rounds: 0,
        max_rounds: 0,
        performed_rounds: 0,
        exhausted: false,
        history: []
      },
      stopped_early: false,
      metrics: buildBatchMetrics([], 0),
      results: []
    };
  }

  const results = [];
  let aggregateResourcePlan = null;
  let batchParallel = 0;
  let stoppedEarly = false;
  let configuredRetryRounds = 0;
  let maxRetryRounds = 0;
  let performedRetryRounds = 0;
  let retryExhausted = false;
  let retryEnabled = false;
  let retryUntilComplete = false;
  const retryHistory = [];
  const retryStrategies = new Set();
  let totalGoals = 0;
  let processedGoals = 0;
  let completedGoals = 0;
  let failedGoals = 0;

  summaries.forEach(summary => {
    results.push(...(Array.isArray(summary.results) ? summary.results : []));
    totalGoals += Number(summary.total_goals) || 0;
    processedGoals += Number(summary.processed_goals) || 0;
    completedGoals += Number(summary.completed_goals) || 0;
    failedGoals += Number(summary.failed_goals) || 0;
    batchParallel = Math.max(batchParallel, Number(summary.batch_parallel) || 0);
    aggregateResourcePlan = mergeBatchResourcePlans(aggregateResourcePlan, summary.resource_plan);
    stoppedEarly = stoppedEarly || Boolean(summary.stopped_early);

    const retry = summary && summary.batch_retry ? summary.batch_retry : {};
    retryEnabled = retryEnabled || Boolean(retry.enabled);
    retryUntilComplete = retryUntilComplete || Boolean(retry.until_complete);
    retryExhausted = retryExhausted || Boolean(retry.exhausted);
    configuredRetryRounds += Number(retry.configured_rounds) || 0;
    maxRetryRounds += Number(retry.max_rounds) || 0;
    performedRetryRounds += Number(retry.performed_rounds) || 0;
    if (retry.strategy) {
      retryStrategies.add(retry.strategy);
    }
    const history = Array.isArray(retry.history) ? retry.history : [];
    retryHistory.push(...history);
  });

  const status = failedGoals === 0
    ? 'completed'
    : completedGoals === 0
      ? 'failed'
      : 'partial-failed';

  return {
    mode,
    status,
    goals_file: summaries[0].goals_file || null,
    resumed_from_summary: null,
    generated_from_goal: null,
    total_goals: totalGoals,
    processed_goals: processedGoals,
    completed_goals: completedGoals,
    failed_goals: failedGoals,
    batch_parallel: batchParallel,
    autonomous_policy: {
      enabled: true,
      source: 'handoff',
      continue_on_error: true,
      batch_parallel: batchParallel,
      batch_retry_rounds: configuredRetryRounds,
      batch_retry_until_complete: retryUntilComplete
    },
    resource_plan: aggregateResourcePlan,
    batch_retry: {
      enabled: retryEnabled,
      strategy: retryStrategies.size === 1 ? Array.from(retryStrategies)[0] : 'mixed',
      until_complete: retryUntilComplete,
      configured_rounds: configuredRetryRounds,
      max_rounds: maxRetryRounds,
      performed_rounds: performedRetryRounds,
      exhausted: retryExhausted,
      history: retryHistory
    },
    stopped_early: stoppedEarly,
    metrics: buildBatchMetrics(results, totalGoals),
    goal_input_guard: {
      enabled: false,
      max_duplicate_goals: null,
      duplicate_goals: 0,
      unique_goals: totalGoals,
      duplicate_examples: [],
      over_limit: false,
      hard_fail_triggered: false
    },
    results
  };
}

async function executeAutoHandoffExecutionBatches(projectPath, handoff, queue, options = {}) {
  const queueGoals = Array.isArray(queue && queue.goals) ? queue.goals : [];
  const executionPlan = buildAutoHandoffExecutionBatches(
    handoff,
    queueGoals,
    options.dependencyBatching !== false
  );
  const executionBatches = [];
  const summaries = [];

  for (const batch of executionPlan.batches) {
    const goals = Array.isArray(batch.goals) ? batch.goals : [];
    if (goals.length === 0) {
      continue;
    }
    const goalsResult = {
      file: queue && queue.output_file
        ? queue.output_file
        : path.join(projectPath, options.queueOut || AUTO_HANDOFF_DEFAULT_QUEUE_FILE),
      goals
    };
    const summary = await executeCloseLoopBatch(goalsResult, {
      continueOnError: options.continueOnError !== false,
      batchAutonomous: options.batchAutonomous !== false,
      batchParallel: options.batchParallel,
      batchAgentBudget: options.batchAgentBudget,
      batchRetryRounds: options.batchRetryRounds,
      batchRetryUntilComplete: options.batchRetryUntilComplete,
      batchRetryMaxRounds: options.batchRetryMaxRounds,
      batchSession: true
    }, projectPath, 'auto-handoff-run');
    summaries.push(summary);
    executionBatches.push({
      id: batch.id,
      type: batch.type,
      title: batch.title,
      specs: batch.specs,
      goal_count: goals.length,
      status: summary.status,
      failed_goals: summary.failed_goals
    });
  }

  return {
    summary: mergeAutoHandoffBatchSummaries(summaries, 'auto-handoff-run'),
    execution_batches: executionBatches,
    execution_plan: executionPlan
  };
}

function normalizeHandoffSessionQuery(sessionCandidate) {
  const normalized = typeof sessionCandidate === 'string'
    ? sessionCandidate.trim()
    : 'latest';
  return normalized || 'latest';
}

function normalizeHandoffRegressionWindow(windowCandidate) {
  if (windowCandidate === undefined || windowCandidate === null) {
    return 2;
  }
  const parsed = Number(windowCandidate);
  if (!Number.isInteger(parsed) || parsed < 2 || parsed > 50) {
    throw new Error('--window must be an integer between 2 and 50.');
  }
  return parsed;
}

function normalizeHandoffEvidenceWindow(windowCandidate) {
  if (windowCandidate === undefined || windowCandidate === null) {
    return 5;
  }
  const parsed = Number(windowCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 50) {
    throw new Error('--window must be an integer between 1 and 50.');
  }
  return parsed;
}

function normalizeHandoffGateHistoryKeep(keepCandidate) {
  if (keepCandidate === undefined || keepCandidate === null) {
    return 200;
  }
  const parsed = Number(keepCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 5000) {
    throw new Error('--keep must be an integer between 1 and 5000.');
  }
  return parsed;
}

function normalizeHandoffRegressionFormat(formatCandidate) {
  const normalized = typeof formatCandidate === 'string'
    ? formatCandidate.trim().toLowerCase()
    : 'json';
  if (!['json', 'markdown'].includes(normalized)) {
    throw new Error('--format must be one of: json, markdown.');
  }
  return normalized;
}

function normalizeHandoffContinueStrategy(strategyCandidate) {
  const normalized = typeof strategyCandidate === 'string'
    ? strategyCandidate.trim().toLowerCase()
    : 'auto';
  if (!['auto', 'pending', 'failed-only'].includes(normalized)) {
    throw new Error('--continue-strategy must be one of: auto, pending, failed-only.');
  }
  return normalized;
}

function resolveAutoHandoffContinueStrategy(requestedStrategy, summary = null) {
  const strategyRequested = normalizeHandoffContinueStrategy(requestedStrategy);
  if (strategyRequested !== 'auto') {
    return {
      strategy: strategyRequested,
      strategy_requested: strategyRequested,
      strategy_reason: 'explicit'
    };
  }

  const payload = summary && typeof summary === 'object' ? summary : {};
  const results = Array.isArray(payload.results) ? payload.results : [];
  const totalGoals = Number(payload.total_goals);
  const processedGoals = Number(payload.processed_goals);
  const hasUnprocessed = Number.isInteger(totalGoals) && Number.isInteger(processedGoals) && processedGoals < totalGoals;
  const hasPlannedLike = results.some(item => {
    const status = `${item && item.status ? item.status : ''}`.trim().toLowerCase();
    return ['unknown', 'stopped', 'planned', 'prepared'].includes(status);
  });
  const hasFailed = results.some(item => {
    const status = `${item && item.status ? item.status : ''}`.trim().toLowerCase();
    return ['failed', 'error'].includes(status);
  });

  if (hasUnprocessed || hasPlannedLike) {
    return {
      strategy: 'pending',
      strategy_requested: 'auto',
      strategy_reason: hasUnprocessed ? 'auto-detected-unprocessed' : 'auto-detected-planned'
    };
  }
  if (hasFailed) {
    return {
      strategy: 'failed-only',
      strategy_requested: 'auto',
      strategy_reason: 'auto-detected-failed-only'
    };
  }
  return {
    strategy: 'pending',
    strategy_requested: 'auto',
    strategy_reason: 'auto-default-pending'
  };
}

async function listAutoHandoffRunReports(projectPath) {
  const dirPath = path.join(projectPath, AUTO_HANDOFF_RUN_REPORT_DIR);
  if (!await fs.pathExists(dirPath)) {
    return [];
  }
  const entries = await fs.readdir(dirPath);
  const reports = [];
  for (const entry of entries) {
    if (!entry.toLowerCase().endsWith('.json')) {
      continue;
    }
    const filePath = path.join(dirPath, entry);
    let stats = null;
    try {
      stats = await fs.stat(filePath);
    } catch (error) {
      continue;
    }
    let payload = null;
    try {
      payload = await fs.readJson(filePath);
    } catch (error) {
      continue;
    }
    if (!payload || payload.mode !== 'auto-handoff-run') {
      continue;
    }
    const ts = Date.parse(
      payload.completed_at
      || payload.generated_at
      || payload.created_at
      || null
    );
    reports.push({
      file: filePath,
      session_id: payload.session_id || path.basename(entry, '.json'),
      payload,
      sort_ts: Number.isFinite(ts) ? ts : (stats ? stats.mtimeMs : 0)
    });
  }

  reports.sort((left, right) => right.sort_ts - left.sort_ts);
  return reports;
}

async function resolveAutoHandoffRunReportFile(projectPath, sessionCandidate, optionName = '--continue-from') {
  if (typeof sessionCandidate !== 'string' || !sessionCandidate.trim()) {
    throw new Error(`${optionName} requires a session id/file or "latest".`);
  }
  const normalizedCandidate = sessionCandidate.trim();
  if (normalizedCandidate.toLowerCase() === 'latest') {
    const reports = await listAutoHandoffRunReports(projectPath);
    if (reports.length === 0) {
      throw new Error(`No handoff run reports found in: ${path.join(projectPath, AUTO_HANDOFF_RUN_REPORT_DIR)}`);
    }
    return reports[0].file;
  }

  if (path.isAbsolute(normalizedCandidate)) {
    return normalizedCandidate;
  }
  if (
    normalizedCandidate.includes('/') ||
    normalizedCandidate.includes('\\') ||
    normalizedCandidate.toLowerCase().endsWith('.json')
  ) {
    return path.join(projectPath, normalizedCandidate);
  }

  const reports = await listAutoHandoffRunReports(projectPath);
  const bySessionId = reports.find(item => item.session_id === normalizedCandidate);
  if (bySessionId) {
    return bySessionId.file;
  }

  const bySessionFile = path.join(
    projectPath,
    AUTO_HANDOFF_RUN_REPORT_DIR,
    `${sanitizeBatchSessionId(normalizedCandidate)}.json`
  );
  if (await fs.pathExists(bySessionFile)) {
    return bySessionFile;
  }
  return path.join(projectPath, normalizedCandidate);
}

async function loadAutoHandoffRunSessionPayload(projectPath, sessionCandidate, optionName = '--continue-from') {
  const reportFile = await resolveAutoHandoffRunReportFile(projectPath, sessionCandidate, optionName);
  if (!(await fs.pathExists(reportFile))) {
    throw new Error(`Handoff run report file not found: ${reportFile}`);
  }

  let payload = null;
  try {
    payload = await fs.readJson(reportFile);
  } catch (error) {
    throw new Error(`Invalid handoff run report JSON: ${reportFile} (${error.message})`);
  }
  if (!payload || typeof payload !== 'object' || payload.mode !== 'auto-handoff-run') {
    throw new Error(`Invalid handoff run report payload: ${reportFile}`);
  }

  return {
    id: typeof payload.session_id === 'string' && payload.session_id.trim()
      ? payload.session_id.trim()
      : path.basename(reportFile, '.json'),
    file: reportFile,
    payload
  };
}

async function buildAutoHandoffQueueFromContinueSource(projectPath, plan, options = {}) {
  const resumedSession = await loadAutoHandoffRunSessionPayload(projectPath, options.continueFrom, '--continue-from');
  const previousManifestPath = typeof (resumedSession.payload && resumedSession.payload.manifest_path) === 'string' &&
    resumedSession.payload.manifest_path.trim()
    ? resumedSession.payload.manifest_path.trim()
    : null;
  if (previousManifestPath) {
    const resolvedPreviousManifest = path.resolve(projectPath, previousManifestPath);
    const resolvedCurrentManifest = path.resolve(plan.manifest_path);
    if (path.normalize(resolvedPreviousManifest) !== path.normalize(resolvedCurrentManifest)) {
      throw new Error(
        `--continue-from manifest mismatch: previous=${resolvedPreviousManifest} current=${resolvedCurrentManifest}.`
      );
    }
  }

  const previousSummary = resumedSession.payload && resumedSession.payload.batch_summary;
  if (!previousSummary || typeof previousSummary !== 'object') {
    throw new Error(`--continue-from report is missing batch_summary: ${resumedSession.file}`);
  }
  const continueStrategy = resolveAutoHandoffContinueStrategy(options.continueStrategy, previousSummary);
  const resumedGoals = await buildCloseLoopBatchGoalsFromSummaryPayload(
    previousSummary,
    resumedSession.file,
    projectPath,
    'lines',
    continueStrategy.strategy
  );

  return {
    mode: 'auto-handoff-queue',
    generated_at: new Date().toISOString(),
    manifest_path: plan.manifest_path,
    dry_run: Boolean(options.dryRun),
    append: Boolean(options.append),
    include_known_gaps: options.includeKnownGaps !== false,
    goal_count: resumedGoals.goals.length,
    goals: resumedGoals.goals,
    validation: {
      errors: [],
      warnings: []
    },
    resume_context: {
      previous_batch_summary: previousSummary
    },
    resumed_from: {
      session_id: resumedSession.id,
      file: resumedSession.file,
      strategy: continueStrategy.strategy,
      strategy_requested: continueStrategy.strategy_requested,
      strategy_reason: continueStrategy.strategy_reason,
      previous_status: resumedSession.payload.status || null,
      previous_total_goals: Number.isInteger(
        Number(resumedGoals.resumedFromSummary && resumedGoals.resumedFromSummary.previous_total_goals)
      )
        ? Number(resumedGoals.resumedFromSummary.previous_total_goals)
        : null,
      previous_processed_goals: Number.isInteger(
        Number(resumedGoals.resumedFromSummary && resumedGoals.resumedFromSummary.previous_processed_goals)
      )
        ? Number(resumedGoals.resumedFromSummary.previous_processed_goals)
        : null
    }
  };
}

function normalizeRiskRank(levelCandidate) {
  const level = `${levelCandidate || 'high'}`.trim().toLowerCase();
  if (level === 'low') {
    return 1;
  }
  if (level === 'medium') {
    return 2;
  }
  return 3;
}

function buildAutoHandoffRegressionSnapshot(report) {
  const payload = report && report.payload ? report.payload : report;
  const specStatus = payload && payload.spec_status ? payload.spec_status : {};
  const gates = payload && payload.gates ? payload.gates : {};
  const gateActual = gates && gates.actual ? gates.actual : {};
  const batchSummary = payload && payload.batch_summary ? payload.batch_summary : {};
  const ontology = payload && payload.ontology_validation ? payload.ontology_validation : {};
  const ontologyMetrics = ontology && ontology.metrics ? ontology.metrics : {};
  const scenePackageBatch = payload && payload.scene_package_batch ? payload.scene_package_batch : {};
  const scenePackageBatchSummary = scenePackageBatch && scenePackageBatch.summary
    ? scenePackageBatch.summary
    : {};

  const riskLevel = gateActual.risk_level
    || (payload && payload.observability_snapshot && payload.observability_snapshot.highlights
      ? payload.observability_snapshot.highlights.governance_risk_level
      : 'high');
  const successRate = Number(specStatus.success_rate_percent);
  const failedGoals = Number(batchSummary.failed_goals);
  const elapsedMs = Number(payload && payload.elapsed_ms);
  const ontologyQualityScore = Number(
    gateActual.ontology_quality_score !== undefined
      ? gateActual.ontology_quality_score
      : ontology.quality_score
  );
  const ontologyUnmappedRules = Number(
    gateActual.ontology_business_rule_unmapped !== undefined
      ? gateActual.ontology_business_rule_unmapped
      : ontologyMetrics.business_rule_unmapped
  );
  const ontologyUndecidedDecisions = Number(
    gateActual.ontology_decision_undecided !== undefined
      ? gateActual.ontology_decision_undecided
      : ontologyMetrics.decision_undecided
  );
  const businessRulePassRate = Number(
    gateActual.ontology_business_rule_pass_rate_percent !== undefined
      ? gateActual.ontology_business_rule_pass_rate_percent
      : ontologyMetrics.business_rule_pass_rate_percent
  );
  const decisionResolvedRate = Number(
    gateActual.ontology_decision_resolved_rate_percent !== undefined
      ? gateActual.ontology_decision_resolved_rate_percent
      : ontologyMetrics.decision_resolved_rate_percent
  );
  const sceneBatchFailureCount = Number(
    scenePackageBatchSummary.batch_gate_failure_count !== undefined
      ? scenePackageBatchSummary.batch_gate_failure_count
      : scenePackageBatchSummary.failed
  );
  const sceneBatchStatus = normalizeHandoffText(
    scenePackageBatch.status !== undefined
      ? scenePackageBatch.status
      : gateActual.scene_package_batch_status
  );
  let sceneBatchPassed = null;
  if (sceneBatchStatus && sceneBatchStatus !== 'skipped') {
    sceneBatchPassed = sceneBatchStatus === 'passed';
  }
  if (gateActual.scene_package_batch_passed === true) {
    sceneBatchPassed = true;
  } else if (gateActual.scene_package_batch_passed === false) {
    sceneBatchPassed = false;
  }

  return {
    session_id: payload && payload.session_id ? payload.session_id : null,
    status: payload && payload.status ? payload.status : null,
    spec_success_rate_percent: Number.isFinite(successRate) ? successRate : null,
    risk_level: `${riskLevel || 'high'}`.trim().toLowerCase(),
    risk_level_rank: normalizeRiskRank(riskLevel),
    failed_goals: Number.isFinite(failedGoals) ? failedGoals : null,
    elapsed_ms: Number.isFinite(elapsedMs) ? elapsedMs : null,
    ontology_quality_score: Number.isFinite(ontologyQualityScore) ? ontologyQualityScore : null,
    ontology_unmapped_rules: Number.isFinite(ontologyUnmappedRules) ? ontologyUnmappedRules : null,
    ontology_undecided_decisions: Number.isFinite(ontologyUndecidedDecisions) ? ontologyUndecidedDecisions : null,
    ontology_business_rule_pass_rate_percent: Number.isFinite(businessRulePassRate) ? businessRulePassRate : null,
    ontology_decision_resolved_rate_percent: Number.isFinite(decisionResolvedRate) ? decisionResolvedRate : null,
    scene_package_batch_status: sceneBatchStatus || null,
    scene_package_batch_passed: typeof sceneBatchPassed === 'boolean' ? sceneBatchPassed : null,
    scene_package_batch_failure_count: Number.isFinite(sceneBatchFailureCount) ? sceneBatchFailureCount : null,
    generated_at: payload && payload.generated_at ? payload.generated_at : null
  };
}

function buildAutoHandoffRegressionComparison(currentSnapshot, previousSnapshot) {
  const deltaSuccess = (
    Number.isFinite(currentSnapshot.spec_success_rate_percent) &&
    Number.isFinite(previousSnapshot.spec_success_rate_percent)
  )
    ? Number((currentSnapshot.spec_success_rate_percent - previousSnapshot.spec_success_rate_percent).toFixed(2))
    : null;
  const deltaRiskRank = (
    Number.isFinite(currentSnapshot.risk_level_rank) &&
    Number.isFinite(previousSnapshot.risk_level_rank)
  )
    ? currentSnapshot.risk_level_rank - previousSnapshot.risk_level_rank
    : null;
  const deltaFailedGoals = (
    Number.isFinite(currentSnapshot.failed_goals) &&
    Number.isFinite(previousSnapshot.failed_goals)
  )
    ? currentSnapshot.failed_goals - previousSnapshot.failed_goals
    : null;
  const deltaElapsedMs = (
    Number.isFinite(currentSnapshot.elapsed_ms) &&
    Number.isFinite(previousSnapshot.elapsed_ms)
  )
    ? currentSnapshot.elapsed_ms - previousSnapshot.elapsed_ms
    : null;
  const deltaOntologyQualityScore = (
    Number.isFinite(currentSnapshot.ontology_quality_score) &&
    Number.isFinite(previousSnapshot.ontology_quality_score)
  )
    ? Number((currentSnapshot.ontology_quality_score - previousSnapshot.ontology_quality_score).toFixed(2))
    : null;
  const deltaOntologyUnmappedRules = (
    Number.isFinite(currentSnapshot.ontology_unmapped_rules) &&
    Number.isFinite(previousSnapshot.ontology_unmapped_rules)
  )
    ? currentSnapshot.ontology_unmapped_rules - previousSnapshot.ontology_unmapped_rules
    : null;
  const deltaOntologyUndecidedDecisions = (
    Number.isFinite(currentSnapshot.ontology_undecided_decisions) &&
    Number.isFinite(previousSnapshot.ontology_undecided_decisions)
  )
    ? currentSnapshot.ontology_undecided_decisions - previousSnapshot.ontology_undecided_decisions
    : null;
  const deltaBusinessRulePassRate = (
    Number.isFinite(currentSnapshot.ontology_business_rule_pass_rate_percent) &&
    Number.isFinite(previousSnapshot.ontology_business_rule_pass_rate_percent)
  )
    ? Number((
      currentSnapshot.ontology_business_rule_pass_rate_percent -
      previousSnapshot.ontology_business_rule_pass_rate_percent
    ).toFixed(2))
    : null;
  const deltaDecisionResolvedRate = (
    Number.isFinite(currentSnapshot.ontology_decision_resolved_rate_percent) &&
    Number.isFinite(previousSnapshot.ontology_decision_resolved_rate_percent)
  )
    ? Number((
      currentSnapshot.ontology_decision_resolved_rate_percent -
      previousSnapshot.ontology_decision_resolved_rate_percent
    ).toFixed(2))
    : null;
  const deltaSceneBatchFailureCount = (
    Number.isFinite(currentSnapshot.scene_package_batch_failure_count) &&
    Number.isFinite(previousSnapshot.scene_package_batch_failure_count)
  )
    ? currentSnapshot.scene_package_batch_failure_count - previousSnapshot.scene_package_batch_failure_count
    : null;

  let trend = 'stable';
  if (
    (Number.isFinite(deltaSuccess) && deltaSuccess > 0) &&
    (deltaRiskRank === null || deltaRiskRank <= 0) &&
    (deltaFailedGoals === null || deltaFailedGoals <= 0) &&
    (deltaOntologyQualityScore === null || deltaOntologyQualityScore >= 0) &&
    (deltaOntologyUnmappedRules === null || deltaOntologyUnmappedRules <= 0) &&
    (deltaOntologyUndecidedDecisions === null || deltaOntologyUndecidedDecisions <= 0) &&
    (deltaSceneBatchFailureCount === null || deltaSceneBatchFailureCount <= 0)
  ) {
    trend = 'improved';
  } else if (
    (Number.isFinite(deltaSuccess) && deltaSuccess < 0) ||
    (deltaRiskRank !== null && deltaRiskRank > 0) ||
    (deltaFailedGoals !== null && deltaFailedGoals > 0) ||
    (deltaOntologyQualityScore !== null && deltaOntologyQualityScore < 0) ||
    (deltaOntologyUnmappedRules !== null && deltaOntologyUnmappedRules > 0) ||
    (deltaOntologyUndecidedDecisions !== null && deltaOntologyUndecidedDecisions > 0) ||
    (deltaSceneBatchFailureCount !== null && deltaSceneBatchFailureCount > 0)
  ) {
    trend = 'degraded';
  }

  return {
    trend,
    delta: {
      spec_success_rate_percent: deltaSuccess,
      risk_level_rank: deltaRiskRank,
      failed_goals: deltaFailedGoals,
      elapsed_ms: deltaElapsedMs,
      ontology_quality_score: deltaOntologyQualityScore,
      ontology_unmapped_rules: deltaOntologyUnmappedRules,
      ontology_undecided_decisions: deltaOntologyUndecidedDecisions,
      ontology_business_rule_pass_rate_percent: deltaBusinessRulePassRate,
      ontology_decision_resolved_rate_percent: deltaDecisionResolvedRate,
      scene_package_batch_failure_count: deltaSceneBatchFailureCount
    }
  };
}

function buildAutoHandoffRegressionWindowTrend(series = []) {
  const normalized = Array.isArray(series) ? series.filter(Boolean) : [];
  if (normalized.length < 2) {
    return {
      trend: 'baseline',
      delta: {
        spec_success_rate_percent: null,
        risk_level_rank: null,
        failed_goals: null,
        elapsed_ms: null,
        ontology_quality_score: null,
        ontology_unmapped_rules: null,
        ontology_undecided_decisions: null,
        ontology_business_rule_pass_rate_percent: null,
        ontology_decision_resolved_rate_percent: null,
        scene_package_batch_failure_count: null
      },
      has_baseline: false
    };
  }
  const latest = normalized[0];
  const oldest = normalized[normalized.length - 1];
  const comparison = buildAutoHandoffRegressionComparison(latest, oldest);
  return {
    trend: comparison.trend,
    delta: comparison.delta,
    has_baseline: true
  };
}

function buildAutoHandoffRegressionAggregates(series = []) {
  const snapshots = Array.isArray(series) ? series.filter(Boolean) : [];
  const successRates = snapshots
    .map(item => Number(item.spec_success_rate_percent))
    .filter(value => Number.isFinite(value));
  const failedGoals = snapshots
    .map(item => Number(item.failed_goals))
    .filter(value => Number.isFinite(value));
  const ontologyScores = snapshots
    .map(item => Number(item.ontology_quality_score))
    .filter(value => Number.isFinite(value));
  const ontologyUnmappedRules = snapshots
    .map(item => Number(item.ontology_unmapped_rules))
    .filter(value => Number.isFinite(value));
  const ontologyUndecidedDecisions = snapshots
    .map(item => Number(item.ontology_undecided_decisions))
    .filter(value => Number.isFinite(value));
  const rulePassRates = snapshots
    .map(item => Number(item.ontology_business_rule_pass_rate_percent))
    .filter(value => Number.isFinite(value));
  const decisionResolvedRates = snapshots
    .map(item => Number(item.ontology_decision_resolved_rate_percent))
    .filter(value => Number.isFinite(value));
  const sceneBatchFailures = snapshots
    .map(item => Number(item.scene_package_batch_failure_count))
    .filter(value => Number.isFinite(value));
  const sceneBatchApplicables = snapshots.filter(item => typeof item.scene_package_batch_passed === 'boolean');
  const sceneBatchPassedCount = sceneBatchApplicables.filter(item => item.scene_package_batch_passed === true).length;
  const sceneBatchFailedCount = sceneBatchApplicables.filter(item => item.scene_package_batch_passed === false).length;
  const riskLevels = {
    low: 0,
    medium: 0,
    high: 0,
    unknown: 0
  };
  snapshots.forEach(item => {
    const risk = `${item && item.risk_level ? item.risk_level : 'unknown'}`.trim().toLowerCase();
    if (Object.prototype.hasOwnProperty.call(riskLevels, risk)) {
      riskLevels[risk] += 1;
    } else {
      riskLevels.unknown += 1;
    }
  });

  const averageSuccessRate = successRates.length > 0
    ? Number((successRates.reduce((sum, value) => sum + value, 0) / successRates.length).toFixed(2))
    : null;
  const averageFailedGoals = failedGoals.length > 0
    ? Number((failedGoals.reduce((sum, value) => sum + value, 0) / failedGoals.length).toFixed(2))
    : null;
  const averageOntologyScore = ontologyScores.length > 0
    ? Number((ontologyScores.reduce((sum, value) => sum + value, 0) / ontologyScores.length).toFixed(2))
    : null;
  const averageOntologyUnmappedRules = ontologyUnmappedRules.length > 0
    ? Number((ontologyUnmappedRules.reduce((sum, value) => sum + value, 0) / ontologyUnmappedRules.length).toFixed(2))
    : null;
  const averageOntologyUndecidedDecisions = ontologyUndecidedDecisions.length > 0
    ? Number((ontologyUndecidedDecisions.reduce((sum, value) => sum + value, 0) / ontologyUndecidedDecisions.length).toFixed(2))
    : null;
  const averageRulePassRate = rulePassRates.length > 0
    ? Number((rulePassRates.reduce((sum, value) => sum + value, 0) / rulePassRates.length).toFixed(2))
    : null;
  const averageDecisionResolvedRate = decisionResolvedRates.length > 0
    ? Number((decisionResolvedRates.reduce((sum, value) => sum + value, 0) / decisionResolvedRates.length).toFixed(2))
    : null;
  const averageSceneBatchFailures = sceneBatchFailures.length > 0
    ? Number((sceneBatchFailures.reduce((sum, value) => sum + value, 0) / sceneBatchFailures.length).toFixed(2))
    : null;
  const sceneBatchPassRate = sceneBatchApplicables.length > 0
    ? Number(((sceneBatchPassedCount / sceneBatchApplicables.length) * 100).toFixed(2))
    : null;

  return {
    avg_spec_success_rate_percent: averageSuccessRate,
    min_spec_success_rate_percent: successRates.length > 0 ? Math.min(...successRates) : null,
    max_spec_success_rate_percent: successRates.length > 0 ? Math.max(...successRates) : null,
    avg_failed_goals: averageFailedGoals,
    avg_ontology_quality_score: averageOntologyScore,
    min_ontology_quality_score: ontologyScores.length > 0 ? Math.min(...ontologyScores) : null,
    max_ontology_quality_score: ontologyScores.length > 0 ? Math.max(...ontologyScores) : null,
    avg_ontology_unmapped_rules: averageOntologyUnmappedRules,
    max_ontology_unmapped_rules: ontologyUnmappedRules.length > 0 ? Math.max(...ontologyUnmappedRules) : null,
    avg_ontology_undecided_decisions: averageOntologyUndecidedDecisions,
    max_ontology_undecided_decisions: ontologyUndecidedDecisions.length > 0 ? Math.max(...ontologyUndecidedDecisions) : null,
    avg_ontology_business_rule_pass_rate_percent: averageRulePassRate,
    avg_ontology_decision_resolved_rate_percent: averageDecisionResolvedRate,
    scene_package_batch_applicable_count: sceneBatchApplicables.length,
    scene_package_batch_passed_count: sceneBatchPassedCount,
    scene_package_batch_failed_count: sceneBatchFailedCount,
    scene_package_batch_pass_rate_percent: sceneBatchPassRate,
    avg_scene_package_batch_failure_count: averageSceneBatchFailures,
    max_scene_package_batch_failure_count: sceneBatchFailures.length > 0 ? Math.max(...sceneBatchFailures) : null,
    risk_levels: riskLevels
  };
}

function buildAutoHandoffRegressionRiskLayers(series = []) {
  const snapshots = Array.isArray(series) ? series.filter(Boolean) : [];
  const levels = ['low', 'medium', 'high', 'unknown'];
  const result = {};

  levels.forEach(level => {
    const scoped = snapshots.filter(item => {
      const risk = `${item && item.risk_level ? item.risk_level : 'unknown'}`.trim().toLowerCase();
      return risk === level;
    });
    const successRates = scoped
      .map(item => Number(item.spec_success_rate_percent))
      .filter(value => Number.isFinite(value));
    const failedGoals = scoped
      .map(item => Number(item.failed_goals))
      .filter(value => Number.isFinite(value));
    const ontologyScores = scoped
      .map(item => Number(item.ontology_quality_score))
      .filter(value => Number.isFinite(value));
    const sceneBatchFailures = scoped
      .map(item => Number(item.scene_package_batch_failure_count))
      .filter(value => Number.isFinite(value));
    const sceneBatchApplicable = scoped.filter(item => typeof item.scene_package_batch_passed === 'boolean');
    const sceneBatchPassed = sceneBatchApplicable.filter(item => item.scene_package_batch_passed === true).length;

    const avg = values => (
      values.length > 0
        ? Number((values.reduce((sum, value) => sum + value, 0) / values.length).toFixed(2))
        : null
    );

    result[level] = {
      count: scoped.length,
      sessions: scoped.map(item => item.session_id).filter(Boolean),
      avg_spec_success_rate_percent: avg(successRates),
      max_spec_success_rate_percent: successRates.length > 0 ? Math.max(...successRates) : null,
      min_spec_success_rate_percent: successRates.length > 0 ? Math.min(...successRates) : null,
      avg_failed_goals: avg(failedGoals),
      avg_ontology_quality_score: avg(ontologyScores),
      avg_scene_package_batch_failure_count: avg(sceneBatchFailures),
      scene_package_batch_pass_rate_percent: sceneBatchApplicable.length > 0
        ? Number(((sceneBatchPassed / sceneBatchApplicable.length) * 100).toFixed(2))
        : null
    };
  });

  return result;
}

function buildAutoHandoffRegressionRecommendations(payload = {}) {
  const recommendations = [];
  const seen = new Set();
  const push = value => {
    const text = `${value || ''}`.trim();
    if (!text || seen.has(text)) {
      return;
    }
    seen.add(text);
    recommendations.push(text);
  };

  const current = payload.current || {};
  const trend = `${payload.trend || 'stable'}`.trim().toLowerCase();
  const windowTrend = payload.window_trend && payload.window_trend.trend
    ? `${payload.window_trend.trend}`.trim().toLowerCase()
    : trend;
  const currentFailed = Number(current.failed_goals);
  const currentRisk = `${current.risk_level || 'unknown'}`.trim().toLowerCase();
  const ontologyQuality = Number(current.ontology_quality_score);
  const ontologyUnmappedRules = Number(current.ontology_unmapped_rules);
  const ontologyUndecidedDecisions = Number(current.ontology_undecided_decisions);
  const sceneBatchFailureCount = Number(current.scene_package_batch_failure_count);
  const sceneBatchPassed = current.scene_package_batch_passed;

  if (trend === 'degraded' || windowTrend === 'degraded') {
    push(
      `kse auto handoff run --manifest <path> --continue-from ${quoteCliArg(current.session_id || 'latest')} ` +
      '--continue-strategy pending --json'
    );
  } else if (Number.isFinite(currentFailed) && currentFailed > 0) {
    push(
      `kse auto handoff run --manifest <path> --continue-from ${quoteCliArg(current.session_id || 'latest')} ` +
      '--continue-strategy failed-only --json'
    );
  }

  if (currentRisk === 'high') {
    push('kse auto governance stats --days 14 --json');
  }

  if (Number.isFinite(ontologyQuality) && ontologyQuality < 80) {
    push('Strengthen ontology quality gate before next run: `--min-ontology-score 80`.');
  }
  if (Number.isFinite(ontologyUnmappedRules) && ontologyUnmappedRules > 0) {
    push('Drive business-rule closure to zero unmapped rules (`--max-unmapped-rules 0`).');
  }
  if (Number.isFinite(ontologyUndecidedDecisions) && ontologyUndecidedDecisions > 0) {
    push('Resolve pending decision logic entries (`--max-undecided-decisions 0`).');
  }
  if (sceneBatchPassed === false || (Number.isFinite(sceneBatchFailureCount) && sceneBatchFailureCount > 0)) {
    push(
      'Resolve scene package publish-batch gate failures and rerun: ' +
      '`kse scene package-publish-batch --manifest docs/handoffs/handoff-manifest.json --dry-run --json`.'
    );
  }

  if ((payload.window && Number(payload.window.actual) > 0) && (payload.window.requested !== payload.window.actual)) {
    push('Increase regression coverage with `kse auto handoff regression --window 10 --json`.');
  }

  return recommendations;
}

function formatAutoHandoffRegressionValue(value, fallback = 'n/a') {
  if (value === null || value === undefined) {
    return fallback;
  }
  if (typeof value === 'number' && !Number.isFinite(value)) {
    return fallback;
  }
  return `${value}`;
}

function renderAutoHandoffRegressionAsciiBar(value, max = 100, width = 20) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed)) {
    return `${'.'.repeat(width)} n/a`;
  }
  const bounded = Math.max(0, Math.min(max, parsed));
  const ratio = max > 0 ? bounded / max : 0;
  const filled = Math.max(0, Math.min(width, Math.round(ratio * width)));
  return `${'#'.repeat(filled)}${'.'.repeat(Math.max(0, width - filled))} ${Number(bounded.toFixed(2))}`;
}

function renderAutoHandoffRegressionMarkdown(payload = {}) {
  const current = payload.current || {};
  const previous = payload.previous || null;
  const window = payload.window || { requested: 2, actual: 0 };
  const delta = payload.delta || {};
  const windowTrend = payload.window_trend || { trend: 'baseline', delta: {} };
  const aggregates = payload.aggregates || {};
  const riskLevels = aggregates.risk_levels || {};
  const recommendations = Array.isArray(payload.recommendations) ? payload.recommendations : [];
  const series = Array.isArray(payload.series) ? payload.series : [];
  const riskLayers = payload.risk_layers && typeof payload.risk_layers === 'object'
    ? payload.risk_layers
    : {};
  const trendSeriesLines = series.length > 0
    ? series.map(item => {
      const sessionId = formatAutoHandoffRegressionValue(item.session_id);
      const generatedAt = formatAutoHandoffRegressionValue(item.generated_at);
      const riskLevel = formatAutoHandoffRegressionValue(item.risk_level);
      const failedGoals = formatAutoHandoffRegressionValue(item.failed_goals);
      const sceneBatch = item.scene_package_batch_passed === null || item.scene_package_batch_passed === undefined
        ? 'n/a'
        : (item.scene_package_batch_passed ? 'pass' : 'fail');
      const successBar = renderAutoHandoffRegressionAsciiBar(item.spec_success_rate_percent, 100, 20);
      const ontologyBar = renderAutoHandoffRegressionAsciiBar(item.ontology_quality_score, 100, 20);
      return `- ${sessionId} | ${generatedAt} | risk=${riskLevel} | failed=${failedGoals} | scene-batch=${sceneBatch} | success=${successBar} | ontology=${ontologyBar}`;
    })
    : ['- None'];
  const riskLayerLines = ['low', 'medium', 'high', 'unknown'].map(level => {
    const scoped = riskLayers[level] && typeof riskLayers[level] === 'object'
      ? riskLayers[level]
      : {};
    return (
      `- ${level}: count=${formatAutoHandoffRegressionValue(scoped.count, '0')}, ` +
      `avg_success=${formatAutoHandoffRegressionValue(scoped.avg_spec_success_rate_percent)}, ` +
      `avg_failed_goals=${formatAutoHandoffRegressionValue(scoped.avg_failed_goals)}, ` +
      `avg_ontology_quality=${formatAutoHandoffRegressionValue(scoped.avg_ontology_quality_score)}, ` +
      `scene_batch_pass_rate=${formatAutoHandoffRegressionValue(scoped.scene_package_batch_pass_rate_percent)}%`
    );
  });

  const lines = [
    '# Auto Handoff Regression Report',
    '',
    `- Session: ${formatAutoHandoffRegressionValue(current.session_id)}`,
    `- Compared to: ${previous ? formatAutoHandoffRegressionValue(previous.session_id) : 'none'}`,
    `- Trend: ${formatAutoHandoffRegressionValue(payload.trend)}`,
    `- Window: ${formatAutoHandoffRegressionValue(window.actual)}/${formatAutoHandoffRegressionValue(window.requested)}`,
    '',
    '## Point Delta',
    '',
    `- Spec success rate delta: ${formatAutoHandoffRegressionValue(delta.spec_success_rate_percent)}`,
    `- Risk level rank delta: ${formatAutoHandoffRegressionValue(delta.risk_level_rank)}`,
    `- Failed goals delta: ${formatAutoHandoffRegressionValue(delta.failed_goals)}`,
    `- Elapsed ms delta: ${formatAutoHandoffRegressionValue(delta.elapsed_ms)}`,
    `- Ontology quality delta: ${formatAutoHandoffRegressionValue(delta.ontology_quality_score)}`,
    `- Ontology unmapped rules delta: ${formatAutoHandoffRegressionValue(delta.ontology_unmapped_rules)}`,
    `- Ontology undecided decisions delta: ${formatAutoHandoffRegressionValue(delta.ontology_undecided_decisions)}`,
    `- Scene package batch failure count delta: ${formatAutoHandoffRegressionValue(delta.scene_package_batch_failure_count)}`,
    '',
    '## Window Trend',
    '',
    `- Trend: ${formatAutoHandoffRegressionValue(windowTrend.trend)}`,
    `- Success rate delta: ${formatAutoHandoffRegressionValue(windowTrend.delta && windowTrend.delta.spec_success_rate_percent)}`,
    `- Risk level rank delta: ${formatAutoHandoffRegressionValue(windowTrend.delta && windowTrend.delta.risk_level_rank)}`,
    `- Failed goals delta: ${formatAutoHandoffRegressionValue(windowTrend.delta && windowTrend.delta.failed_goals)}`,
    '',
    '## Aggregates',
    '',
    `- Avg spec success rate: ${formatAutoHandoffRegressionValue(aggregates.avg_spec_success_rate_percent)}`,
    `- Min spec success rate: ${formatAutoHandoffRegressionValue(aggregates.min_spec_success_rate_percent)}`,
    `- Max spec success rate: ${formatAutoHandoffRegressionValue(aggregates.max_spec_success_rate_percent)}`,
    `- Avg failed goals: ${formatAutoHandoffRegressionValue(aggregates.avg_failed_goals)}`,
    `- Avg ontology quality score: ${formatAutoHandoffRegressionValue(aggregates.avg_ontology_quality_score)}`,
    `- Min ontology quality score: ${formatAutoHandoffRegressionValue(aggregates.min_ontology_quality_score)}`,
    `- Max ontology quality score: ${formatAutoHandoffRegressionValue(aggregates.max_ontology_quality_score)}`,
    `- Avg ontology unmapped rules: ${formatAutoHandoffRegressionValue(aggregates.avg_ontology_unmapped_rules)}`,
    `- Max ontology unmapped rules: ${formatAutoHandoffRegressionValue(aggregates.max_ontology_unmapped_rules)}`,
    `- Avg ontology undecided decisions: ${formatAutoHandoffRegressionValue(aggregates.avg_ontology_undecided_decisions)}`,
    `- Max ontology undecided decisions: ${formatAutoHandoffRegressionValue(aggregates.max_ontology_undecided_decisions)}`,
    `- Avg business rule pass rate: ${formatAutoHandoffRegressionValue(aggregates.avg_ontology_business_rule_pass_rate_percent)}`,
    `- Avg decision resolved rate: ${formatAutoHandoffRegressionValue(aggregates.avg_ontology_decision_resolved_rate_percent)}`,
    `- Scene package batch pass rate: ${formatAutoHandoffRegressionValue(aggregates.scene_package_batch_pass_rate_percent)}%`,
    `- Scene package batch failed sessions: ${formatAutoHandoffRegressionValue(aggregates.scene_package_batch_failed_count, '0')}`,
    `- Avg scene package batch failure count: ${formatAutoHandoffRegressionValue(aggregates.avg_scene_package_batch_failure_count)}`,
    `- Risk levels: low=${formatAutoHandoffRegressionValue(riskLevels.low, '0')}, medium=${formatAutoHandoffRegressionValue(riskLevels.medium, '0')}, high=${formatAutoHandoffRegressionValue(riskLevels.high, '0')}, unknown=${formatAutoHandoffRegressionValue(riskLevels.unknown, '0')}`,
    '',
    '## Trend Series',
    '',
    ...trendSeriesLines,
    '',
    '## Risk Layer View',
    '',
    ...riskLayerLines,
    '',
    '## Recommendations'
  ];

  if (recommendations.length === 0) {
    lines.push('', '- None');
  } else {
    recommendations.forEach(item => {
      lines.push('', `- ${item}`);
    });
  }

  return `${lines.join('\n')}\n`;
}

function resolveAutoHandoffReleaseEvidenceFile(projectPath, fileCandidate) {
  const candidate = typeof fileCandidate === 'string' && fileCandidate.trim()
    ? fileCandidate.trim()
    : AUTO_HANDOFF_RELEASE_EVIDENCE_FILE;
  return path.isAbsolute(candidate)
    ? candidate
    : path.join(projectPath, candidate);
}

function resolveAutoHandoffReleaseEvidenceDir(projectPath, dirCandidate = null) {
  const candidate = typeof dirCandidate === 'string' && dirCandidate.trim()
    ? dirCandidate.trim()
    : AUTO_HANDOFF_RELEASE_EVIDENCE_DIR;
  return path.isAbsolute(candidate)
    ? candidate
    : path.join(projectPath, candidate);
}

function resolveAutoHandoffReleaseGateHistoryFile(projectPath, fileCandidate = null) {
  const candidate = typeof fileCandidate === 'string' && fileCandidate.trim()
    ? fileCandidate.trim()
    : AUTO_HANDOFF_RELEASE_GATE_HISTORY_FILE;
  return path.isAbsolute(candidate)
    ? candidate
    : path.join(projectPath, candidate);
}

function parseAutoHandoffReleaseGateTag(filenameCandidate) {
  const filename = typeof filenameCandidate === 'string'
    ? filenameCandidate.trim()
    : '';
  if (!filename) {
    return null;
  }
  const match = /^release-gate-(.+)\.json$/i.exec(filename);
  if (!match || !match[1]) {
    return null;
  }
  const tag = `${match[1]}`.trim();
  if (!tag || /^history(?:-|$)/i.test(tag)) {
    return null;
  }
  return tag;
}

function parseAutoHandoffGateBoolean(value, fallback = null) {
  if (typeof value === 'boolean') {
    return value;
  }
  if (typeof value === 'number') {
    if (value === 1) return true;
    if (value === 0) return false;
  }
  if (typeof value === 'string') {
    const normalized = value.trim().toLowerCase();
    if (['true', '1', 'yes', 'y', 'on'].includes(normalized)) {
      return true;
    }
    if (['false', '0', 'no', 'n', 'off'].includes(normalized)) {
      return false;
    }
  }
  return fallback;
}

function parseAutoHandoffGateNumber(value) {
  const parsed = Number(value);
  return Number.isFinite(parsed) ? parsed : null;
}

function normalizeAutoHandoffGateRiskLevel(levelCandidate) {
  const normalized = typeof levelCandidate === 'string'
    ? levelCandidate.trim().toLowerCase()
    : '';
  if (['low', 'medium', 'high', 'unknown'].includes(normalized)) {
    return normalized;
  }
  return 'unknown';
}

function parseAutoHandoffGateSignalsMap(signals = []) {
  const map = {};
  if (!Array.isArray(signals)) {
    return map;
  }
  signals.forEach(item => {
    if (typeof item !== 'string') {
      return;
    }
    const trimmed = item.trim();
    if (!trimmed) {
      return;
    }
    const separatorIndex = trimmed.indexOf('=');
    if (separatorIndex <= 0) {
      return;
    }
    const key = trimmed.slice(0, separatorIndex).trim();
    const value = trimmed.slice(separatorIndex + 1).trim();
    if (!key) {
      return;
    }
    map[key] = value;
  });
  return map;
}

function toAutoHandoffTimestamp(valueCandidate) {
  const value = normalizeHandoffText(valueCandidate);
  const parsed = Date.parse(value || '');
  return Number.isFinite(parsed) ? parsed : 0;
}

function buildAutoHandoffReleaseGateHistoryEntry(entry = {}, options = {}) {
  const projectPath = options.projectPath || process.cwd();
  const sourceFile = typeof options.file === 'string' && options.file.trim()
    ? options.file.trim()
    : null;
  const signalMap = parseAutoHandoffGateSignalsMap(entry.signals);
  const derivedTag = normalizeHandoffText(options.tag)
    || (sourceFile ? parseAutoHandoffReleaseGateTag(path.basename(sourceFile)) : null)
    || normalizeHandoffText(entry.tag);
  const gatePassed = parseAutoHandoffGateBoolean(
    entry.gate_passed !== undefined ? entry.gate_passed : signalMap.gate_passed,
    null
  );
  const riskLevel = normalizeAutoHandoffGateRiskLevel(
    normalizeHandoffText(entry.risk_level) || signalMap.risk_level
  );
  const specSuccessRate = parseAutoHandoffGateNumber(
    entry.spec_success_rate_percent !== undefined
      ? entry.spec_success_rate_percent
      : signalMap.spec_success_rate
  );
  const sceneBatchStatus = normalizeHandoffText(
    entry.scene_package_batch_status !== undefined
      ? entry.scene_package_batch_status
      : signalMap.scene_package_batch_status
  );
  let sceneBatchPassed = parseAutoHandoffGateBoolean(
    entry.scene_package_batch_passed !== undefined
      ? entry.scene_package_batch_passed
      : signalMap.scene_package_batch_passed,
    null
  );
  if (sceneBatchPassed === null && sceneBatchStatus && sceneBatchStatus !== 'skipped') {
    sceneBatchPassed = sceneBatchStatus === 'passed';
  }
  const sceneBatchFailureCount = parseAutoHandoffGateNumber(
    entry.scene_package_batch_failure_count !== undefined
      ? entry.scene_package_batch_failure_count
      : signalMap.scene_package_batch_failure_count
  );
  const violations = Array.isArray(entry.violations)
    ? entry.violations.map(item => `${item}`)
    : [];
  const configWarnings = Array.isArray(entry.config_warnings)
    ? entry.config_warnings.map(item => `${item}`)
    : [];
  const signals = Array.isArray(entry.signals)
    ? entry.signals.map(item => `${item}`)
    : [];
  const thresholds = entry.thresholds && typeof entry.thresholds === 'object' && !Array.isArray(entry.thresholds)
    ? { ...entry.thresholds }
    : {};
  const evaluatedAt = normalizeHandoffText(
    entry.evaluated_at || entry.generated_at || entry.updated_at
  );
  const mode = normalizeHandoffText(entry.mode);
  const enforce = parseAutoHandoffGateBoolean(entry.enforce, false);
  const evidenceUsed = parseAutoHandoffGateBoolean(entry.evidence_used, false);
  const requireEvidence = parseAutoHandoffGateBoolean(entry.require_evidence, false);
  const requireGatePass = parseAutoHandoffGateBoolean(entry.require_gate_pass, true);
  const summaryFile = normalizeHandoffText(entry.summary_file);
  const portableFile = sourceFile
    ? toPortablePath(projectPath, sourceFile)
    : normalizeHandoffText(entry.file);
  const violationsCount = Number.isInteger(entry.violations_count)
    ? entry.violations_count
    : violations.length;
  const configWarningCount = Number.isInteger(entry.config_warning_count)
    ? entry.config_warning_count
    : configWarnings.length;

  return {
    tag: derivedTag,
    evaluated_at: evaluatedAt,
    gate_passed: gatePassed,
    mode,
    enforce,
    evidence_used: evidenceUsed,
    require_evidence: requireEvidence,
    require_gate_pass: requireGatePass,
    risk_level: riskLevel,
    spec_success_rate_percent: specSuccessRate,
    scene_package_batch_status: sceneBatchStatus || null,
    scene_package_batch_passed: typeof sceneBatchPassed === 'boolean' ? sceneBatchPassed : null,
    scene_package_batch_failure_count: Number.isFinite(sceneBatchFailureCount) ? sceneBatchFailureCount : null,
    violations_count: Math.max(0, Number(violationsCount) || 0),
    config_warning_count: Math.max(0, Number(configWarningCount) || 0),
    thresholds,
    summary_file: summaryFile,
    file: portableFile,
    signals,
    violations,
    config_warnings: configWarnings
  };
}

async function loadAutoHandoffReleaseGateReports(projectPath, dirCandidate = null) {
  const dirPath = resolveAutoHandoffReleaseEvidenceDir(projectPath, dirCandidate);
  const warnings = [];
  if (!(await fs.pathExists(dirPath))) {
    return {
      dir: dirPath,
      report_files: [],
      entries: [],
      warnings
    };
  }

  const names = await fs.readdir(dirPath);
  const reportFiles = names
    .filter(name => {
      if (typeof name !== 'string') {
        return false;
      }
      const lowered = name.trim().toLowerCase();
      if (!lowered.startsWith('release-gate-') || !lowered.endsWith('.json')) {
        return false;
      }
      if (lowered === 'release-gate-history.json') {
        return false;
      }
      if (lowered.startsWith('release-gate-history-')) {
        return false;
      }
      return parseAutoHandoffReleaseGateTag(name) !== null;
    })
    .map(name => path.join(dirPath, name));

  const entries = [];
  for (const reportFile of reportFiles) {
    let payload = null;
    try {
      payload = await fs.readJson(reportFile);
    } catch (error) {
      warnings.push(`skip invalid release gate report: ${reportFile} (${error.message})`);
      continue;
    }
    if (!payload || typeof payload !== 'object' || Array.isArray(payload)) {
      warnings.push(`skip invalid release gate payload: ${reportFile}`);
      continue;
    }
    entries.push(buildAutoHandoffReleaseGateHistoryEntry(payload, {
      projectPath,
      file: reportFile,
      tag: parseAutoHandoffReleaseGateTag(path.basename(reportFile))
    }));
  }

  return {
    dir: dirPath,
    report_files: reportFiles,
    entries,
    warnings
  };
}

async function loadAutoHandoffReleaseGateHistorySeed(projectPath, fileCandidate = null) {
  const filePath = resolveAutoHandoffReleaseGateHistoryFile(projectPath, fileCandidate);
  if (!(await fs.pathExists(filePath))) {
    return {
      file: filePath,
      entries: [],
      warnings: []
    };
  }

  let payload = null;
  try {
    payload = await fs.readJson(filePath);
  } catch (error) {
    return {
      file: filePath,
      entries: [],
      warnings: [`skip invalid gate history file: ${filePath} (${error.message})`]
    };
  }
  const list = Array.isArray(payload && payload.entries) ? payload.entries : [];
  const entries = list
    .filter(item => item && typeof item === 'object' && !Array.isArray(item))
    .map(item => buildAutoHandoffReleaseGateHistoryEntry(item, { projectPath }));
  return {
    file: filePath,
    entries,
    warnings: []
  };
}

function mergeAutoHandoffReleaseGateHistoryEntries(entries = []) {
  const merged = new Map();
  entries.forEach((entry, index) => {
    if (!entry || typeof entry !== 'object') {
      return;
    }
    const key = normalizeHandoffText(entry.tag)
      || normalizeHandoffText(entry.file)
      || `entry-${index}`;
    const previous = merged.get(key);
    if (!previous) {
      merged.set(key, entry);
      return;
    }
    const prevTs = toAutoHandoffTimestamp(previous.evaluated_at);
    const nextTs = toAutoHandoffTimestamp(entry.evaluated_at);
    if (nextTs >= prevTs) {
      merged.set(key, entry);
    }
  });
  return Array.from(merged.values());
}

function buildAutoHandoffReleaseGateHistoryAggregates(entries = []) {
  const riskCounts = {
    low: 0,
    medium: 0,
    high: 0,
    unknown: 0
  };
  const specRates = [];
  let gatePassedCount = 0;
  let gateFailedCount = 0;
  let gateUnknownCount = 0;
  let evidenceUsedCount = 0;
  let enforceCount = 0;
  let advisoryCount = 0;
  let violationsTotal = 0;
  let configWarningsTotal = 0;
  const sceneBatchFailureCounts = [];
  let sceneBatchApplicableCount = 0;
  let sceneBatchPassedCount = 0;
  let sceneBatchFailedCount = 0;

  entries.forEach(entry => {
    const gatePassed = parseAutoHandoffGateBoolean(entry && entry.gate_passed, null);
    if (gatePassed === true) {
      gatePassedCount += 1;
    } else if (gatePassed === false) {
      gateFailedCount += 1;
    } else {
      gateUnknownCount += 1;
    }

    const evidenceUsed = parseAutoHandoffGateBoolean(entry && entry.evidence_used, false);
    if (evidenceUsed) {
      evidenceUsedCount += 1;
    }

    const enforce = parseAutoHandoffGateBoolean(entry && entry.enforce, false);
    if (enforce) {
      enforceCount += 1;
    } else {
      advisoryCount += 1;
    }

    const riskLevel = normalizeAutoHandoffGateRiskLevel(entry && entry.risk_level);
    riskCounts[riskLevel] += 1;

    const specRate = parseAutoHandoffGateNumber(entry && entry.spec_success_rate_percent);
    if (Number.isFinite(specRate)) {
      specRates.push(specRate);
    }
    const sceneBatchPassed = parseAutoHandoffGateBoolean(entry && entry.scene_package_batch_passed, null);
    if (sceneBatchPassed === true) {
      sceneBatchApplicableCount += 1;
      sceneBatchPassedCount += 1;
    } else if (sceneBatchPassed === false) {
      sceneBatchApplicableCount += 1;
      sceneBatchFailedCount += 1;
    }
    const sceneBatchFailureCount = parseAutoHandoffGateNumber(
      entry && entry.scene_package_batch_failure_count
    );
    if (Number.isFinite(sceneBatchFailureCount)) {
      sceneBatchFailureCounts.push(sceneBatchFailureCount);
    }

    violationsTotal += Math.max(0, Number(entry && entry.violations_count) || 0);
    configWarningsTotal += Math.max(0, Number(entry && entry.config_warning_count) || 0);
  });

  const evaluatedGateCount = gatePassedCount + gateFailedCount;
  const passRate = evaluatedGateCount > 0
    ? Number(((gatePassedCount / evaluatedGateCount) * 100).toFixed(2))
    : null;
  const averageSpecRate = specRates.length > 0
    ? Number((specRates.reduce((sum, value) => sum + value, 0) / specRates.length).toFixed(2))
    : null;
  const minSpecRate = specRates.length > 0
    ? Number(Math.min(...specRates).toFixed(2))
    : null;
  const maxSpecRate = specRates.length > 0
    ? Number(Math.max(...specRates).toFixed(2))
    : null;
  const sceneBatchPassRate = sceneBatchApplicableCount > 0
    ? Number(((sceneBatchPassedCount / sceneBatchApplicableCount) * 100).toFixed(2))
    : null;
  const avgSceneBatchFailureCount = sceneBatchFailureCounts.length > 0
    ? Number((sceneBatchFailureCounts.reduce((sum, value) => sum + value, 0) / sceneBatchFailureCounts.length).toFixed(2))
    : null;
  const maxSceneBatchFailureCount = sceneBatchFailureCounts.length > 0
    ? Number(Math.max(...sceneBatchFailureCounts).toFixed(2))
    : null;

  return {
    gate_passed_count: gatePassedCount,
    gate_failed_count: gateFailedCount,
    gate_unknown_count: gateUnknownCount,
    pass_rate_percent: passRate,
    evidence_used_count: evidenceUsedCount,
    enforce_count: enforceCount,
    advisory_count: advisoryCount,
    violations_total: violationsTotal,
    config_warnings_total: configWarningsTotal,
    avg_spec_success_rate_percent: averageSpecRate,
    min_spec_success_rate_percent: minSpecRate,
    max_spec_success_rate_percent: maxSpecRate,
    scene_package_batch_applicable_count: sceneBatchApplicableCount,
    scene_package_batch_passed_count: sceneBatchPassedCount,
    scene_package_batch_failed_count: sceneBatchFailedCount,
    scene_package_batch_pass_rate_percent: sceneBatchPassRate,
    avg_scene_package_batch_failure_count: avgSceneBatchFailureCount,
    max_scene_package_batch_failure_count: maxSceneBatchFailureCount,
    risk_levels: riskCounts
  };
}

async function buildAutoHandoffReleaseGateHistoryIndex(projectPath, options = {}) {
  const keep = normalizeHandoffGateHistoryKeep(options.keep);
  const outFile = resolveAutoHandoffReleaseGateHistoryFile(projectPath, options.out);
  const historySeedFile = typeof options.historyFile === 'string' && options.historyFile.trim()
    ? resolveAutoHandoffReleaseGateHistoryFile(projectPath, options.historyFile)
    : outFile;
  const reportResult = await loadAutoHandoffReleaseGateReports(projectPath, options.dir);
  const historySeed = await loadAutoHandoffReleaseGateHistorySeed(projectPath, historySeedFile);
  const mergedEntries = mergeAutoHandoffReleaseGateHistoryEntries([
    ...reportResult.entries,
    ...historySeed.entries
  ]);

  if (mergedEntries.length === 0) {
    throw new Error(`no release gate reports found: ${reportResult.dir}`);
  }

  mergedEntries.sort((left, right) => {
    const leftTs = toAutoHandoffTimestamp(left && left.evaluated_at);
    const rightTs = toAutoHandoffTimestamp(right && right.evaluated_at);
    if (rightTs !== leftTs) {
      return rightTs - leftTs;
    }
    const leftTag = normalizeHandoffText(left && left.tag) || '';
    const rightTag = normalizeHandoffText(right && right.tag) || '';
    return rightTag.localeCompare(leftTag);
  });

  const entries = mergedEntries.slice(0, keep);
  const latestEntry = entries[0] || null;
  const warnings = [...reportResult.warnings, ...historySeed.warnings];
  const payload = {
    mode: 'auto-handoff-release-gate-history',
    generated_at: new Date().toISOString(),
    source_dir: reportResult.dir,
    report_file_count: reportResult.report_files.length,
    report_entry_count: reportResult.entries.length,
    seed_file: historySeed.file,
    seed_entry_count: historySeed.entries.length,
    keep,
    total_entries: entries.length,
    latest: latestEntry
      ? {
        tag: latestEntry.tag,
        evaluated_at: latestEntry.evaluated_at,
        gate_passed: latestEntry.gate_passed,
        risk_level: latestEntry.risk_level,
        scene_package_batch_passed: latestEntry.scene_package_batch_passed,
        scene_package_batch_failure_count: latestEntry.scene_package_batch_failure_count
      }
      : null,
    aggregates: buildAutoHandoffReleaseGateHistoryAggregates(entries),
    warnings,
    warnings_count: warnings.length,
    entries
  };
  return payload;
}

function renderAutoHandoffReleaseGateHistoryMarkdown(payload = {}) {
  const entries = Array.isArray(payload.entries) ? payload.entries : [];
  const aggregates = payload.aggregates && typeof payload.aggregates === 'object'
    ? payload.aggregates
    : {};
  const latest = payload.latest && typeof payload.latest === 'object'
    ? payload.latest
    : null;
  const warnings = Array.isArray(payload.warnings) ? payload.warnings : [];
  const recentEntries = entries.slice(0, 10);

  const lines = [
    '# Auto Handoff Release Gate History',
    '',
    `- Generated at: ${formatAutoHandoffRegressionValue(payload.generated_at)}`,
    `- Source dir: ${formatAutoHandoffRegressionValue(payload.source_dir)}`,
    `- Total entries: ${formatAutoHandoffRegressionValue(payload.total_entries, '0')}`,
    `- Keep: ${formatAutoHandoffRegressionValue(payload.keep, '0')}`,
    ''
  ];

  if (latest) {
    lines.push('## Latest');
    lines.push('');
    lines.push(`- Tag: ${formatAutoHandoffRegressionValue(latest.tag)}`);
    lines.push(`- Evaluated at: ${formatAutoHandoffRegressionValue(latest.evaluated_at)}`);
    lines.push(`- Gate passed: ${latest.gate_passed === true ? 'yes' : (latest.gate_passed === false ? 'no' : 'n/a')}`);
    lines.push(`- Risk level: ${formatAutoHandoffRegressionValue(latest.risk_level)}`);
    lines.push(`- Scene package batch: ${latest.scene_package_batch_passed === true ? 'pass' : (latest.scene_package_batch_passed === false ? 'fail' : 'n/a')}`);
    lines.push(`- Scene package batch failures: ${formatAutoHandoffRegressionValue(latest.scene_package_batch_failure_count)}`);
    lines.push('');
  }

  lines.push('## Aggregates');
  lines.push('');
  lines.push(`- Gate pass rate: ${formatAutoHandoffRegressionValue(aggregates.pass_rate_percent)}%`);
  lines.push(`- Passed: ${formatAutoHandoffRegressionValue(aggregates.gate_passed_count, '0')}`);
  lines.push(`- Failed: ${formatAutoHandoffRegressionValue(aggregates.gate_failed_count, '0')}`);
  lines.push(`- Unknown: ${formatAutoHandoffRegressionValue(aggregates.gate_unknown_count, '0')}`);
  lines.push(`- Evidence used: ${formatAutoHandoffRegressionValue(aggregates.evidence_used_count, '0')}`);
  lines.push(`- Enforce mode runs: ${formatAutoHandoffRegressionValue(aggregates.enforce_count, '0')}`);
  lines.push(`- Advisory mode runs: ${formatAutoHandoffRegressionValue(aggregates.advisory_count, '0')}`);
  lines.push(`- Avg spec success rate: ${formatAutoHandoffRegressionValue(aggregates.avg_spec_success_rate_percent)}`);
  lines.push(`- Scene package batch pass rate: ${formatAutoHandoffRegressionValue(aggregates.scene_package_batch_pass_rate_percent)}%`);
  lines.push(`- Scene package batch failed: ${formatAutoHandoffRegressionValue(aggregates.scene_package_batch_failed_count, '0')}`);
  lines.push(`- Avg scene package batch failures: ${formatAutoHandoffRegressionValue(aggregates.avg_scene_package_batch_failure_count)}`);
  lines.push(`- Risk levels: low=${formatAutoHandoffRegressionValue(aggregates.risk_levels && aggregates.risk_levels.low, '0')}, medium=${formatAutoHandoffRegressionValue(aggregates.risk_levels && aggregates.risk_levels.medium, '0')}, high=${formatAutoHandoffRegressionValue(aggregates.risk_levels && aggregates.risk_levels.high, '0')}, unknown=${formatAutoHandoffRegressionValue(aggregates.risk_levels && aggregates.risk_levels.unknown, '0')}`);
  lines.push('');
  lines.push('## Recent Entries');
  lines.push('');

  if (recentEntries.length === 0) {
    lines.push('- None');
  } else {
    recentEntries.forEach(entry => {
      const tag = formatAutoHandoffRegressionValue(entry && entry.tag);
      const passed = entry && entry.gate_passed === true ? 'yes' : (entry && entry.gate_passed === false ? 'no' : 'n/a');
      const risk = formatAutoHandoffRegressionValue(entry && entry.risk_level);
      const successRate = formatAutoHandoffRegressionValue(entry && entry.spec_success_rate_percent);
      const evaluatedAt = formatAutoHandoffRegressionValue(entry && entry.evaluated_at);
      const violations = formatAutoHandoffRegressionValue(entry && entry.violations_count, '0');
      const sceneBatch = entry && entry.scene_package_batch_passed === true
        ? 'pass'
        : (entry && entry.scene_package_batch_passed === false ? 'fail' : 'n/a');
      const sceneBatchFailures = formatAutoHandoffRegressionValue(
        entry && entry.scene_package_batch_failure_count
      );
      lines.push(
        `- ${tag} | passed=${passed} | risk=${risk} | scene-batch=${sceneBatch} | ` +
        `scene-failures=${sceneBatchFailures} | success=${successRate} | violations=${violations} | at=${evaluatedAt}`
      );
    });
  }

  if (warnings.length > 0) {
    lines.push('');
    lines.push('## Warnings');
    warnings.forEach(item => {
      lines.push('', `- ${item}`);
    });
  }

  return `${lines.join('\n')}\n`;
}

async function loadAutoHandoffReleaseEvidence(projectPath, fileCandidate = null) {
  const filePath = resolveAutoHandoffReleaseEvidenceFile(projectPath, fileCandidate);
  if (!(await fs.pathExists(filePath))) {
    throw new Error(`release evidence file not found: ${filePath}`);
  }

  let payload = null;
  try {
    payload = await fs.readJson(filePath);
  } catch (error) {
    throw new Error(`invalid release evidence JSON: ${filePath} (${error.message})`);
  }
  if (!payload || typeof payload !== 'object') {
    throw new Error(`invalid release evidence payload: ${filePath}`);
  }

  const sessions = Array.isArray(payload.sessions)
    ? payload.sessions.filter(item => item && typeof item === 'object')
    : [];
  sessions.sort((left, right) => {
    const leftTs = Date.parse(
      left && (left.merged_at || left.generated_at || left.updated_at)
        ? (left.merged_at || left.generated_at || left.updated_at)
        : 0
    );
    const rightTs = Date.parse(
      right && (right.merged_at || right.generated_at || right.updated_at)
        ? (right.merged_at || right.generated_at || right.updated_at)
        : 0
    );
    return (Number.isFinite(rightTs) ? rightTs : 0) - (Number.isFinite(leftTs) ? leftTs : 0);
  });

  return {
    file: filePath,
    payload,
    sessions
  };
}

function buildAutoHandoffEvidenceSnapshot(entry = {}) {
  const toNumber = value => {
    const parsed = Number(value);
    return Number.isFinite(parsed) ? parsed : null;
  };
  const gate = entry && typeof entry.gate === 'object' ? entry.gate : {};
  const gateActual = gate && typeof gate.actual === 'object' ? gate.actual : {};
  const ontology = entry && typeof entry.ontology_validation === 'object'
    ? entry.ontology_validation
    : {};
  const ontologyMetrics = ontology && typeof ontology.metrics === 'object'
    ? ontology.metrics
    : {};
  const scenePackageBatch = entry && typeof entry.scene_package_batch === 'object'
    ? entry.scene_package_batch
    : {};
  const scenePackageBatchSummary = scenePackageBatch && typeof scenePackageBatch.summary === 'object'
    ? scenePackageBatch.summary
    : {};
  const sceneBatchStatus = normalizeHandoffText(scenePackageBatch.status);
  const sceneBatchPassed = sceneBatchStatus
    ? (sceneBatchStatus === 'skipped' ? null : sceneBatchStatus === 'passed')
    : null;
  const riskLevel = normalizeHandoffText(
    gateActual.risk_level
      || (entry && entry.regression ? entry.regression.risk_level : null)
      || 'high'
  ) || 'high';

  return {
    session_id: normalizeHandoffText(entry.session_id),
    status: normalizeHandoffText(entry.status),
    merged_at: normalizeHandoffText(entry.merged_at),
    manifest_path: normalizeHandoffText(entry.manifest_path),
    gate_passed: gate.passed === true,
    spec_success_rate_percent: toNumber(gateActual.spec_success_rate_percent),
    risk_level: `${riskLevel}`.trim().toLowerCase(),
    risk_level_rank: normalizeRiskRank(riskLevel),
    failed_goals: toNumber(entry && entry.batch_summary ? entry.batch_summary.failed_goals : null),
    elapsed_ms: null,
    ontology_quality_score: toNumber(
      gateActual.ontology_quality_score !== undefined
        ? gateActual.ontology_quality_score
        : ontology.quality_score
    ),
    ontology_unmapped_rules: toNumber(
      gateActual.ontology_business_rule_unmapped !== undefined
        ? gateActual.ontology_business_rule_unmapped
        : ontologyMetrics.business_rule_unmapped
    ),
    ontology_undecided_decisions: toNumber(
      gateActual.ontology_decision_undecided !== undefined
        ? gateActual.ontology_decision_undecided
        : ontologyMetrics.decision_undecided
    ),
    ontology_business_rule_pass_rate_percent: toNumber(ontologyMetrics.business_rule_pass_rate_percent),
    ontology_decision_resolved_rate_percent: toNumber(ontologyMetrics.decision_resolved_rate_percent),
    scene_package_batch_status: sceneBatchStatus,
    scene_package_batch_passed: typeof sceneBatchPassed === 'boolean' ? sceneBatchPassed : null,
    scene_package_batch_failure_count: toNumber(
      scenePackageBatchSummary.batch_gate_failure_count !== undefined
        ? scenePackageBatchSummary.batch_gate_failure_count
        : scenePackageBatchSummary.failed
    ),
    capability_coverage_percent: toNumber(
      entry &&
      entry.capability_coverage &&
      entry.capability_coverage.summary
        ? entry.capability_coverage.summary.coverage_percent
        : null
    ),
    capability_coverage_passed: Boolean(
      entry &&
      entry.capability_coverage &&
      entry.capability_coverage.summary &&
      entry.capability_coverage.summary.passed === true
    ),
    generated_at: normalizeHandoffText(entry.merged_at)
  };
}

function buildAutoHandoffEvidenceStatusCounts(entries = []) {
  const counts = {
    completed: 0,
    failed: 0,
    dry_run: 0,
    running: 0,
    other: 0
  };
  entries.forEach(entry => {
    const status = `${entry && entry.status ? entry.status : ''}`.trim().toLowerCase();
    if (status === 'completed') {
      counts.completed += 1;
    } else if (status === 'failed') {
      counts.failed += 1;
    } else if (status === 'dry-run' || status === 'dry_run') {
      counts.dry_run += 1;
    } else if (status === 'running') {
      counts.running += 1;
    } else {
      counts.other += 1;
    }
  });
  return counts;
}

function renderAutoHandoffEvidenceReviewMarkdown(payload = {}) {
  const current = payload.current || {};
  const currentOverview = payload.current_overview || {};
  const gate = currentOverview.gate && typeof currentOverview.gate === 'object'
    ? currentOverview.gate
    : {};
  const gateActual = gate && gate.actual && typeof gate.actual === 'object'
    ? gate.actual
    : {};
  const ontology = currentOverview.ontology_validation && typeof currentOverview.ontology_validation === 'object'
    ? currentOverview.ontology_validation
    : {};
  const ontologyMetrics = ontology && ontology.metrics && typeof ontology.metrics === 'object'
    ? ontology.metrics
    : {};
  const regression = currentOverview.regression && typeof currentOverview.regression === 'object'
    ? currentOverview.regression
    : {};
  const moquiBaseline = currentOverview.moqui_baseline && typeof currentOverview.moqui_baseline === 'object'
    ? currentOverview.moqui_baseline
    : {};
  const moquiSummary = moquiBaseline && moquiBaseline.summary && typeof moquiBaseline.summary === 'object'
    ? moquiBaseline.summary
    : {};
  const moquiCompare = moquiBaseline && moquiBaseline.compare && typeof moquiBaseline.compare === 'object'
    ? moquiBaseline.compare
    : {};
  const moquiDeltas = moquiCompare && moquiCompare.deltas && typeof moquiCompare.deltas === 'object'
    ? moquiCompare.deltas
    : {};
  const moquiFailedTemplates = moquiCompare && moquiCompare.failed_templates && typeof moquiCompare.failed_templates === 'object'
    ? moquiCompare.failed_templates
    : {};
  const scenePackageBatch = currentOverview.scene_package_batch && typeof currentOverview.scene_package_batch === 'object'
    ? currentOverview.scene_package_batch
    : {};
  const scenePackageBatchSummary = scenePackageBatch && scenePackageBatch.summary && typeof scenePackageBatch.summary === 'object'
    ? scenePackageBatch.summary
    : {};
  const scenePackageBatchGate = scenePackageBatch && scenePackageBatch.batch_ontology_gate && typeof scenePackageBatch.batch_ontology_gate === 'object'
    ? scenePackageBatch.batch_ontology_gate
    : {};
  const scenePackageBatchFailures = Array.isArray(scenePackageBatchGate.failures)
    ? scenePackageBatchGate.failures
    : [];
  const capabilityCoverage = currentOverview.capability_coverage && typeof currentOverview.capability_coverage === 'object'
    ? currentOverview.capability_coverage
    : {};
  const capabilitySummary = capabilityCoverage && capabilityCoverage.summary && typeof capabilityCoverage.summary === 'object'
    ? capabilityCoverage.summary
    : {};
  const capabilityCompare = capabilityCoverage && capabilityCoverage.compare && typeof capabilityCoverage.compare === 'object'
    ? capabilityCoverage.compare
    : {};
  const capabilityGaps = Array.isArray(capabilityCoverage && capabilityCoverage.gaps)
    ? capabilityCoverage.gaps
    : [];
  const capabilityNormalization = capabilityCoverage && capabilityCoverage.normalization && typeof capabilityCoverage.normalization === 'object'
    ? capabilityCoverage.normalization
    : {};
  const capabilityWarnings = Array.isArray(capabilityCoverage && capabilityCoverage.warnings)
    ? capabilityCoverage.warnings
    : [];
  const window = payload.window || { requested: 5, actual: 0 };
  const series = Array.isArray(payload.series) ? payload.series : [];
  const riskLayers = payload.risk_layers && typeof payload.risk_layers === 'object'
    ? payload.risk_layers
    : {};
  const recommendations = Array.isArray(payload.recommendations) ? payload.recommendations : [];
  const trendSeriesLines = series.length > 0
    ? series.map(item => {
      const sessionId = formatAutoHandoffRegressionValue(item.session_id);
      const mergedAt = formatAutoHandoffRegressionValue(item.merged_at || item.generated_at);
      const riskLevel = formatAutoHandoffRegressionValue(item.risk_level);
      const failedGoals = formatAutoHandoffRegressionValue(item.failed_goals);
      const sceneBatch = item.scene_package_batch_passed === null || item.scene_package_batch_passed === undefined
        ? 'n/a'
        : (item.scene_package_batch_passed ? 'pass' : 'fail');
      const successBar = renderAutoHandoffRegressionAsciiBar(item.spec_success_rate_percent, 100, 20);
      const ontologyBar = renderAutoHandoffRegressionAsciiBar(item.ontology_quality_score, 100, 20);
      const capabilityBar = renderAutoHandoffRegressionAsciiBar(item.capability_coverage_percent, 100, 20);
      return (
        `- ${sessionId} | ${mergedAt} | risk=${riskLevel} | failed=${failedGoals} | scene-batch=${sceneBatch} | ` +
        `success=${successBar} | ontology=${ontologyBar} | capability=${capabilityBar}`
      );
    })
    : ['- None'];
  const riskLayerLines = ['low', 'medium', 'high', 'unknown'].map(level => {
    const scoped = riskLayers[level] && typeof riskLayers[level] === 'object'
      ? riskLayers[level]
      : {};
    return (
      `- ${level}: count=${formatAutoHandoffRegressionValue(scoped.count, '0')}, ` +
      `avg_success=${formatAutoHandoffRegressionValue(scoped.avg_spec_success_rate_percent)}, ` +
      `avg_failed_goals=${formatAutoHandoffRegressionValue(scoped.avg_failed_goals)}, ` +
      `avg_ontology_quality=${formatAutoHandoffRegressionValue(scoped.avg_ontology_quality_score)}, ` +
      `scene_batch_pass_rate=${formatAutoHandoffRegressionValue(scoped.scene_package_batch_pass_rate_percent)}%`
    );
  });

  const lines = [
    '# Auto Handoff Release Evidence Review',
    '',
    `- Evidence file: ${formatAutoHandoffRegressionValue(payload.evidence_file)}`,
    `- Session: ${formatAutoHandoffRegressionValue(current.session_id)}`,
    `- Status: ${formatAutoHandoffRegressionValue(current.status)}`,
    `- Trend: ${formatAutoHandoffRegressionValue(payload.trend)}`,
    `- Window: ${formatAutoHandoffRegressionValue(window.actual)}/${formatAutoHandoffRegressionValue(window.requested)}`,
    '',
    '## Current Gate',
    '',
    `- Passed: ${gate.passed === true ? 'yes' : 'no'}`,
    `- Spec success rate: ${formatAutoHandoffRegressionValue(gateActual.spec_success_rate_percent)}`,
    `- Risk level: ${formatAutoHandoffRegressionValue(gateActual.risk_level)}`,
    `- Ontology quality score: ${formatAutoHandoffRegressionValue(gateActual.ontology_quality_score)}`,
    `- Unmapped business rules: ${formatAutoHandoffRegressionValue(gateActual.ontology_business_rule_unmapped)}`,
    `- Undecided decisions: ${formatAutoHandoffRegressionValue(gateActual.ontology_decision_undecided)}`,
    '',
    '## Current Ontology',
    '',
    `- Status: ${formatAutoHandoffRegressionValue(ontology.status)}`,
    `- Passed: ${ontology.passed === true ? 'yes' : 'no'}`,
    `- Quality score: ${formatAutoHandoffRegressionValue(ontology.quality_score)}`,
    `- Entity total: ${formatAutoHandoffRegressionValue(ontologyMetrics.entity_total)}`,
    `- Relation total: ${formatAutoHandoffRegressionValue(ontologyMetrics.relation_total)}`,
    `- Business rule unmapped: ${formatAutoHandoffRegressionValue(ontologyMetrics.business_rule_unmapped)}`,
    `- Decision undecided: ${formatAutoHandoffRegressionValue(ontologyMetrics.decision_undecided)}`,
    '',
    '## Current Regression',
    '',
    `- Trend: ${formatAutoHandoffRegressionValue(regression.trend)}`,
    `- Delta success rate: ${formatAutoHandoffRegressionValue(regression.delta && regression.delta.spec_success_rate_percent)}`,
    `- Delta risk rank: ${formatAutoHandoffRegressionValue(regression.delta && regression.delta.risk_level_rank)}`,
    `- Delta failed goals: ${formatAutoHandoffRegressionValue(regression.delta && regression.delta.failed_goals)}`,
    '',
    '## Current Moqui Baseline',
    '',
    `- Status: ${formatAutoHandoffRegressionValue(moquiBaseline.status)}`,
    `- Portfolio passed: ${moquiSummary.portfolio_passed === true ? 'yes' : (moquiSummary.portfolio_passed === false ? 'no' : 'n/a')}`,
    `- Avg score: ${formatAutoHandoffRegressionValue(moquiSummary.avg_score)}`,
    `- Valid-rate: ${formatAutoHandoffRegressionValue(moquiSummary.valid_rate_percent)}%`,
    `- Baseline failed templates: ${formatAutoHandoffRegressionValue(moquiSummary.baseline_failed)}`,
    `- Delta avg score: ${formatAutoHandoffRegressionValue(moquiDeltas.avg_score)}`,
    `- Delta valid-rate: ${formatAutoHandoffRegressionValue(moquiDeltas.valid_rate_percent)}%`,
    `- Newly failed templates: ${Array.isArray(moquiFailedTemplates.newly_failed) && moquiFailedTemplates.newly_failed.length > 0 ? moquiFailedTemplates.newly_failed.join(', ') : 'none'}`,
    `- Recovered templates: ${Array.isArray(moquiFailedTemplates.recovered) && moquiFailedTemplates.recovered.length > 0 ? moquiFailedTemplates.recovered.join(', ') : 'none'}`,
    `- Baseline JSON: ${formatAutoHandoffRegressionValue(moquiBaseline.output && moquiBaseline.output.json)}`,
    '',
    '## Current Scene Package Batch',
    '',
    `- Status: ${formatAutoHandoffRegressionValue(scenePackageBatch.status)}`,
    `- Generated: ${scenePackageBatch.generated === true ? 'yes' : 'no'}`,
    `- Selected specs: ${formatAutoHandoffRegressionValue(scenePackageBatchSummary.selected)}`,
    `- Failed specs: ${formatAutoHandoffRegressionValue(scenePackageBatchSummary.failed)}`,
    `- Batch gate passed: ${scenePackageBatchSummary.batch_gate_passed === true ? 'yes' : (scenePackageBatchSummary.batch_gate_passed === false ? 'no' : 'n/a')}`,
    `- Batch gate failure count: ${formatAutoHandoffRegressionValue(scenePackageBatchSummary.batch_gate_failure_count)}`,
    `- Ontology average score: ${formatAutoHandoffRegressionValue(scenePackageBatchSummary.ontology_average_score)}`,
    `- Ontology valid-rate: ${formatAutoHandoffRegressionValue(scenePackageBatchSummary.ontology_valid_rate_percent)}%`,
    `- Batch gate failures: ${scenePackageBatchFailures.length > 0 ? scenePackageBatchFailures.map(item => item && item.message ? item.message : '').filter(Boolean).join(' | ') : 'none'}`,
    `- Scene batch JSON: ${formatAutoHandoffRegressionValue(scenePackageBatch.output && scenePackageBatch.output.json)}`,
    '',
    '## Current Capability Coverage',
    '',
    `- Status: ${formatAutoHandoffRegressionValue(capabilityCoverage.status)}`,
    `- Passed: ${capabilitySummary.passed === true ? 'yes' : (capabilitySummary.passed === false ? 'no' : 'n/a')}`,
    `- Coverage: ${formatAutoHandoffRegressionValue(capabilitySummary.coverage_percent)}%`,
    `- Min required: ${formatAutoHandoffRegressionValue(capabilitySummary.min_required_percent)}%`,
    `- Covered capabilities: ${formatAutoHandoffRegressionValue(capabilitySummary.covered_capabilities)}`,
    `- Uncovered capabilities: ${formatAutoHandoffRegressionValue(capabilitySummary.uncovered_capabilities)}`,
    `- Delta coverage: ${formatAutoHandoffRegressionValue(capabilityCompare.delta_coverage_percent)}%`,
    `- Delta covered capabilities: ${formatAutoHandoffRegressionValue(capabilityCompare.delta_covered_capabilities)}`,
    `- Newly covered: ${Array.isArray(capabilityCompare.newly_covered) && capabilityCompare.newly_covered.length > 0 ? capabilityCompare.newly_covered.join(', ') : 'none'}`,
    `- Newly uncovered: ${Array.isArray(capabilityCompare.newly_uncovered) && capabilityCompare.newly_uncovered.length > 0 ? capabilityCompare.newly_uncovered.join(', ') : 'none'}`,
    `- Lexicon version: ${formatAutoHandoffRegressionValue(capabilityNormalization.lexicon_version)}`,
    `- Expected alias mapped: ${formatAutoHandoffRegressionValue(Array.isArray(capabilityNormalization.expected_alias_mapped) ? capabilityNormalization.expected_alias_mapped.length : 0)}`,
    `- Expected deprecated alias: ${formatAutoHandoffRegressionValue(Array.isArray(capabilityNormalization.expected_deprecated_aliases) ? capabilityNormalization.expected_deprecated_aliases.length : 0)}`,
    `- Expected unknown: ${formatAutoHandoffRegressionValue(Array.isArray(capabilityNormalization.expected_unknown) ? capabilityNormalization.expected_unknown.length : 0)}`,
    `- Provided alias mapped: ${formatAutoHandoffRegressionValue(Array.isArray(capabilityNormalization.provided_alias_mapped) ? capabilityNormalization.provided_alias_mapped.length : 0)}`,
    `- Provided deprecated alias: ${formatAutoHandoffRegressionValue(Array.isArray(capabilityNormalization.provided_deprecated_aliases) ? capabilityNormalization.provided_deprecated_aliases.length : 0)}`,
    `- Provided unknown: ${formatAutoHandoffRegressionValue(Array.isArray(capabilityNormalization.provided_unknown) ? capabilityNormalization.provided_unknown.length : 0)}`,
    `- Capability gaps: ${capabilityGaps.length > 0 ? capabilityGaps.join(', ') : 'none'}`,
    `- Coverage warnings: ${capabilityWarnings.length > 0 ? capabilityWarnings.join(' | ') : 'none'}`,
    `- Coverage JSON: ${formatAutoHandoffRegressionValue(capabilityCoverage.output && capabilityCoverage.output.json)}`,
    '',
    '## Trend Series',
    '',
    ...trendSeriesLines,
    '',
    '## Risk Layer View',
    '',
    ...riskLayerLines,
    '',
    '## Recommendations'
  ];

  if (recommendations.length === 0) {
    lines.push('', '- None');
  } else {
    recommendations.forEach(item => {
      lines.push('', `- ${item}`);
    });
  }

  return `${lines.join('\n')}\n`;
}

function normalizeHandoffReleaseDate(dateCandidate) {
  const fallbackDate = new Date().toISOString().slice(0, 10);
  if (dateCandidate === undefined || dateCandidate === null || `${dateCandidate}`.trim().length === 0) {
    return fallbackDate;
  }
  const normalized = `${dateCandidate}`.trim();
  if (!/^\d{4}-\d{2}-\d{2}$/.test(normalized)) {
    throw new Error('--release-date must be in YYYY-MM-DD format.');
  }
  const parsed = Date.parse(`${normalized}T00:00:00.000Z`);
  if (!Number.isFinite(parsed)) {
    throw new Error('--release-date must be a valid calendar date.');
  }
  return normalized;
}

function normalizeHandoffReleaseVersion(versionCandidate, fallbackVersion) {
  const fallback = typeof fallbackVersion === 'string' && fallbackVersion.trim()
    ? fallbackVersion.trim()
    : '0.0.0';
  const normalized = versionCandidate === undefined || versionCandidate === null || `${versionCandidate}`.trim().length === 0
    ? fallback
    : `${versionCandidate}`.trim();
  return normalized.startsWith('v') ? normalized : `v${normalized}`;
}

function toPortablePath(projectPath, absolutePath) {
  const relative = path.relative(projectPath, absolutePath);
  if (relative && !relative.startsWith('..') && !path.isAbsolute(relative)) {
    return relative.split(path.sep).join('/');
  }
  return absolutePath;
}

async function resolveAutoHandoffReleaseDraftContext(projectPath, options = {}) {
  let packageVersion = null;
  try {
    const packagePayload = await fs.readJson(path.join(projectPath, 'package.json'));
    if (packagePayload && typeof packagePayload.version === 'string' && packagePayload.version.trim()) {
      packageVersion = packagePayload.version.trim();
    }
  } catch (error) {
    packageVersion = null;
  }

  return {
    version: normalizeHandoffReleaseVersion(options.releaseVersion, packageVersion || '0.0.0'),
    releaseDate: normalizeHandoffReleaseDate(options.releaseDate)
  };
}

function renderAutoHandoffReleaseNotesDraft(payload = {}, context = {}) {
  const current = payload.current || {};
  const currentOverview = payload.current_overview || {};
  const gate = currentOverview.gate && typeof currentOverview.gate === 'object'
    ? currentOverview.gate
    : {};
  const gateActual = gate && gate.actual && typeof gate.actual === 'object'
    ? gate.actual
    : {};
  const ontology = currentOverview.ontology_validation && typeof currentOverview.ontology_validation === 'object'
    ? currentOverview.ontology_validation
    : {};
  const ontologyMetrics = ontology && ontology.metrics && typeof ontology.metrics === 'object'
    ? ontology.metrics
    : {};
  const regression = currentOverview.regression && typeof currentOverview.regression === 'object'
    ? currentOverview.regression
    : {};
  const moquiBaseline = currentOverview.moqui_baseline && typeof currentOverview.moqui_baseline === 'object'
    ? currentOverview.moqui_baseline
    : {};
  const moquiSummary = moquiBaseline && moquiBaseline.summary && typeof moquiBaseline.summary === 'object'
    ? moquiBaseline.summary
    : {};
  const moquiCompare = moquiBaseline && moquiBaseline.compare && typeof moquiBaseline.compare === 'object'
    ? moquiBaseline.compare
    : {};
  const moquiDeltas = moquiCompare && moquiCompare.deltas && typeof moquiCompare.deltas === 'object'
    ? moquiCompare.deltas
    : {};
  const moquiFailedTemplates = moquiCompare && moquiCompare.failed_templates && typeof moquiCompare.failed_templates === 'object'
    ? moquiCompare.failed_templates
    : {};
  const scenePackageBatch = currentOverview.scene_package_batch && typeof currentOverview.scene_package_batch === 'object'
    ? currentOverview.scene_package_batch
    : {};
  const scenePackageBatchSummary = scenePackageBatch && scenePackageBatch.summary && typeof scenePackageBatch.summary === 'object'
    ? scenePackageBatch.summary
    : {};
  const scenePackageBatchGate = scenePackageBatch && scenePackageBatch.batch_ontology_gate && typeof scenePackageBatch.batch_ontology_gate === 'object'
    ? scenePackageBatch.batch_ontology_gate
    : {};
  const scenePackageBatchFailures = Array.isArray(scenePackageBatchGate.failures)
    ? scenePackageBatchGate.failures
    : [];
  const capabilityCoverage = currentOverview.capability_coverage && typeof currentOverview.capability_coverage === 'object'
    ? currentOverview.capability_coverage
    : {};
  const capabilitySummary = capabilityCoverage && capabilityCoverage.summary && typeof capabilityCoverage.summary === 'object'
    ? capabilityCoverage.summary
    : {};
  const capabilityCompare = capabilityCoverage && capabilityCoverage.compare && typeof capabilityCoverage.compare === 'object'
    ? capabilityCoverage.compare
    : {};
  const capabilityGaps = Array.isArray(capabilityCoverage && capabilityCoverage.gaps)
    ? capabilityCoverage.gaps
    : [];
  const capabilityNormalization = capabilityCoverage && capabilityCoverage.normalization && typeof capabilityCoverage.normalization === 'object'
    ? capabilityCoverage.normalization
    : {};
  const capabilityWarnings = Array.isArray(capabilityCoverage && capabilityCoverage.warnings)
    ? capabilityCoverage.warnings
    : [];
  const riskLayers = payload.risk_layers && typeof payload.risk_layers === 'object'
    ? payload.risk_layers
    : {};
  const statusCounts = payload.aggregates && payload.aggregates.status_counts
    ? payload.aggregates.status_counts
    : {};
  const recommendations = Array.isArray(payload.recommendations) ? payload.recommendations : [];
  const reviewFile = typeof context.reviewFile === 'string' && context.reviewFile.trim()
    ? context.reviewFile.trim()
    : null;
  const version = normalizeHandoffReleaseVersion(context.version, '0.0.0');
  const releaseDate = normalizeHandoffReleaseDate(context.releaseDate);

  const riskLines = ['low', 'medium', 'high', 'unknown'].map(level => {
    const scoped = riskLayers[level] && typeof riskLayers[level] === 'object'
      ? riskLayers[level]
      : {};
    return (
      `- ${level}: count=${formatAutoHandoffRegressionValue(scoped.count, '0')}, ` +
      `avg_success=${formatAutoHandoffRegressionValue(scoped.avg_spec_success_rate_percent)}, ` +
      `avg_failed_goals=${formatAutoHandoffRegressionValue(scoped.avg_failed_goals)}, ` +
      `avg_ontology_quality=${formatAutoHandoffRegressionValue(scoped.avg_ontology_quality_score)}`
    );
  });

  const lines = [
    `# Release Notes Draft: ${version}`,
    '',
    `Release date: ${releaseDate}`,
    '',
    '## Handoff Evidence Summary',
    '',
    `- Evidence file: ${formatAutoHandoffRegressionValue(payload.evidence_file)}`,
    `- Current session: ${formatAutoHandoffRegressionValue(current.session_id)}`,
    `- Current status: ${formatAutoHandoffRegressionValue(current.status)}`,
    `- Gate passed: ${gate.passed === true ? 'yes' : 'no'}`,
    `- Spec success rate: ${formatAutoHandoffRegressionValue(gateActual.spec_success_rate_percent)}`,
    `- Risk level: ${formatAutoHandoffRegressionValue(gateActual.risk_level)}`,
    `- Ontology quality score: ${formatAutoHandoffRegressionValue(gateActual.ontology_quality_score)}`,
    `- Ontology unmapped rules: ${formatAutoHandoffRegressionValue(gateActual.ontology_business_rule_unmapped, formatAutoHandoffRegressionValue(ontologyMetrics.business_rule_unmapped))}`,
    `- Ontology undecided decisions: ${formatAutoHandoffRegressionValue(gateActual.ontology_decision_undecided, formatAutoHandoffRegressionValue(ontologyMetrics.decision_undecided))}`,
    `- Regression trend: ${formatAutoHandoffRegressionValue(regression.trend, formatAutoHandoffRegressionValue(payload.trend))}`,
    `- Window trend: ${formatAutoHandoffRegressionValue(payload.window_trend && payload.window_trend.trend)}`,
    `- Gate pass rate (window): ${formatAutoHandoffRegressionValue(payload.aggregates && payload.aggregates.gate_pass_rate_percent)}%`,
    `- Moqui baseline portfolio passed: ${moquiSummary.portfolio_passed === true ? 'yes' : (moquiSummary.portfolio_passed === false ? 'no' : 'n/a')}`,
    `- Moqui baseline avg score: ${formatAutoHandoffRegressionValue(moquiSummary.avg_score)}`,
    `- Moqui baseline valid-rate: ${formatAutoHandoffRegressionValue(moquiSummary.valid_rate_percent)}%`,
    `- Moqui baseline failed templates: ${formatAutoHandoffRegressionValue(moquiSummary.baseline_failed)}`,
    `- Moqui baseline avg score delta: ${formatAutoHandoffRegressionValue(moquiDeltas.avg_score)}`,
    `- Moqui baseline valid-rate delta: ${formatAutoHandoffRegressionValue(moquiDeltas.valid_rate_percent)}%`,
    `- Moqui newly failed templates: ${Array.isArray(moquiFailedTemplates.newly_failed) && moquiFailedTemplates.newly_failed.length > 0 ? moquiFailedTemplates.newly_failed.join(', ') : 'none'}`,
    `- Scene package batch status: ${formatAutoHandoffRegressionValue(scenePackageBatch.status)}`,
    `- Scene package batch selected: ${formatAutoHandoffRegressionValue(scenePackageBatchSummary.selected)}`,
    `- Scene package batch failed: ${formatAutoHandoffRegressionValue(scenePackageBatchSummary.failed)}`,
    `- Scene package batch gate passed: ${scenePackageBatchSummary.batch_gate_passed === true ? 'yes' : (scenePackageBatchSummary.batch_gate_passed === false ? 'no' : 'n/a')}`,
    `- Scene package batch gate failures: ${scenePackageBatchFailures.length > 0 ? scenePackageBatchFailures.map(item => item && item.message ? item.message : '').filter(Boolean).join(' | ') : 'none'}`,
    `- Capability coverage status: ${formatAutoHandoffRegressionValue(capabilityCoverage.status)}`,
    `- Capability coverage passed: ${capabilitySummary.passed === true ? 'yes' : (capabilitySummary.passed === false ? 'no' : 'n/a')}`,
    `- Capability coverage: ${formatAutoHandoffRegressionValue(capabilitySummary.coverage_percent)}%`,
    `- Capability min required: ${formatAutoHandoffRegressionValue(capabilitySummary.min_required_percent)}%`,
    `- Capability coverage delta: ${formatAutoHandoffRegressionValue(capabilityCompare.delta_coverage_percent)}%`,
    `- Capability newly uncovered: ${Array.isArray(capabilityCompare.newly_uncovered) && capabilityCompare.newly_uncovered.length > 0 ? capabilityCompare.newly_uncovered.join(', ') : 'none'}`,
    `- Capability lexicon version: ${formatAutoHandoffRegressionValue(capabilityNormalization.lexicon_version)}`,
    `- Capability expected alias mapped: ${formatAutoHandoffRegressionValue(Array.isArray(capabilityNormalization.expected_alias_mapped) ? capabilityNormalization.expected_alias_mapped.length : 0)}`,
    `- Capability expected deprecated alias: ${formatAutoHandoffRegressionValue(Array.isArray(capabilityNormalization.expected_deprecated_aliases) ? capabilityNormalization.expected_deprecated_aliases.length : 0)}`,
    `- Capability provided deprecated alias: ${formatAutoHandoffRegressionValue(Array.isArray(capabilityNormalization.provided_deprecated_aliases) ? capabilityNormalization.provided_deprecated_aliases.length : 0)}`,
    `- Capability gaps: ${capabilityGaps.length > 0 ? capabilityGaps.join(', ') : 'none'}`,
    `- Capability warnings: ${capabilityWarnings.length > 0 ? capabilityWarnings.join(' | ') : 'none'}`,
    '',
    '## Status Breakdown',
    '',
    `- completed: ${formatAutoHandoffRegressionValue(statusCounts.completed, '0')}`,
    `- failed: ${formatAutoHandoffRegressionValue(statusCounts.failed, '0')}`,
    `- dry_run: ${formatAutoHandoffRegressionValue(statusCounts.dry_run, '0')}`,
    `- running: ${formatAutoHandoffRegressionValue(statusCounts.running, '0')}`,
    `- other: ${formatAutoHandoffRegressionValue(statusCounts.other, '0')}`,
    '',
    '## Risk Layer Snapshot',
    '',
    ...riskLines,
    '',
    '## Release Evidence Artifacts',
    '',
    `- Evidence review report: ${reviewFile || 'n/a'}`,
    `- Handoff report: ${formatAutoHandoffRegressionValue(currentOverview.handoff_report_file)}`,
    `- Release evidence JSON: ${formatAutoHandoffRegressionValue(payload.evidence_file)}`,
    `- Moqui baseline JSON: ${formatAutoHandoffRegressionValue(moquiBaseline.output && moquiBaseline.output.json)}`,
    `- Moqui baseline markdown: ${formatAutoHandoffRegressionValue(moquiBaseline.output && moquiBaseline.output.markdown)}`,
    `- Scene package batch JSON: ${formatAutoHandoffRegressionValue(scenePackageBatch.output && scenePackageBatch.output.json)}`,
    `- Capability coverage JSON: ${formatAutoHandoffRegressionValue(capabilityCoverage.output && capabilityCoverage.output.json)}`,
    `- Capability coverage markdown: ${formatAutoHandoffRegressionValue(capabilityCoverage.output && capabilityCoverage.output.markdown)}`,
    '',
    '## Recommendations'
  ];

  if (recommendations.length === 0) {
    lines.push('', '- None');
  } else {
    recommendations.forEach(item => {
      lines.push('', `- ${item}`);
    });
  }

  return `${lines.join('\n')}\n`;
}

async function buildAutoHandoffEvidenceReviewReport(projectPath, options = {}) {
  const releaseEvidence = await loadAutoHandoffReleaseEvidence(projectPath, options.file);
  if (releaseEvidence.sessions.length === 0) {
    throw new Error(`no release evidence sessions found: ${releaseEvidence.file}`);
  }

  const query = normalizeHandoffSessionQuery(options.sessionId);
  const windowSize = normalizeHandoffEvidenceWindow(options.window);
  let currentIndex = 0;
  if (query !== 'latest') {
    currentIndex = releaseEvidence.sessions.findIndex(item => normalizeHandoffText(item.session_id) === query);
    if (currentIndex < 0) {
      throw new Error(`release evidence session not found: ${query}`);
    }
  }

  const selectedEntries = releaseEvidence.sessions.slice(currentIndex, currentIndex + windowSize);
  const series = selectedEntries.map(item => buildAutoHandoffEvidenceSnapshot(item));
  const currentSnapshot = series[0];
  const previousSnapshot = series[1] || null;
  const comparison = previousSnapshot
    ? buildAutoHandoffRegressionComparison(currentSnapshot, previousSnapshot)
    : {
      trend: 'baseline',
      delta: {
        spec_success_rate_percent: null,
        risk_level_rank: null,
        failed_goals: null,
        elapsed_ms: null,
        ontology_quality_score: null,
        ontology_unmapped_rules: null,
        ontology_undecided_decisions: null,
        ontology_business_rule_pass_rate_percent: null,
        ontology_decision_resolved_rate_percent: null,
        scene_package_batch_failure_count: null
      }
    };
  const windowTrend = buildAutoHandoffRegressionWindowTrend(series);
  const aggregates = buildAutoHandoffRegressionAggregates(series);
  const riskLayers = buildAutoHandoffRegressionRiskLayers(series);
  const statusCounts = buildAutoHandoffEvidenceStatusCounts(selectedEntries);
  const gatePassCount = selectedEntries.filter(item => item && item.gate && item.gate.passed === true).length;
  const gatePassRate = selectedEntries.length > 0
    ? Number(((gatePassCount / selectedEntries.length) * 100).toFixed(2))
    : null;

  const payload = {
    mode: 'auto-handoff-evidence-review',
    generated_at: new Date().toISOString(),
    evidence_file: releaseEvidence.file,
    release_evidence_updated_at: normalizeHandoffText(releaseEvidence.payload.updated_at),
    session_query: query,
    current: currentSnapshot,
    current_overview: selectedEntries[0] || null,
    previous: previousSnapshot,
    trend: comparison.trend,
    delta: comparison.delta,
    window: {
      requested: windowSize,
      actual: series.length
    },
    series,
    window_trend: windowTrend,
    aggregates: {
      ...aggregates,
      status_counts: statusCounts,
      gate_pass_rate_percent: gatePassRate
    },
    risk_layers: riskLayers,
    recommendations: []
  };
  payload.recommendations = buildAutoHandoffRegressionRecommendations(payload);
  return payload;
}

async function buildAutoHandoffRegression(projectPath, currentResult) {
  const reports = await listAutoHandoffRunReports(projectPath);
  const previous = reports.find(item => item.session_id !== currentResult.session_id) || null;
  const currentSnapshot = buildAutoHandoffRegressionSnapshot(currentResult);
  if (!previous) {
    return {
      mode: 'auto-handoff-regression',
      current: currentSnapshot,
      previous: null,
      trend: 'baseline',
      delta: {
        spec_success_rate_percent: null,
        risk_level_rank: null,
        failed_goals: null,
        elapsed_ms: null,
        ontology_quality_score: null,
        ontology_unmapped_rules: null,
        ontology_undecided_decisions: null,
        ontology_business_rule_pass_rate_percent: null,
        ontology_decision_resolved_rate_percent: null,
        scene_package_batch_failure_count: null
      }
    };
  }

  const previousSnapshot = buildAutoHandoffRegressionSnapshot(previous);
  const comparison = buildAutoHandoffRegressionComparison(currentSnapshot, previousSnapshot);
  return {
    mode: 'auto-handoff-regression',
    current: currentSnapshot,
    previous: previousSnapshot,
    trend: comparison.trend,
    delta: comparison.delta
  };
}

async function buildAutoHandoffRegressionReport(projectPath, options = {}) {
  const reports = await listAutoHandoffRunReports(projectPath);
  if (reports.length === 0) {
    throw new Error('no handoff run reports found');
  }
  const query = normalizeHandoffSessionQuery(options.sessionId);
  const windowSize = normalizeHandoffRegressionWindow(options.window);
  let currentIndex = 0;
  if (query !== 'latest') {
    currentIndex = reports.findIndex(item => item.session_id === query);
    if (currentIndex < 0) {
      throw new Error(`handoff run session not found: ${query}`);
    }
  }

  const chainReports = reports.slice(currentIndex, currentIndex + windowSize);
  const series = chainReports.map(item => buildAutoHandoffRegressionSnapshot(item));
  const currentSnapshot = series[0];
  const previousSnapshot = series[1] || null;
  const comparison = previousSnapshot
    ? buildAutoHandoffRegressionComparison(currentSnapshot, previousSnapshot)
    : {
      trend: 'baseline',
      delta: {
        spec_success_rate_percent: null,
        risk_level_rank: null,
        failed_goals: null,
        elapsed_ms: null,
        ontology_quality_score: null,
        ontology_unmapped_rules: null,
        ontology_undecided_decisions: null,
        ontology_business_rule_pass_rate_percent: null,
        ontology_decision_resolved_rate_percent: null,
        scene_package_batch_failure_count: null
      }
    };
  const windowTrend = buildAutoHandoffRegressionWindowTrend(series);
  const aggregates = buildAutoHandoffRegressionAggregates(series);
  const riskLayers = buildAutoHandoffRegressionRiskLayers(series);

  const payload = {
    mode: 'auto-handoff-regression',
    current: currentSnapshot,
    previous: previousSnapshot,
    trend: comparison.trend,
    delta: comparison.delta,
    window: {
      requested: windowSize,
      actual: series.length
    },
    series,
    window_trend: windowTrend,
    aggregates,
    risk_layers: riskLayers,
    recommendations: []
  };
  payload.recommendations = buildAutoHandoffRegressionRecommendations(payload);
  return payload;
}

function normalizeHandoffMinSpecSuccessRate(rateCandidate) {
  if (rateCandidate === undefined || rateCandidate === null) {
    return 100;
  }
  const parsed = Number(rateCandidate);
  if (!Number.isFinite(parsed) || parsed < 0 || parsed > 100) {
    throw new Error('--min-spec-success-rate must be a number between 0 and 100.');
  }
  return Number(parsed.toFixed(2));
}

function normalizeHandoffRiskLevel(levelCandidate) {
  const normalized = typeof levelCandidate === 'string'
    ? levelCandidate.trim().toLowerCase()
    : 'high';
  if (!['low', 'medium', 'high'].includes(normalized)) {
    throw new Error('--max-risk-level must be one of: low, medium, high.');
  }
  return normalized;
}

function normalizeHandoffMinOntologyScore(scoreCandidate) {
  if (scoreCandidate === undefined || scoreCandidate === null) {
    return 0;
  }
  const parsed = Number(scoreCandidate);
  if (!Number.isFinite(parsed) || parsed < 0 || parsed > 100) {
    throw new Error('--min-ontology-score must be a number between 0 and 100.');
  }
  return Number(parsed.toFixed(2));
}

function normalizeHandoffMinCapabilityCoverage(coverageCandidate) {
  if (coverageCandidate === undefined || coverageCandidate === null) {
    return 100;
  }
  const parsed = Number(coverageCandidate);
  if (!Number.isFinite(parsed) || parsed < 0 || parsed > 100) {
    throw new Error('--min-capability-coverage must be a number between 0 and 100.');
  }
  return Number(parsed.toFixed(2));
}

function normalizeHandoffOptionalNonNegativeInteger(valueCandidate, optionName) {
  if (valueCandidate === undefined || valueCandidate === null || valueCandidate === '') {
    return null;
  }
  const parsed = Number(valueCandidate);
  if (!Number.isInteger(parsed) || parsed < 0) {
    throw new Error(`${optionName} must be an integer >= 0.`);
  }
  return parsed;
}

function normalizeHandoffReleaseEvidenceWindow(windowCandidate) {
  if (windowCandidate === undefined || windowCandidate === null || windowCandidate === '') {
    return 5;
  }
  const parsed = Number(windowCandidate);
  if (!Number.isInteger(parsed) || parsed < 2 || parsed > 50) {
    throw new Error('--release-evidence-window must be an integer between 2 and 50.');
  }
  return parsed;
}

function buildAutoHandoffRunPolicy(options = {}) {
  return {
    min_spec_success_rate: normalizeHandoffMinSpecSuccessRate(options.minSpecSuccessRate),
    max_risk_level: normalizeHandoffRiskLevel(options.maxRiskLevel),
    min_ontology_score: normalizeHandoffMinOntologyScore(options.minOntologyScore),
    min_capability_coverage_percent: normalizeHandoffMinCapabilityCoverage(options.minCapabilityCoverage),
    max_unmapped_rules: normalizeHandoffOptionalNonNegativeInteger(
      options.maxUnmappedRules,
      '--max-unmapped-rules'
    ),
    max_undecided_decisions: normalizeHandoffOptionalNonNegativeInteger(
      options.maxUndecidedDecisions,
      '--max-undecided-decisions'
    ),
    require_ontology_validation: options.requireOntologyValidation !== false,
    require_moqui_baseline: options.requireMoquiBaseline !== false,
    require_scene_package_batch: options.requireScenePackageBatch !== false,
    require_capability_coverage: options.requireCapabilityCoverage !== false,
    dependency_batching: options.dependencyBatching !== false,
    release_evidence_window: normalizeHandoffReleaseEvidenceWindow(options.releaseEvidenceWindow)
  };
}

function evaluateHandoffOntologyValidation(ontologyValidation) {
  const payload = ontologyValidation && typeof ontologyValidation === 'object'
    ? ontologyValidation
    : null;
  const statusText = normalizeHandoffText(
    readHandoffPathValue(payload, 'status')
      || readHandoffPathValue(payload, 'result')
      || readHandoffPathValue(payload, 'state')
  );
  const statusToken = statusText ? statusText.toLowerCase() : null;
  const boolSignals = [
    readHandoffPathValue(payload, 'passed'),
    readHandoffPathValue(payload, 'valid'),
    readHandoffPathValue(payload, 'success')
  ];
  let passed = false;
  if (boolSignals.some(value => value === true)) {
    passed = true;
  } else if (statusToken && ['passed', 'success', 'ok', 'valid', 'completed', 'complete'].includes(statusToken)) {
    passed = true;
  }

  const model = normalizeHandoffOntologyModel(payload);
  const entityCount = normalizeHandoffNumber(
    readHandoffFirstPathValue(payload, [
      'coverage.entities.total',
      'metrics.entities.total',
      'entities.total',
      'entity_count'
    ]),
    { min: 0, integer: true }
  );
  const relationCount = normalizeHandoffNumber(
    readHandoffFirstPathValue(payload, [
      'coverage.relations.total',
      'metrics.relations.total',
      'relations.total',
      'relation_count'
    ]),
    { min: 0, integer: true }
  );
  const ruleTotal = normalizeHandoffNumber(
    readHandoffFirstPathValue(payload, [
      'business_rules.total',
      'rules.total',
      'coverage.business_rules.total',
      'metrics.business_rules.total',
      'rule_count'
    ]),
    { min: 0, integer: true }
  );
  const mappedRules = normalizeHandoffNumber(
    readHandoffFirstPathValue(payload, [
      'business_rules.mapped',
      'rules.mapped',
      'coverage.business_rules.mapped',
      'metrics.business_rules.mapped'
    ]),
    { min: 0, integer: true }
  );
  const passedRules = normalizeHandoffNumber(
    readHandoffFirstPathValue(payload, [
      'business_rules.passed',
      'rules.passed',
      'coverage.business_rules.passed',
      'metrics.business_rules.passed'
    ]),
    { min: 0, integer: true }
  );
  const failedRules = normalizeHandoffNumber(
    readHandoffFirstPathValue(payload, [
      'business_rules.failed',
      'rules.failed',
      'coverage.business_rules.failed',
      'metrics.business_rules.failed'
    ]),
    { min: 0, integer: true }
  );
  const decisionTotal = normalizeHandoffNumber(
    readHandoffFirstPathValue(payload, [
      'decision_logic.total',
      'decisions.total',
      'coverage.decision_logic.total',
      'metrics.decision_logic.total',
      'decision_count'
    ]),
    { min: 0, integer: true }
  );
  const resolvedDecisions = normalizeHandoffNumber(
    readHandoffFirstPathValue(payload, [
      'decision_logic.resolved',
      'decisions.resolved',
      'coverage.decision_logic.resolved',
      'metrics.decision_logic.resolved'
    ]),
    { min: 0, integer: true }
  );
  const pendingDecisions = normalizeHandoffNumber(
    readHandoffFirstPathValue(payload, [
      'decision_logic.pending',
      'decisions.pending',
      'coverage.decision_logic.pending',
      'metrics.decision_logic.pending'
    ]),
    { min: 0, integer: true }
  );
  const automatedDecisions = normalizeHandoffNumber(
    readHandoffFirstPathValue(payload, [
      'decision_logic.automated',
      'decisions.automated',
      'decision_logic.tested',
      'decisions.tested',
      'coverage.decision_logic.automated',
      'metrics.decision_logic.automated'
    ]),
    { min: 0, integer: true }
  );

  const resolvedEntityCount = entityCount !== null ? entityCount : model.entities.length;
  const resolvedRelationCount = relationCount !== null ? relationCount : model.relations.length;
  const resolvedRuleTotal = ruleTotal !== null ? ruleTotal : model.business_rules.length;
  const resolvedRuleMapped = mappedRules !== null
    ? mappedRules
    : model.business_rules.filter(item => item.mapped).length;
  const resolvedRulePassed = passedRules !== null
    ? passedRules
    : model.business_rules.filter(item => item.passed).length;
  const resolvedRuleFailed = failedRules !== null
    ? failedRules
    : (resolvedRuleTotal !== null && resolvedRulePassed !== null
      ? Math.max(0, resolvedRuleTotal - resolvedRulePassed)
      : null);
  const resolvedDecisionTotal = decisionTotal !== null ? decisionTotal : model.decision_logic.length;
  const resolvedDecisionResolved = resolvedDecisions !== null
    ? resolvedDecisions
    : model.decision_logic.filter(item => item.resolved).length;
  const resolvedDecisionPending = pendingDecisions !== null
    ? pendingDecisions
    : (resolvedDecisionTotal !== null && resolvedDecisionResolved !== null
      ? Math.max(0, resolvedDecisionTotal - resolvedDecisionResolved)
      : null);
  const resolvedDecisionAutomated = automatedDecisions !== null
    ? automatedDecisions
    : model.decision_logic.filter(item => item.automated).length;

  const unmappedRules = (
    Number.isFinite(resolvedRuleTotal) && Number.isFinite(resolvedRuleMapped)
  )
    ? Math.max(0, resolvedRuleTotal - resolvedRuleMapped)
    : null;
  const undecidedDecisions = Number.isFinite(resolvedDecisionPending)
    ? resolvedDecisionPending
    : (
      Number.isFinite(resolvedDecisionTotal) && Number.isFinite(resolvedDecisionResolved)
        ? Math.max(0, resolvedDecisionTotal - resolvedDecisionResolved)
        : null
    );

  const ruleMappingRate = Number.isFinite(resolvedRuleTotal) && resolvedRuleTotal > 0 && Number.isFinite(resolvedRuleMapped)
    ? Number(((resolvedRuleMapped / resolvedRuleTotal) * 100).toFixed(2))
    : null;
  const rulePassRate = Number.isFinite(resolvedRuleTotal) && resolvedRuleTotal > 0 && Number.isFinite(resolvedRulePassed)
    ? Number(((resolvedRulePassed / resolvedRuleTotal) * 100).toFixed(2))
    : null;
  const decisionResolvedRate = Number.isFinite(resolvedDecisionTotal) && resolvedDecisionTotal > 0 && Number.isFinite(resolvedDecisionResolved)
    ? Number(((resolvedDecisionResolved / resolvedDecisionTotal) * 100).toFixed(2))
    : null;

  const qualityScoreFromManifest = normalizeHandoffNumber(
    readHandoffFirstPathValue(payload, [
      'quality.score',
      'quality_score',
      'metrics.quality_score',
      'score'
    ]),
    { min: 0, max: 100, precision: 2 }
  );

  let qualityScore = qualityScoreFromManifest;
  let qualityScoreSource = qualityScoreFromManifest === null ? 'derived' : 'manifest';
  const qualityComponents = {
    structure: 0,
    business_rules: 0,
    decision_logic: 0
  };
  if (qualityScore === null) {
    qualityComponents.structure = (
      (Number.isFinite(resolvedEntityCount) && resolvedEntityCount > 0 ? 20 : 0) +
      (Number.isFinite(resolvedRelationCount) && resolvedRelationCount > 0 ? 20 : 0)
    );
    qualityComponents.business_rules = Number.isFinite(ruleMappingRate)
      ? Number((30 * (ruleMappingRate / 100)).toFixed(2))
      : 15;
    qualityComponents.decision_logic = Number.isFinite(decisionResolvedRate)
      ? Number((30 * (decisionResolvedRate / 100)).toFixed(2))
      : 15;
    qualityScore = Number((
      qualityComponents.structure +
      qualityComponents.business_rules +
      qualityComponents.decision_logic
    ).toFixed(2));
  } else {
    qualityScoreSource = 'manifest';
  }

  return {
    present: Boolean(payload),
    passed,
    status: statusText || null,
    quality_score: qualityScore,
    quality_score_source: qualityScoreSource,
    quality_components: qualityComponents,
    model: {
      entity_relation: {
        entities: resolvedEntityCount,
        relations: resolvedRelationCount
      },
      business_rules: {
        total: resolvedRuleTotal,
        mapped: resolvedRuleMapped,
        passed: resolvedRulePassed,
        failed: resolvedRuleFailed,
        unmapped: unmappedRules
      },
      decision_logic: {
        total: resolvedDecisionTotal,
        resolved: resolvedDecisionResolved,
        pending: resolvedDecisionPending,
        automated: resolvedDecisionAutomated,
        undecided: undecidedDecisions
      }
    },
    metrics: {
      entity_count: resolvedEntityCount,
      relation_count: resolvedRelationCount,
      business_rule_total: resolvedRuleTotal,
      business_rule_mapped: resolvedRuleMapped,
      business_rule_passed: resolvedRulePassed,
      business_rule_failed: resolvedRuleFailed,
      business_rule_unmapped: unmappedRules,
      business_rule_mapping_rate_percent: ruleMappingRate,
      business_rule_pass_rate_percent: rulePassRate,
      decision_total: resolvedDecisionTotal,
      decision_resolved: resolvedDecisionResolved,
      decision_pending: resolvedDecisionPending,
      decision_automated: resolvedDecisionAutomated,
      decision_undecided: undecidedDecisions,
      decision_resolved_rate_percent: decisionResolvedRate
    },
    payload
  };
}

function evaluateAutoHandoffOntologyGateReasons(policy = {}, ontology = {}) {
  const reasons = [];
  if (policy.require_ontology_validation && !ontology.passed) {
    if (!ontology.present) {
      reasons.push('manifest ontology_validation is missing');
    } else {
      reasons.push(`manifest ontology_validation status is not passed (${ontology.status || 'unknown'})`);
    }
  }

  const scoreThreshold = Number(policy.min_ontology_score);
  if (Number.isFinite(scoreThreshold) && scoreThreshold > 0) {
    const qualityScore = Number(ontology.quality_score);
    if (!Number.isFinite(qualityScore)) {
      reasons.push('ontology_quality_score unavailable');
    } else if (qualityScore < scoreThreshold) {
      reasons.push(`ontology_quality_score ${qualityScore} < required ${scoreThreshold}`);
    }
  }

  if (Number.isInteger(policy.max_unmapped_rules)) {
    const unmapped = Number(
      ontology && ontology.metrics ? ontology.metrics.business_rule_unmapped : null
    );
    if (!Number.isFinite(unmapped)) {
      reasons.push('ontology business_rule_unmapped unavailable');
    } else if (unmapped > policy.max_unmapped_rules) {
      reasons.push(`ontology business_rule_unmapped ${unmapped} > allowed ${policy.max_unmapped_rules}`);
    }
  }

  if (Number.isInteger(policy.max_undecided_decisions)) {
    const undecided = Number(
      ontology && ontology.metrics ? ontology.metrics.decision_undecided : null
    );
    if (!Number.isFinite(undecided)) {
      reasons.push('ontology decision_undecided unavailable');
    } else if (undecided > policy.max_undecided_decisions) {
      reasons.push(`ontology decision_undecided ${undecided} > allowed ${policy.max_undecided_decisions}`);
    }
  }

  return reasons;
}

function evaluateAutoHandoffMoquiBaselineGateReasons(policy = {}, moquiBaseline = null) {
  const reasons = [];
  if (policy.require_moqui_baseline !== true) {
    return reasons;
  }

  const baseline = moquiBaseline && typeof moquiBaseline === 'object'
    ? moquiBaseline
    : null;
  const summary = baseline && baseline.summary && typeof baseline.summary === 'object'
    ? baseline.summary
    : {};
  const status = `${baseline && baseline.status ? baseline.status : 'missing'}`.trim().toLowerCase();
  if (!baseline || baseline.generated !== true) {
    const reason = baseline && baseline.reason ? baseline.reason : 'moqui baseline snapshot missing';
    reasons.push(`moqui baseline unavailable: ${reason}`);
    return reasons;
  }
  if (status === 'error') {
    reasons.push(`moqui baseline errored: ${baseline.error || 'unknown error'}`);
    return reasons;
  }
  if (summary.portfolio_passed !== true) {
    const avgScore = Number(summary.avg_score);
    const validRate = Number(summary.valid_rate_percent);
    reasons.push(
      `moqui baseline portfolio not passed (avg_score=${Number.isFinite(avgScore) ? avgScore : 'n/a'}, ` +
      `valid_rate=${Number.isFinite(validRate) ? `${validRate}%` : 'n/a'})`
    );
  }
  return reasons;
}

function evaluateAutoHandoffScenePackageBatchGateReasons(policy = {}, scenePackageBatch = null) {
  const reasons = [];
  if (policy.require_scene_package_batch !== true) {
    return reasons;
  }

  const batch = scenePackageBatch && typeof scenePackageBatch === 'object'
    ? scenePackageBatch
    : null;
  if (!batch) {
    reasons.push('scene package publish-batch dry-run snapshot missing');
    return reasons;
  }
  if (batch.status === 'skipped') {
    return reasons;
  }
  if (batch.status === 'error') {
    reasons.push(`scene package publish-batch dry-run errored: ${batch.error || 'unknown error'}`);
    return reasons;
  }
  if (batch.status !== 'passed') {
    const summary = batch.summary && typeof batch.summary === 'object' ? batch.summary : {};
    const selected = Number(summary.selected);
    const failed = Number(summary.failed);
    const batchGatePassed = summary.batch_gate_passed === true;
    reasons.push(
      `scene package publish-batch dry-run failed (selected=${Number.isFinite(selected) ? selected : 'n/a'}, ` +
      `failed=${Number.isFinite(failed) ? failed : 'n/a'}, batch_gate=${batchGatePassed ? 'pass' : 'fail'})`
    );
  }
  return reasons;
}

function evaluateAutoHandoffCapabilityCoverageGateReasons(policy = {}, capabilityCoverage = null) {
  const reasons = [];
  if (policy.require_capability_coverage !== true) {
    return reasons;
  }

  const coverage = capabilityCoverage && typeof capabilityCoverage === 'object'
    ? capabilityCoverage
    : null;
  if (!coverage) {
    reasons.push('capability coverage snapshot missing');
    return reasons;
  }
  if (coverage.status === 'error') {
    reasons.push(`capability coverage errored: ${coverage.error || 'unknown error'}`);
    return reasons;
  }
  if (coverage.status === 'skipped') {
    const totalCapabilities = Number(
      coverage &&
      coverage.summary &&
      coverage.summary.total_capabilities !== undefined
        ? coverage.summary.total_capabilities
        : 0
    );
    if (Number.isFinite(totalCapabilities) && totalCapabilities <= 0) {
      return reasons;
    }
    reasons.push(`capability coverage skipped: ${coverage.reason || 'unknown reason'}`);
    return reasons;
  }

  const summary = coverage.summary && typeof coverage.summary === 'object'
    ? coverage.summary
    : {};
  const coveragePercent = Number(summary.coverage_percent);
  const minCoverage = Number(policy.min_capability_coverage_percent);
  if (!Number.isFinite(coveragePercent)) {
    reasons.push('capability_coverage_percent unavailable');
  } else if (Number.isFinite(minCoverage) && coveragePercent < minCoverage) {
    reasons.push(`capability_coverage_percent ${coveragePercent} < required ${minCoverage}`);
  }
  return reasons;
}

function collectHandoffBlockers(resultItem) {
  const blockers = [];
  if (!resultItem) {
    return blockers;
  }
  if (typeof resultItem.error === 'string' && resultItem.error.trim().length > 0) {
    blockers.push(resultItem.error.trim());
  }
  const status = typeof resultItem.status === 'string' ? resultItem.status.trim().toLowerCase() : 'unknown';
  if (status !== 'completed' && blockers.length === 0) {
    blockers.push(`close-loop-batch status: ${status || 'unknown'}`);
  }
  return blockers;
}

function buildAutoHandoffSpecStatus(handoffSpecs = [], batchSummary = null, baselineSummary = null) {
  const specs = Array.isArray(handoffSpecs)
    ? handoffSpecs.map(item => `${item || ''}`.trim()).filter(Boolean)
    : [];
  const results = Array.isArray(batchSummary && batchSummary.results) ? batchSummary.results : [];
  const baselineResults = Array.isArray(baselineSummary && baselineSummary.results) ? baselineSummary.results : [];

  const statuses = specs.map(specName => {
    const expectedPrefix = `integrate handoff spec ${specName}`.toLowerCase();
    const currentResult = results.find(item => {
      const goal = `${item && item.goal ? item.goal : ''}`.trim().toLowerCase();
      return goal.startsWith(expectedPrefix);
    }) || null;
    const baselineResult = currentResult ? null : baselineResults.find(item => {
      const goal = `${item && item.goal ? item.goal : ''}`.trim().toLowerCase();
      return goal.startsWith(expectedPrefix);
    }) || null;
    const effectiveResult = currentResult || baselineResult;
    const status = effectiveResult && typeof effectiveResult.status === 'string'
      ? effectiveResult.status
      : 'missing';
    const blockers = effectiveResult
      ? collectHandoffBlockers(effectiveResult)
      : ['missing close-loop-batch result for spec integration goal'];
    const success = status === 'completed';
    return {
      spec: specName,
      status,
      success,
      blockers,
      source: currentResult
        ? 'current-run'
        : (baselineResult ? 'continued-from' : 'missing')
    };
  });

  const total = statuses.length;
  const successful = statuses.filter(item => item.success).length;
  const blocked = statuses.filter(item => item.blockers.length > 0).length;
  const successRate = total > 0
    ? Number(((successful / total) * 100).toFixed(2))
    : 100;

  return {
    total_specs: total,
    successful_specs: successful,
    blocked_specs: blocked,
    success_rate_percent: successRate,
    items: statuses
  };
}

function evaluateAutoHandoffRunGates(context = {}) {
  const policy = context.policy || {
    min_spec_success_rate: 100,
    max_risk_level: 'high',
    min_ontology_score: 0,
    max_unmapped_rules: null,
    max_undecided_decisions: null,
    require_ontology_validation: true,
    require_scene_package_batch: true
  };
  const dryRun = Boolean(context.dryRun);
  const specStatus = context.specStatus || {
    success_rate_percent: 100
  };
  const ontology = context.ontology || {
    present: false,
    passed: false
  };
  const moquiBaseline = context.moquiBaseline && typeof context.moquiBaseline === 'object'
    ? context.moquiBaseline
    : null;
  const scenePackageBatch = context.scenePackageBatch && typeof context.scenePackageBatch === 'object'
    ? context.scenePackageBatch
    : null;
  const capabilityCoverage = context.capabilityCoverage && typeof context.capabilityCoverage === 'object'
    ? context.capabilityCoverage
    : null;
  const kpi = context.programKpi || {
    risk_level: 'high'
  };
  const riskLevel = `${kpi.risk_level || 'high'}`.trim().toLowerCase();
  const riskRank = {
    low: 1,
    medium: 2,
    high: 3
  };

  const reasons = [];
  if (!dryRun) {
    const successRate = Number(specStatus.success_rate_percent);
    if (!Number.isFinite(successRate)) {
      reasons.push('spec_success_rate_percent unavailable');
    } else if (successRate < policy.min_spec_success_rate) {
      reasons.push(`spec_success_rate_percent ${successRate} < required ${policy.min_spec_success_rate}`);
    }

    if ((riskRank[riskLevel] || 3) > (riskRank[policy.max_risk_level] || 3)) {
      reasons.push(`risk_level ${riskLevel} exceeds allowed ${policy.max_risk_level}`);
    }
  }

  reasons.push(...evaluateAutoHandoffOntologyGateReasons(policy, ontology));
  reasons.push(...evaluateAutoHandoffMoquiBaselineGateReasons(policy, moquiBaseline));
  reasons.push(...evaluateAutoHandoffScenePackageBatchGateReasons(policy, scenePackageBatch));
  reasons.push(...evaluateAutoHandoffCapabilityCoverageGateReasons(policy, capabilityCoverage));

  return {
    passed: reasons.length === 0,
    dry_run: dryRun,
    policy,
    actual: {
      spec_success_rate_percent: Number(specStatus.success_rate_percent),
      risk_level: riskLevel,
      ontology_validation_present: Boolean(ontology.present),
      ontology_validation_passed: Boolean(ontology.passed),
      ontology_validation_status: ontology.status || null,
      ontology_quality_score: Number.isFinite(Number(ontology.quality_score))
        ? Number(ontology.quality_score)
        : null,
      ontology_business_rule_unmapped: Number.isFinite(
        Number(ontology && ontology.metrics ? ontology.metrics.business_rule_unmapped : null)
      )
        ? Number(ontology.metrics.business_rule_unmapped)
        : null,
      ontology_decision_undecided: Number.isFinite(
        Number(ontology && ontology.metrics ? ontology.metrics.decision_undecided : null)
      )
        ? Number(ontology.metrics.decision_undecided)
        : null,
      ontology_business_rule_pass_rate_percent: Number.isFinite(
        Number(ontology && ontology.metrics ? ontology.metrics.business_rule_pass_rate_percent : null)
      )
        ? Number(ontology.metrics.business_rule_pass_rate_percent)
        : null,
      ontology_decision_resolved_rate_percent: Number.isFinite(
        Number(ontology && ontology.metrics ? ontology.metrics.decision_resolved_rate_percent : null)
      )
        ? Number(ontology.metrics.decision_resolved_rate_percent)
        : null,
      moqui_baseline_status: normalizeHandoffText(moquiBaseline && moquiBaseline.status),
      moqui_baseline_portfolio_passed: Boolean(
        moquiBaseline &&
        moquiBaseline.summary &&
        moquiBaseline.summary.portfolio_passed === true
      ),
      scene_package_batch_status: normalizeHandoffText(scenePackageBatch && scenePackageBatch.status),
      scene_package_batch_passed: Boolean(scenePackageBatch && scenePackageBatch.status === 'passed'),
      capability_coverage_status: normalizeHandoffText(capabilityCoverage && capabilityCoverage.status),
      capability_coverage_percent: Number.isFinite(
        Number(capabilityCoverage && capabilityCoverage.summary ? capabilityCoverage.summary.coverage_percent : null)
      )
        ? Number(capabilityCoverage.summary.coverage_percent)
        : null
    },
    reasons
  };
}

function buildAutoHandoffRunRecommendations(projectPath, result) {
  const recommendations = [];
  const seen = new Set();
  const push = value => {
    const text = `${value || ''}`.trim();
    if (!text || seen.has(text)) {
      return;
    }
    seen.add(text);
    recommendations.push(text);
  };

  const manifestPath = typeof result.manifest_path === 'string' && result.manifest_path.trim().length > 0
    ? result.manifest_path
    : null;
  const manifestCli = manifestPath
    ? quoteCliArg(toAutoHandoffCliPath(projectPath, manifestPath))
    : '<manifest>';
  const summary = result && result.batch_summary && typeof result.batch_summary === 'object'
    ? result.batch_summary
    : null;
  const totalGoals = Number(summary && summary.total_goals) || 0;
  const processedGoals = Number(summary && summary.processed_goals) || 0;
  const failedGoals = Number(summary && summary.failed_goals) || 0;
  const hasPendingOrFailed = totalGoals > 0 && (failedGoals > 0 || processedGoals < totalGoals);

  if (manifestPath && result.session_id && hasPendingOrFailed) {
    push(
      `kse auto handoff run --manifest ${manifestCli} ` +
      `--continue-from ${quoteCliArg(result.session_id)} --continue-strategy auto --json`
    );
  }

  if (
    result.status === 'failed' &&
    typeof result.error === 'string' &&
    result.error.toLowerCase().includes('ontology validation gate failed') &&
    manifestPath
  ) {
    push(
      `Ensure manifest ontology_validation is present and passed, then rerun: ` +
      `kse auto handoff run --manifest ${manifestCli} --json`
    );
    if (result.error.toLowerCase().includes('ontology_quality_score')) {
      push(`kse auto handoff run --manifest ${manifestCli} --min-ontology-score 80 --json`);
    }
    if (result.error.toLowerCase().includes('business_rule_unmapped')) {
      push(`kse auto handoff run --manifest ${manifestCli} --max-unmapped-rules 0 --json`);
    }
    if (result.error.toLowerCase().includes('decision_undecided')) {
      push(`kse auto handoff run --manifest ${manifestCli} --max-undecided-decisions 0 --json`);
    }
  }

  const gateActual = result && result.gates && result.gates.actual ? result.gates.actual : {};
  const ontologyScore = Number(gateActual.ontology_quality_score);
  if (manifestPath && Number.isFinite(ontologyScore) && ontologyScore < 80) {
    push(`kse auto handoff run --manifest ${manifestCli} --min-ontology-score 80 --json`);
  }
  const unmappedRules = Number(gateActual.ontology_business_rule_unmapped);
  if (manifestPath && Number.isFinite(unmappedRules) && unmappedRules > 0) {
    push(`kse auto handoff run --manifest ${manifestCli} --max-unmapped-rules 0 --json`);
  }
  const undecidedDecisions = Number(gateActual.ontology_decision_undecided);
  if (manifestPath && Number.isFinite(undecidedDecisions) && undecidedDecisions > 0) {
    push(`kse auto handoff run --manifest ${manifestCli} --max-undecided-decisions 0 --json`);
  }

  if (result.template_diff && result.template_diff.compatibility === 'needs-sync' && manifestPath) {
    push(`kse auto handoff template-diff --manifest ${manifestCli} --json`);
  }

  if (result.session_id) {
    push(`kse auto handoff regression --session-id ${quoteCliArg(result.session_id)} --json`);
  }

  const riskLevel = result && result.gates && result.gates.actual && typeof result.gates.actual.risk_level === 'string'
    ? result.gates.actual.risk_level.trim().toLowerCase()
    : null;
  if (riskLevel === 'high') {
    push('kse auto governance stats --days 14 --json');
  }

  if (result && result.remediation_queue && result.remediation_queue.file) {
    push(
      `kse auto close-loop-batch ${quoteCliArg(
        toAutoHandoffCliPath(projectPath, result.remediation_queue.file)
      )} --format lines --json`
    );
  }

  const moquiBaseline = result && result.moqui_baseline && typeof result.moqui_baseline === 'object'
    ? result.moqui_baseline
    : null;
  const moquiSummary = moquiBaseline && moquiBaseline.summary && typeof moquiBaseline.summary === 'object'
    ? moquiBaseline.summary
    : null;
  if (moquiBaseline && moquiBaseline.status === 'error') {
    push('kse scene moqui-baseline --json');
  } else if (moquiSummary && moquiSummary.portfolio_passed === false) {
    push(
      'kse scene moqui-baseline --include-all ' +
      '--compare-with .kiro/reports/release-evidence/moqui-template-baseline.json --json'
    );
    push(
      'kse scene package-publish-batch --manifest docs/handoffs/handoff-manifest.json ' +
      '--dry-run --ontology-task-queue-out .kiro/auto/ontology-remediation.lines --json'
    );
  }

  const scenePackageBatch = result && result.scene_package_batch && typeof result.scene_package_batch === 'object'
    ? result.scene_package_batch
    : null;
  if (
    scenePackageBatch &&
    scenePackageBatch.status &&
    ['failed', 'error'].includes(`${scenePackageBatch.status}`.toLowerCase())
  ) {
    push(
      `kse scene package-publish-batch --manifest ${manifestCli} ` +
      '--dry-run --ontology-task-queue-out .kiro/auto/ontology-remediation.lines --json'
    );
  }

  const capabilityCoverage = result && result.moqui_capability_coverage && typeof result.moqui_capability_coverage === 'object'
    ? result.moqui_capability_coverage
    : null;
  const capabilitySummary = capabilityCoverage && capabilityCoverage.summary && typeof capabilityCoverage.summary === 'object'
    ? capabilityCoverage.summary
    : null;
  const capabilityNormalization = capabilityCoverage && capabilityCoverage.normalization && typeof capabilityCoverage.normalization === 'object'
    ? capabilityCoverage.normalization
    : null;
  if (capabilityCoverage && capabilityCoverage.status === 'error') {
    push('declare manifest capabilities and rerun `kse auto handoff run` to rebuild capability coverage evidence');
  } else if (capabilitySummary && capabilitySummary.passed === false) {
    push('complete uncovered moqui capabilities and rerun `kse auto handoff run --json`');
  } else if (capabilityCoverage && capabilityCoverage.status === 'skipped') {
    push('declare `capabilities` in handoff manifest to enable machine-checkable moqui capability coverage');
  }
  if (
    capabilityNormalization &&
    Array.isArray(capabilityNormalization.expected_deprecated_aliases) &&
    capabilityNormalization.expected_deprecated_aliases.length > 0
  ) {
    push('replace deprecated manifest capabilities with canonical Moqui capability ids and rerun `kse auto handoff run --json`');
  }

  return recommendations;
}

function buildAutoHandoffRunSessionId() {
  const now = new Date();
  const stamp = [
    now.getUTCFullYear(),
    `${now.getUTCMonth() + 1}`.padStart(2, '0'),
    `${now.getUTCDate()}`.padStart(2, '0'),
    `${now.getUTCHours()}`.padStart(2, '0'),
    `${now.getUTCMinutes()}`.padStart(2, '0'),
    `${now.getUTCSeconds()}`.padStart(2, '0')
  ].join('');
  const suffix = Math.floor(Math.random() * 100000)
    .toString()
    .padStart(5, '0');
  return `handoff-${stamp}-${suffix}`;
}

function beginAutoHandoffRunPhase(result, id, title) {
  const phase = {
    id,
    title,
    status: 'running',
    started_at: new Date().toISOString(),
    completed_at: null,
    elapsed_ms: null
  };
  result.phases.push(phase);
  return {
    phase,
    startedAt: Date.now()
  };
}

function completeAutoHandoffRunPhase(phaseState, details = null) {
  phaseState.phase.status = 'completed';
  if (details && typeof details === 'object') {
    phaseState.phase.details = details;
  }
  phaseState.phase.completed_at = new Date().toISOString();
  phaseState.phase.elapsed_ms = Math.max(0, Date.now() - phaseState.startedAt);
}

function failAutoHandoffRunPhase(phaseState, error) {
  phaseState.phase.status = 'failed';
  phaseState.phase.error = error && error.message ? error.message : `${error}`;
  phaseState.phase.completed_at = new Date().toISOString();
  phaseState.phase.elapsed_ms = Math.max(0, Date.now() - phaseState.startedAt);
}

function skipAutoHandoffRunPhase(result, id, title, reason) {
  result.phases.push({
    id,
    title,
    status: 'skipped',
    reason,
    started_at: new Date().toISOString(),
    completed_at: new Date().toISOString(),
    elapsed_ms: 0
  });
}

function buildAutoHandoffReleaseEvidenceEntry(projectPath, result, reportFile = null, trendWindow = null) {
  const toNumber = value => {
    const parsed = Number(value);
    return Number.isFinite(parsed) ? parsed : null;
  };

  const gate = result && result.gates && typeof result.gates === 'object'
    ? result.gates
    : {};
  const gateActual = gate && gate.actual && typeof gate.actual === 'object'
    ? gate.actual
    : {};
  const ontology = result && result.ontology_validation && typeof result.ontology_validation === 'object'
    ? result.ontology_validation
    : {};
  const ontologyMetrics = ontology && ontology.metrics && typeof ontology.metrics === 'object'
    ? ontology.metrics
    : {};
  const regression = result && result.regression && typeof result.regression === 'object'
    ? result.regression
    : {};
  const regressionDelta = regression && regression.delta && typeof regression.delta === 'object'
    ? regression.delta
    : {};
  const moquiBaseline = result && result.moqui_baseline && typeof result.moqui_baseline === 'object'
    ? result.moqui_baseline
    : {};
  const moquiSummary = moquiBaseline && moquiBaseline.summary && typeof moquiBaseline.summary === 'object'
    ? moquiBaseline.summary
    : {};
  const moquiCompare = moquiBaseline && moquiBaseline.compare && typeof moquiBaseline.compare === 'object'
    ? moquiBaseline.compare
    : {};
  const moquiDeltas = moquiCompare && moquiCompare.deltas && typeof moquiCompare.deltas === 'object'
    ? moquiCompare.deltas
    : {};
  const moquiFailedTemplates = moquiCompare && moquiCompare.failed_templates && typeof moquiCompare.failed_templates === 'object'
    ? moquiCompare.failed_templates
    : {};
  const scenePackageBatch = result && result.scene_package_batch && typeof result.scene_package_batch === 'object'
    ? result.scene_package_batch
    : {};
  const scenePackageBatchSummary = scenePackageBatch && scenePackageBatch.summary && typeof scenePackageBatch.summary === 'object'
    ? scenePackageBatch.summary
    : {};
  const scenePackageBatchGate = scenePackageBatch && scenePackageBatch.batch_ontology_gate && typeof scenePackageBatch.batch_ontology_gate === 'object'
    ? scenePackageBatch.batch_ontology_gate
    : {};
  const capabilityCoverage = result && result.moqui_capability_coverage && typeof result.moqui_capability_coverage === 'object'
    ? result.moqui_capability_coverage
    : {};
  const capabilitySummary = capabilityCoverage && capabilityCoverage.summary && typeof capabilityCoverage.summary === 'object'
    ? capabilityCoverage.summary
    : {};
  const capabilityCompare = capabilityCoverage && capabilityCoverage.compare && typeof capabilityCoverage.compare === 'object'
    ? capabilityCoverage.compare
    : {};
  const capabilityGaps = Array.isArray(capabilityCoverage && capabilityCoverage.gaps)
    ? capabilityCoverage.gaps
    : [];
  const capabilityNormalization = capabilityCoverage && capabilityCoverage.normalization && typeof capabilityCoverage.normalization === 'object'
    ? capabilityCoverage.normalization
    : {};
  const capabilityWarnings = Array.isArray(capabilityCoverage && capabilityCoverage.warnings)
    ? capabilityCoverage.warnings
    : [];
  const batchSummary = result && result.batch_summary && typeof result.batch_summary === 'object'
    ? result.batch_summary
    : {};
  const reportPath = typeof reportFile === 'string' && reportFile.trim().length > 0
    ? reportFile.trim()
    : (
      result && typeof result.output_file === 'string' && result.output_file.trim().length > 0
        ? result.output_file.trim()
        : null
    );

  return {
    session_id: result && result.session_id ? result.session_id : null,
    merged_at: new Date().toISOString(),
    status: result && result.status ? result.status : null,
    dry_run: Boolean(result && result.dry_run),
    manifest_path: result && result.manifest_path ? result.manifest_path : null,
    source_project: result && result.source_project ? result.source_project : null,
    handoff_report_file: reportPath ? toAutoHandoffCliPath(projectPath, reportPath) : null,
    gate: {
      passed: gate.passed === true,
      reasons: Array.isArray(gate.reasons) ? gate.reasons : [],
      actual: {
        spec_success_rate_percent: toNumber(gateActual.spec_success_rate_percent),
        risk_level: normalizeHandoffText(gateActual.risk_level),
        ontology_quality_score: toNumber(gateActual.ontology_quality_score),
        ontology_business_rule_unmapped: toNumber(gateActual.ontology_business_rule_unmapped),
        ontology_decision_undecided: toNumber(gateActual.ontology_decision_undecided)
      }
    },
    ontology_validation: {
      status: normalizeHandoffText(ontology.status),
      passed: ontology.passed === true,
      quality_score: toNumber(ontology.quality_score),
      metrics: {
        entity_total: toNumber(ontologyMetrics.entity_total),
        relation_total: toNumber(ontologyMetrics.relation_total),
        business_rule_total: toNumber(ontologyMetrics.business_rule_total),
        business_rule_mapped: toNumber(ontologyMetrics.business_rule_mapped),
        business_rule_unmapped: toNumber(ontologyMetrics.business_rule_unmapped),
        decision_total: toNumber(ontologyMetrics.decision_total),
        decision_resolved: toNumber(ontologyMetrics.decision_resolved),
        decision_undecided: toNumber(ontologyMetrics.decision_undecided),
        business_rule_pass_rate_percent: toNumber(ontologyMetrics.business_rule_pass_rate_percent),
        decision_resolved_rate_percent: toNumber(ontologyMetrics.decision_resolved_rate_percent)
      }
    },
    regression: {
      trend: normalizeHandoffText(regression.trend),
      delta: {
        spec_success_rate_percent: toNumber(regressionDelta.spec_success_rate_percent),
        risk_level_rank: toNumber(regressionDelta.risk_level_rank),
        failed_goals: toNumber(regressionDelta.failed_goals),
        ontology_quality_score: toNumber(regressionDelta.ontology_quality_score),
        ontology_unmapped_rules: toNumber(regressionDelta.ontology_unmapped_rules),
        ontology_undecided_decisions: toNumber(regressionDelta.ontology_undecided_decisions)
      }
    },
    moqui_baseline: {
      status: normalizeHandoffText(moquiBaseline.status),
      generated: moquiBaseline.generated === true,
      reason: normalizeHandoffText(moquiBaseline.reason),
      error: normalizeHandoffText(moquiBaseline.error),
      summary: {
        total_templates: toNumber(moquiSummary.total_templates),
        scoped_templates: toNumber(moquiSummary.scoped_templates),
        avg_score: toNumber(moquiSummary.avg_score),
        valid_rate_percent: toNumber(moquiSummary.valid_rate_percent),
        baseline_passed: toNumber(moquiSummary.baseline_passed),
        baseline_failed: toNumber(moquiSummary.baseline_failed),
        portfolio_passed: moquiSummary.portfolio_passed === true
      },
      compare: Object.keys(moquiCompare).length === 0
        ? null
        : {
          previous_generated_at: normalizeHandoffText(moquiCompare.previous_generated_at),
          previous_template_root: normalizeHandoffText(moquiCompare.previous_template_root),
          deltas: {
            scoped_templates: toNumber(moquiDeltas.scoped_templates),
            avg_score: toNumber(moquiDeltas.avg_score),
            valid_rate_percent: toNumber(moquiDeltas.valid_rate_percent),
            baseline_passed: toNumber(moquiDeltas.baseline_passed),
            baseline_failed: toNumber(moquiDeltas.baseline_failed)
          },
          failed_templates: {
            newly_failed: Array.isArray(moquiFailedTemplates.newly_failed) ? moquiFailedTemplates.newly_failed : [],
            recovered: Array.isArray(moquiFailedTemplates.recovered) ? moquiFailedTemplates.recovered : []
          }
        },
      output: {
        json: normalizeHandoffText(moquiBaseline && moquiBaseline.output ? moquiBaseline.output.json : null),
        markdown: normalizeHandoffText(moquiBaseline && moquiBaseline.output ? moquiBaseline.output.markdown : null)
      }
    },
    scene_package_batch: {
      status: normalizeHandoffText(scenePackageBatch.status),
      generated: scenePackageBatch.generated === true,
      reason: normalizeHandoffText(scenePackageBatch.reason),
      error: normalizeHandoffText(scenePackageBatch.error),
      summary: {
        selected: toNumber(scenePackageBatchSummary.selected),
        failed: toNumber(scenePackageBatchSummary.failed),
        skipped: toNumber(scenePackageBatchSummary.skipped),
        batch_gate_passed: scenePackageBatchSummary.batch_gate_passed === true,
        batch_gate_failure_count: toNumber(scenePackageBatchSummary.batch_gate_failure_count),
        ontology_average_score: toNumber(scenePackageBatchSummary.ontology_average_score),
        ontology_valid_rate_percent: toNumber(scenePackageBatchSummary.ontology_valid_rate_percent)
      },
      batch_ontology_gate: {
        passed: scenePackageBatchGate.passed === true,
        failures: Array.isArray(scenePackageBatchGate.failures) ? scenePackageBatchGate.failures : []
      },
      output: {
        json: normalizeHandoffText(scenePackageBatch && scenePackageBatch.output ? scenePackageBatch.output.json : null)
      }
    },
    capability_coverage: {
      status: normalizeHandoffText(capabilityCoverage.status),
      generated: capabilityCoverage.generated === true,
      reason: normalizeHandoffText(capabilityCoverage.reason),
      error: normalizeHandoffText(capabilityCoverage.error),
      summary: {
        total_capabilities: toNumber(capabilitySummary.total_capabilities),
        covered_capabilities: toNumber(capabilitySummary.covered_capabilities),
        uncovered_capabilities: toNumber(capabilitySummary.uncovered_capabilities),
        coverage_percent: toNumber(capabilitySummary.coverage_percent),
        min_required_percent: toNumber(capabilitySummary.min_required_percent),
        passed: capabilitySummary.passed === true
      },
      compare: Object.keys(capabilityCompare).length === 0
        ? null
        : {
          previous_generated_at: normalizeHandoffText(capabilityCompare.previous_generated_at),
          delta_coverage_percent: toNumber(capabilityCompare.delta_coverage_percent),
          delta_covered_capabilities: toNumber(capabilityCompare.delta_covered_capabilities),
          newly_covered: Array.isArray(capabilityCompare.newly_covered) ? capabilityCompare.newly_covered : [],
          newly_uncovered: Array.isArray(capabilityCompare.newly_uncovered) ? capabilityCompare.newly_uncovered : []
        },
      normalization: {
        lexicon_version: normalizeHandoffText(capabilityNormalization.lexicon_version),
        expected_alias_mapped: Array.isArray(capabilityNormalization.expected_alias_mapped) ? capabilityNormalization.expected_alias_mapped : [],
        expected_deprecated_aliases: Array.isArray(capabilityNormalization.expected_deprecated_aliases) ? capabilityNormalization.expected_deprecated_aliases : [],
        expected_unknown: Array.isArray(capabilityNormalization.expected_unknown) ? capabilityNormalization.expected_unknown : [],
        provided_alias_mapped: Array.isArray(capabilityNormalization.provided_alias_mapped) ? capabilityNormalization.provided_alias_mapped : [],
        provided_deprecated_aliases: Array.isArray(capabilityNormalization.provided_deprecated_aliases) ? capabilityNormalization.provided_deprecated_aliases : [],
        provided_unknown: Array.isArray(capabilityNormalization.provided_unknown) ? capabilityNormalization.provided_unknown : []
      },
      gaps: capabilityGaps,
      warnings: capabilityWarnings,
      output: {
        json: normalizeHandoffText(capabilityCoverage && capabilityCoverage.output ? capabilityCoverage.output.json : null),
        markdown: normalizeHandoffText(capabilityCoverage && capabilityCoverage.output ? capabilityCoverage.output.markdown : null)
      }
    },
    batch_summary: {
      status: normalizeHandoffText(batchSummary.status),
      total_goals: toNumber(batchSummary.total_goals),
      processed_goals: toNumber(batchSummary.processed_goals),
      completed_goals: toNumber(batchSummary.completed_goals),
      failed_goals: toNumber(batchSummary.failed_goals)
    },
    continued_from: result && result.continued_from ? result.continued_from : null,
    trend_window: trendWindow && typeof trendWindow === 'object'
      ? trendWindow
      : null
  };
}

async function mergeAutoHandoffRunIntoReleaseEvidence(projectPath, result, reportFile = null) {
  const evidenceFile = path.join(projectPath, AUTO_HANDOFF_RELEASE_EVIDENCE_FILE);
  const nowIso = new Date().toISOString();
  let existing = null;
  if (await fs.pathExists(evidenceFile)) {
    try {
      existing = await fs.readJson(evidenceFile);
    } catch (error) {
      throw new Error(`failed to read release evidence JSON: ${evidenceFile} (${error.message})`);
    }
  }

  const existingSessions = existing && Array.isArray(existing.sessions)
    ? existing.sessions.filter(item => item && typeof item === 'object')
    : [];
  let trendWindow = null;
  const trendWindowSize = Number(
    result &&
    result.policy &&
    result.policy.release_evidence_window !== undefined &&
    result.policy.release_evidence_window !== null
      ? result.policy.release_evidence_window
      : 5
  );
  if (Number.isInteger(trendWindowSize) && trendWindowSize >= 2 && trendWindowSize <= 50) {
    try {
      const regressionSnapshot = await buildAutoHandoffRegressionReport(projectPath, {
        sessionId: result && result.session_id ? result.session_id : 'latest',
        window: trendWindowSize
      });
      trendWindow = {
        generated_at: nowIso,
        window: regressionSnapshot.window || {
          requested: trendWindowSize,
          actual: null
        },
        trend: normalizeHandoffText(regressionSnapshot.trend),
        window_trend: regressionSnapshot.window_trend || null,
        aggregates: regressionSnapshot.aggregates || null,
        risk_layers: regressionSnapshot.risk_layers || null
      };
    } catch (error) {
      trendWindow = {
        generated_at: nowIso,
        window: {
          requested: trendWindowSize,
          actual: null
        },
        error: error && error.message ? error.message : `${error}`
      };
    }
  }

  const nextEntry = buildAutoHandoffReleaseEvidenceEntry(projectPath, result, reportFile, trendWindow);
  const sessionId = normalizeHandoffText(nextEntry.session_id);
  let updatedExisting = false;
  const mergedSessions = existingSessions.slice();

  if (sessionId) {
    const existingIndex = mergedSessions.findIndex(item => normalizeHandoffText(item.session_id) === sessionId);
    if (existingIndex >= 0) {
      mergedSessions[existingIndex] = {
        ...mergedSessions[existingIndex],
        ...nextEntry
      };
      updatedExisting = true;
    } else {
      mergedSessions.push(nextEntry);
    }
  } else {
    mergedSessions.push(nextEntry);
  }

  mergedSessions.sort((left, right) => {
    const leftTs = Date.parse(left && (left.merged_at || left.generated_at || left.updated_at) ? (left.merged_at || left.generated_at || left.updated_at) : 0);
    const rightTs = Date.parse(right && (right.merged_at || right.generated_at || right.updated_at) ? (right.merged_at || right.generated_at || right.updated_at) : 0);
    return (Number.isFinite(rightTs) ? rightTs : 0) - (Number.isFinite(leftTs) ? leftTs : 0);
  });

  const generatedAt = existing && typeof existing.generated_at === 'string' && existing.generated_at.trim()
    ? existing.generated_at
    : nowIso;
  const payload = {
    mode: 'auto-handoff-release-evidence',
    generated_at: generatedAt,
    updated_at: nowIso,
    latest_session_id: sessionId || (
      mergedSessions.length > 0 && normalizeHandoffText(mergedSessions[0].session_id)
        ? normalizeHandoffText(mergedSessions[0].session_id)
        : null
    ),
    total_runs: mergedSessions.length,
    latest_trend_window: mergedSessions.length > 0 && mergedSessions[0] && mergedSessions[0].trend_window
      ? mergedSessions[0].trend_window
      : null,
    sessions: mergedSessions
  };

  await fs.ensureDir(path.dirname(evidenceFile));
  await fs.writeJson(evidenceFile, payload, { spaces: 2 });
  return {
    mode: 'auto-handoff-release-evidence',
    merged: true,
    updated_existing: updatedExisting,
    file: evidenceFile,
    latest_session_id: payload.latest_session_id,
    total_runs: payload.total_runs,
    trend_window: nextEntry.trend_window
  };
}

async function writeAutoHandoffRunReport(projectPath, result, outCandidate = null) {
  if (typeof outCandidate === 'string' && outCandidate.trim().length > 0) {
    await maybeWriteOutput(result, outCandidate.trim(), projectPath);
    return;
  }
  const defaultFile = path.join(AUTO_HANDOFF_RUN_REPORT_DIR, `${result.session_id}.json`);
  await maybeWriteOutput(result, defaultFile, projectPath);
}

function buildAutoHandoffMoquiBaselinePhaseDetails(payload) {
  const baseline = payload && typeof payload === 'object' ? payload : {};
  const summary = baseline.summary && typeof baseline.summary === 'object' ? baseline.summary : null;
  return {
    status: baseline.status || 'unknown',
    generated: baseline.generated === true,
    output: baseline.output || null,
    portfolio_passed: summary ? summary.portfolio_passed === true : null,
    avg_score: summary && Number.isFinite(Number(summary.avg_score))
      ? Number(summary.avg_score)
      : null,
    valid_rate_percent: summary && Number.isFinite(Number(summary.valid_rate_percent))
      ? Number(summary.valid_rate_percent)
      : null
  };
}

function parseAutoHandoffJsonFromCommandStdout(stdoutText = '') {
  const text = `${stdoutText || ''}`.trim();
  if (!text) {
    return null;
  }
  try {
    return JSON.parse(text);
  } catch (_error) {
    // continue
  }

  const firstBrace = text.indexOf('{');
  const lastBrace = text.lastIndexOf('}');
  if (firstBrace >= 0 && lastBrace > firstBrace) {
    const candidate = text.slice(firstBrace, lastBrace + 1);
    try {
      return JSON.parse(candidate);
    } catch (_error) {
      return null;
    }
  }
  return null;
}

async function buildAutoHandoffMoquiBaselineSnapshot(projectPath) {
  const scriptPath = path.join(projectPath, 'scripts', 'moqui-template-baseline-report.js');
  if (!(await fs.pathExists(scriptPath))) {
    return {
      status: 'skipped',
      generated: false,
      reason: `baseline script missing: ${toAutoHandoffCliPath(projectPath, scriptPath)}`
    };
  }

  const outputJsonPath = path.join(projectPath, AUTO_HANDOFF_MOQUI_BASELINE_JSON_FILE);
  const outputMarkdownPath = path.join(projectPath, AUTO_HANDOFF_MOQUI_BASELINE_MARKDOWN_FILE);
  await fs.ensureDir(path.dirname(outputJsonPath));

  const scriptArgs = [
    scriptPath,
    '--out', outputJsonPath,
    '--markdown-out', outputMarkdownPath,
    '--json'
  ];

  if (await fs.pathExists(outputJsonPath)) {
    scriptArgs.push('--compare-with', outputJsonPath);
  }

  const execution = spawnSync(process.execPath, scriptArgs, {
    cwd: projectPath,
    encoding: 'utf8'
  });

  const stdout = typeof execution.stdout === 'string' ? execution.stdout.trim() : '';
  const stderr = typeof execution.stderr === 'string' ? execution.stderr.trim() : '';

  if (execution.error) {
    return {
      status: 'error',
      generated: false,
      error: execution.error.message
    };
  }

  if (execution.status !== 0) {
    return {
      status: 'error',
      generated: false,
      error: stderr || stdout || `baseline script exited with code ${execution.status}`
    };
  }

  let reportPayload = null;
  try {
    reportPayload = stdout ? JSON.parse(stdout) : await fs.readJson(outputJsonPath);
  } catch (error) {
    return {
      status: 'error',
      generated: false,
      error: `failed to parse baseline payload: ${error.message}`
    };
  }

  const summary = reportPayload && reportPayload.summary && typeof reportPayload.summary === 'object'
    ? reportPayload.summary
    : {};
  const compare = reportPayload && reportPayload.compare && typeof reportPayload.compare === 'object'
    ? reportPayload.compare
    : null;
  const failedTemplates = compare && compare.failed_templates && typeof compare.failed_templates === 'object'
    ? compare.failed_templates
    : {};

  return {
    status: summary.portfolio_passed === true ? 'passed' : 'failed',
    generated: true,
    summary: {
      total_templates: Number(summary.total_templates) || 0,
      scoped_templates: Number(summary.scoped_templates) || 0,
      avg_score: Number.isFinite(Number(summary.avg_score)) ? Number(summary.avg_score) : null,
      valid_rate_percent: Number.isFinite(Number(summary.valid_rate_percent)) ? Number(summary.valid_rate_percent) : null,
      baseline_passed: Number(summary.baseline_passed) || 0,
      baseline_failed: Number(summary.baseline_failed) || 0,
      portfolio_passed: summary.portfolio_passed === true
    },
    compare: compare
      ? {
        previous_generated_at: compare.previous_generated_at || null,
        previous_template_root: compare.previous_template_root || null,
        deltas: compare.deltas || null,
        failed_templates: {
          previous: Array.isArray(failedTemplates.previous) ? failedTemplates.previous : [],
          current: Array.isArray(failedTemplates.current) ? failedTemplates.current : [],
          newly_failed: Array.isArray(failedTemplates.newly_failed) ? failedTemplates.newly_failed : [],
          recovered: Array.isArray(failedTemplates.recovered) ? failedTemplates.recovered : []
        }
      }
      : null,
    output: {
      json: toAutoHandoffCliPath(projectPath, outputJsonPath),
      markdown: toAutoHandoffCliPath(projectPath, outputMarkdownPath)
    },
    warnings: stderr ? [stderr] : []
  };
}

function buildAutoHandoffScenePackageBatchPhaseDetails(payload) {
  const batch = payload && typeof payload === 'object' ? payload : {};
  const summary = batch.summary && typeof batch.summary === 'object' ? batch.summary : null;
  return {
    status: batch.status || 'unknown',
    generated: batch.generated === true,
    output: batch.output || null,
    selected: summary && Number.isFinite(Number(summary.selected))
      ? Number(summary.selected)
      : null,
    failed: summary && Number.isFinite(Number(summary.failed))
      ? Number(summary.failed)
      : null,
    batch_gate_passed: summary ? summary.batch_gate_passed === true : null
  };
}

async function buildAutoHandoffScenePackageBatchSnapshot(projectPath, manifestPath) {
  const manifestFile = normalizeHandoffText(manifestPath);
  if (!manifestFile) {
    return {
      status: 'skipped',
      generated: false,
      reason: 'manifest path unavailable for scene package batch gate'
    };
  }
  if (!(await fs.pathExists(AUTO_HANDOFF_CLI_SCRIPT_FILE))) {
    return {
      status: 'skipped',
      generated: false,
      reason: `kse cli script missing: ${toAutoHandoffCliPath(projectPath, AUTO_HANDOFF_CLI_SCRIPT_FILE)}`
    };
  }

  const outputJsonPath = path.join(projectPath, AUTO_HANDOFF_SCENE_PACKAGE_BATCH_JSON_FILE);
  const taskQueuePath = path.join(projectPath, AUTO_HANDOFF_SCENE_PACKAGE_BATCH_TASK_QUEUE_FILE);
  await fs.ensureDir(path.dirname(outputJsonPath));

  const execution = spawnSync(
    process.execPath,
    [
      AUTO_HANDOFF_CLI_SCRIPT_FILE,
      'scene',
      'package-publish-batch',
      '--manifest', manifestFile,
      '--dry-run',
      '--ontology-report-out', outputJsonPath,
      '--ontology-task-queue-out', taskQueuePath,
      '--json'
    ],
    {
      cwd: projectPath,
      encoding: 'utf8'
    }
  );

  const stdout = typeof execution.stdout === 'string' ? execution.stdout.trim() : '';
  const stderr = typeof execution.stderr === 'string' ? execution.stderr.trim() : '';

  if (execution.error) {
    return {
      status: 'error',
      generated: false,
      error: execution.error.message
    };
  }

  const payload = parseAutoHandoffJsonFromCommandStdout(stdout);
  if (!payload || typeof payload !== 'object') {
    const missingSpecArray = /manifest spec array (not found|is empty)/i.test(stderr);
    if (missingSpecArray) {
      return {
        status: 'skipped',
        generated: false,
        reason: 'manifest specs are not scene package batch compatible',
        warnings: stderr ? [stderr] : []
      };
    }
    return {
      status: 'error',
      generated: false,
      error: stderr || stdout || `scene package publish-batch exited with code ${execution.status}`,
      warnings: stderr ? [stderr] : []
    };
  }

  const summary = payload.summary && typeof payload.summary === 'object'
    ? payload.summary
    : {};
  const ontologySummary = payload.ontology_summary && typeof payload.ontology_summary === 'object'
    ? payload.ontology_summary
    : {};
  const batchGate = payload.batch_ontology_gate && typeof payload.batch_ontology_gate === 'object'
    ? payload.batch_ontology_gate
    : {};
  const batchGateFailures = Array.isArray(batchGate.failures) ? batchGate.failures : [];
  const selected = Number(summary.selected) || 0;
  const failed = Number(summary.failed) || 0;

  if (selected <= 0 && failed <= 0) {
    return {
      status: 'skipped',
      generated: false,
      reason: 'no scene package publish candidates were selected from handoff manifest',
      summary: {
        selected,
        published: Number(summary.published) || 0,
        planned: Number(summary.planned) || 0,
        failed,
        skipped: Number(summary.skipped) || 0,
        batch_gate_passed: batchGate.passed === true,
        batch_gate_failure_count: batchGateFailures.length
      },
      output: {
        json: toAutoHandoffCliPath(projectPath, outputJsonPath)
      },
      warnings: stderr ? [stderr] : []
    };
  }

  return {
    status: payload.success === true ? 'passed' : 'failed',
    generated: true,
    mode: payload.mode || 'dry-run',
    success: payload.success === true,
    manifest: normalizeHandoffText(payload.manifest),
    summary: {
      selected,
      published: Number(summary.published) || 0,
      planned: Number(summary.planned) || 0,
      failed,
      skipped: Number(summary.skipped) || 0,
      batch_gate_passed: batchGate.passed === true,
      batch_gate_failure_count: batchGateFailures.length,
      ontology_average_score: Number.isFinite(Number(ontologySummary.average_score))
        ? Number(ontologySummary.average_score)
        : null,
      ontology_valid_rate_percent: Number.isFinite(Number(ontologySummary.valid_rate_percent))
        ? Number(ontologySummary.valid_rate_percent)
        : null
    },
    failures: Array.isArray(payload.failures)
      ? payload.failures.map(item => ({
        spec: normalizeHandoffText(item && item.spec),
        error: normalizeHandoffText(item && item.error)
      }))
      : [],
    batch_ontology_gate: {
      passed: batchGate.passed === true,
      failures: batchGateFailures.map(item => ({
        id: normalizeHandoffText(item && item.id),
        message: normalizeHandoffText(item && item.message)
      }))
    },
    task_queue: payload.ontology_task_queue && typeof payload.ontology_task_queue === 'object'
      ? {
        output_path: normalizeHandoffText(payload.ontology_task_queue.output_path),
        task_count: Number(payload.ontology_task_queue.task_count) || 0
      }
      : null,
    output: {
      json: toAutoHandoffCliPath(projectPath, outputJsonPath)
    },
    warnings: stderr ? [stderr] : []
  };
}

function normalizeMoquiCapabilityToken(value) {
  if (value === undefined || value === null) {
    return null;
  }
  const normalized = `${value}`
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
  return normalized.length > 0 ? normalized : null;
}

function buildMoquiCapabilityLexiconIndex(rawLexicon = {}) {
  const aliasToCanonical = new Map();
  const deprecatedAliasToCanonical = new Map();
  const canonicalSet = new Set();
  const entries = Array.isArray(rawLexicon && rawLexicon.capabilities)
    ? rawLexicon.capabilities
    : [];

  for (const entry of entries) {
    const canonical = normalizeMoquiCapabilityToken(entry && entry.canonical);
    if (!canonical) {
      continue;
    }
    canonicalSet.add(canonical);
    aliasToCanonical.set(canonical, canonical);

    const aliases = Array.isArray(entry && entry.aliases) ? entry.aliases : [];
    for (const alias of aliases) {
      const normalizedAlias = normalizeMoquiCapabilityToken(alias);
      if (!normalizedAlias) {
        continue;
      }
      aliasToCanonical.set(normalizedAlias, canonical);
    }

    const deprecatedAliases = Array.isArray(entry && entry.deprecated_aliases)
      ? entry.deprecated_aliases
      : [];
    for (const deprecatedAlias of deprecatedAliases) {
      const normalizedDeprecatedAlias = normalizeMoquiCapabilityToken(deprecatedAlias);
      if (!normalizedDeprecatedAlias) {
        continue;
      }
      aliasToCanonical.set(normalizedDeprecatedAlias, canonical);
      deprecatedAliasToCanonical.set(normalizedDeprecatedAlias, canonical);
    }
  }

  return {
    version: rawLexicon && rawLexicon.version ? `${rawLexicon.version}` : null,
    source: rawLexicon && rawLexicon.source ? `${rawLexicon.source}` : null,
    canonical_set: canonicalSet,
    alias_to_canonical: aliasToCanonical,
    deprecated_alias_to_canonical: deprecatedAliasToCanonical
  };
}

function resolveMoquiCapabilityDescriptor(value, lexiconIndex = MOQUI_CAPABILITY_LEXICON_INDEX) {
  const normalized = normalizeMoquiCapabilityToken(value);
  if (!normalized) {
    return null;
  }

  const aliasToCanonical = lexiconIndex && lexiconIndex.alias_to_canonical instanceof Map
    ? lexiconIndex.alias_to_canonical
    : new Map();
  const deprecatedAliasToCanonical = lexiconIndex && lexiconIndex.deprecated_alias_to_canonical instanceof Map
    ? lexiconIndex.deprecated_alias_to_canonical
    : new Map();
  const canonicalSet = lexiconIndex && lexiconIndex.canonical_set instanceof Set
    ? lexiconIndex.canonical_set
    : new Set();

  const canonical = aliasToCanonical.get(normalized) || normalized;
  const deprecatedCanonical = deprecatedAliasToCanonical.get(normalized) || null;
  const isDeprecatedAlias = Boolean(deprecatedCanonical);
  const isAlias = !isDeprecatedAlias && normalized !== canonical;
  const isKnown = canonicalSet.has(canonical);

  return {
    raw: `${value}`,
    normalized,
    canonical,
    is_known: isKnown,
    is_alias: isAlias,
    is_deprecated_alias: isDeprecatedAlias,
    deprecated_replacement: isDeprecatedAlias ? deprecatedCanonical : null
  };
}

function tokenizeMoquiCapability(value) {
  const normalized = normalizeMoquiCapabilityToken(value);
  if (!normalized) {
    return [];
  }
  return normalized.split('-').map(item => item.trim()).filter(Boolean);
}

function moquiCapabilityMatch(expected, provided) {
  const leftInfo = resolveMoquiCapabilityDescriptor(expected, MOQUI_CAPABILITY_LEXICON_INDEX);
  const rightInfo = resolveMoquiCapabilityDescriptor(provided, MOQUI_CAPABILITY_LEXICON_INDEX);
  const left = leftInfo ? leftInfo.canonical : null;
  const right = rightInfo ? rightInfo.canonical : null;
  if (!left || !right) {
    return false;
  }
  if (leftInfo && rightInfo && leftInfo.is_known && rightInfo.is_known) {
    return left === right;
  }
  if (left === right) {
    return true;
  }
  if ((left.length >= 8 && left.includes(right)) || (right.length >= 8 && right.includes(left))) {
    return true;
  }
  const leftTokens = tokenizeMoquiCapability(left);
  const rightTokens = tokenizeMoquiCapability(right);
  if (leftTokens.length === 0 || rightTokens.length === 0) {
    return false;
  }
  const rightSet = new Set(rightTokens);
  const overlap = leftTokens.filter(item => rightSet.has(item)).length;
  return overlap >= 2;
}

function renderMoquiCapabilityCoverageMarkdown(report = {}) {
  const summary = report.summary && typeof report.summary === 'object'
    ? report.summary
    : {};
  const normalization = report.normalization && typeof report.normalization === 'object'
    ? report.normalization
    : {};
  const warnings = Array.isArray(report.warnings) ? report.warnings : [];
  const coverage = Array.isArray(report.coverage) ? report.coverage : [];
  const compare = report.compare && typeof report.compare === 'object' ? report.compare : null;
  const lines = [
    '# Moqui Capability Coverage Report',
    '',
    `- Generated at: ${report.generated_at || 'n/a'}`,
    `- Expected capabilities: ${summary.total_capabilities !== undefined ? summary.total_capabilities : 'n/a'}`,
    `- Covered capabilities: ${summary.covered_capabilities !== undefined ? summary.covered_capabilities : 'n/a'}`,
    `- Uncovered capabilities: ${summary.uncovered_capabilities !== undefined ? summary.uncovered_capabilities : 'n/a'}`,
    `- Coverage: ${summary.coverage_percent !== undefined && summary.coverage_percent !== null ? `${summary.coverage_percent}%` : 'n/a'}`,
    `- Min required: ${summary.min_required_percent !== undefined && summary.min_required_percent !== null ? `${summary.min_required_percent}%` : 'n/a'}`,
    `- Passed: ${summary.passed === true ? 'yes' : 'no'}`,
    `- Lexicon version: ${normalization.lexicon_version || 'n/a'}`,
    `- Expected alias mapped: ${Array.isArray(normalization.expected_alias_mapped) ? normalization.expected_alias_mapped.length : 0}`,
    `- Expected deprecated alias: ${Array.isArray(normalization.expected_deprecated_aliases) ? normalization.expected_deprecated_aliases.length : 0}`,
    `- Expected unknown: ${Array.isArray(normalization.expected_unknown) ? normalization.expected_unknown.length : 0}`,
    `- Provided alias mapped: ${Array.isArray(normalization.provided_alias_mapped) ? normalization.provided_alias_mapped.length : 0}`,
    `- Provided deprecated alias: ${Array.isArray(normalization.provided_deprecated_aliases) ? normalization.provided_deprecated_aliases.length : 0}`,
    `- Provided unknown: ${Array.isArray(normalization.provided_unknown) ? normalization.provided_unknown.length : 0}`,
    '',
    '## Capability Matrix',
    '',
    '| Capability | Covered | Matched Templates |',
    '| --- | --- | --- |'
  ];

  for (const item of coverage) {
    const matchedTemplates = Array.isArray(item.matched_templates) && item.matched_templates.length > 0
      ? item.matched_templates.join(', ')
      : 'none';
    lines.push(`| ${item.capability} | ${item.covered ? 'yes' : 'no'} | ${matchedTemplates} |`);
  }

  lines.push('');
  lines.push('## Normalization Warnings');
  lines.push('');
  if (warnings.length === 0) {
    lines.push('- none');
  } else {
    for (const warning of warnings) {
      lines.push(`- ${warning}`);
    }
  }

  if (compare) {
    lines.push('');
    lines.push('## Trend vs Previous');
    lines.push('');
    lines.push(`- Previous generated at: ${compare.previous_generated_at || 'n/a'}`);
    lines.push(`- Delta coverage: ${compare.delta_coverage_percent !== null && compare.delta_coverage_percent !== undefined ? `${compare.delta_coverage_percent}%` : 'n/a'}`);
    lines.push(`- Delta covered capabilities: ${compare.delta_covered_capabilities !== null && compare.delta_covered_capabilities !== undefined ? compare.delta_covered_capabilities : 'n/a'}`);
    lines.push(`- Newly covered: ${Array.isArray(compare.newly_covered) && compare.newly_covered.length > 0 ? compare.newly_covered.join(', ') : 'none'}`);
    lines.push(`- Newly uncovered: ${Array.isArray(compare.newly_uncovered) && compare.newly_uncovered.length > 0 ? compare.newly_uncovered.join(', ') : 'none'}`);
  }

  return `${lines.join('\n')}\n`;
}

function buildCapabilityCoverageComparison(currentPayload, previousPayload) {
  const currentSummary = currentPayload && currentPayload.summary ? currentPayload.summary : {};
  const previousSummary = previousPayload && previousPayload.summary ? previousPayload.summary : {};
  const currentCoverage = Array.isArray(currentPayload && currentPayload.coverage) ? currentPayload.coverage : [];
  const previousCoverage = Array.isArray(previousPayload && previousPayload.coverage) ? previousPayload.coverage : [];
  const currentCovered = new Set(
    currentCoverage.filter(item => item && item.covered === true).map(item => item.capability)
  );
  const previousCovered = new Set(
    previousCoverage.filter(item => item && item.covered === true).map(item => item.capability)
  );
  const newlyCovered = Array.from(currentCovered).filter(item => !previousCovered.has(item)).sort();
  const newlyUncovered = Array.from(previousCovered).filter(item => !currentCovered.has(item)).sort();
  const toDelta = (current, previous) => {
    if (!Number.isFinite(Number(current)) || !Number.isFinite(Number(previous))) {
      return null;
    }
    return Number((Number(current) - Number(previous)).toFixed(2));
  };
  return {
    previous_generated_at: previousPayload && previousPayload.generated_at ? previousPayload.generated_at : null,
    delta_coverage_percent: toDelta(currentSummary.coverage_percent, previousSummary.coverage_percent),
    delta_covered_capabilities: toDelta(currentSummary.covered_capabilities, previousSummary.covered_capabilities),
    newly_covered: newlyCovered,
    newly_uncovered: newlyUncovered
  };
}

async function loadLatestMoquiCapabilityCoverageReport(projectPath) {
  const reportPath = path.join(projectPath, AUTO_HANDOFF_MOQUI_CAPABILITY_COVERAGE_JSON_FILE);
  if (!(await fs.pathExists(reportPath))) {
    return null;
  }
  try {
    const payload = await fs.readJson(reportPath);
    return payload && typeof payload === 'object' ? payload : null;
  } catch (_error) {
    return null;
  }
}

async function buildAutoHandoffCapabilityCoverageSnapshot(projectPath, handoff = null, policy = {}) {
  const expectedRaw = Array.isArray(handoff && handoff.capabilities)
    ? handoff.capabilities
    : [];
  const normalization = {
    lexicon_version: MOQUI_CAPABILITY_LEXICON_INDEX && MOQUI_CAPABILITY_LEXICON_INDEX.version
      ? MOQUI_CAPABILITY_LEXICON_INDEX.version
      : null,
    expected_alias_mapped: [],
    expected_deprecated_aliases: [],
    expected_unknown: [],
    provided_alias_mapped: [],
    provided_deprecated_aliases: [],
    provided_unknown: []
  };
  const warnings = [];
  const addNormalizationRecord = (target, descriptor) => {
    const list = Array.isArray(normalization[target]) ? normalization[target] : [];
    const item = {
      raw: descriptor.raw,
      normalized: descriptor.normalized,
      canonical: descriptor.canonical
    };
    const key = `${item.raw}|${item.normalized}|${item.canonical}`;
    if (!list.some(existing => `${existing.raw}|${existing.normalized}|${existing.canonical}` === key)) {
      list.push(item);
    }
    normalization[target] = list;
  };
  const expectedMap = new Map();
  for (const rawCapability of expectedRaw) {
    const descriptor = resolveMoquiCapabilityDescriptor(rawCapability, MOQUI_CAPABILITY_LEXICON_INDEX);
    if (!descriptor) {
      continue;
    }
    if (descriptor.is_alias) {
      addNormalizationRecord('expected_alias_mapped', descriptor);
    }
    if (descriptor.is_deprecated_alias) {
      addNormalizationRecord('expected_deprecated_aliases', descriptor);
      warnings.push(
        `manifest capability "${descriptor.raw}" is deprecated; use "${descriptor.deprecated_replacement || descriptor.canonical}" instead`
      );
    }
    if (!descriptor.is_known) {
      addNormalizationRecord('expected_unknown', descriptor);
      warnings.push(`manifest capability "${descriptor.raw}" is unknown to Moqui lexicon`);
    }
    if (!expectedMap.has(descriptor.canonical)) {
      expectedMap.set(descriptor.canonical, {
        capability: descriptor.canonical,
        source_values: [descriptor.normalized]
      });
    } else {
      const existing = expectedMap.get(descriptor.canonical);
      if (!existing.source_values.includes(descriptor.normalized)) {
        existing.source_values.push(descriptor.normalized);
      }
    }
  }
  const expected = Array.from(expectedMap.keys());
  if (expected.length === 0) {
    return {
      status: 'skipped',
      generated: false,
      reason: 'manifest capabilities not declared',
      summary: {
        total_capabilities: 0,
        covered_capabilities: 0,
        uncovered_capabilities: 0,
        coverage_percent: null,
        min_required_percent: Number(policy.min_capability_coverage_percent),
        passed: true
      },
      coverage: [],
      gaps: [],
      normalization,
      warnings
    };
  }

  const templateRoot = path.join(projectPath, '.kiro', 'templates', 'scene-packages');
  if (!(await fs.pathExists(templateRoot))) {
    return {
      status: 'skipped',
      generated: false,
      reason: `template library not found: ${toAutoHandoffCliPath(projectPath, templateRoot)}`,
      summary: {
        total_capabilities: expected.length,
        covered_capabilities: 0,
        uncovered_capabilities: expected.length,
        coverage_percent: 0,
        min_required_percent: Number(policy.min_capability_coverage_percent),
        passed: false
      },
      coverage: expected.map(item => ({ capability: item, covered: false, matched_templates: [], matched_provides: [], source_values: expectedMap.get(item).source_values })),
      gaps: expected,
      normalization,
      warnings
    };
  }

  const templateEntries = await fs.readdir(templateRoot);
  const templates = [];
  for (const entry of templateEntries) {
    const templateDir = path.join(templateRoot, entry);
    let stat = null;
    try {
      stat = await fs.stat(templateDir);
    } catch (_error) {
      stat = null;
    }
    if (!stat || !stat.isDirectory()) {
      continue;
    }
    const contractFile = path.join(templateDir, 'scene-package.json');
    if (!(await fs.pathExists(contractFile))) {
      continue;
    }
    try {
      const payload = await fs.readJson(contractFile);
      const providesRaw = [];
      const contractProvides = payload && payload.contract && payload.contract.capabilities && payload.contract.capabilities.provides;
      const rootProvides = payload && payload.capabilities && payload.capabilities.provides;
      if (Array.isArray(contractProvides)) {
        providesRaw.push(...contractProvides);
      }
      if (Array.isArray(rootProvides)) {
        providesRaw.push(...rootProvides);
      }
      const provides = [];
      for (const providedCapability of providesRaw) {
        const descriptor = resolveMoquiCapabilityDescriptor(providedCapability, MOQUI_CAPABILITY_LEXICON_INDEX);
        if (!descriptor) {
          continue;
        }
        if (descriptor.is_alias) {
          addNormalizationRecord('provided_alias_mapped', descriptor);
        }
        if (descriptor.is_deprecated_alias) {
          addNormalizationRecord('provided_deprecated_aliases', descriptor);
          warnings.push(
            `template "${entry}" uses deprecated capability "${descriptor.raw}" (canonical "${descriptor.deprecated_replacement || descriptor.canonical}")`
          );
        }
        if (!descriptor.is_known) {
          addNormalizationRecord('provided_unknown', descriptor);
        }
        provides.push(descriptor.canonical);
      }
      const uniqueProvides = Array.from(new Set(provides));
      templates.push({
        template_id: entry,
        provides: uniqueProvides
      });
    } catch (_error) {
      // Ignore malformed template package entries.
    }
  }

  const coverage = expected.map(capability => {
    const matchedTemplates = [];
    const matchedProvides = [];
    for (const template of templates) {
      const providedMatched = template.provides.filter(item => moquiCapabilityMatch(capability, item));
      if (providedMatched.length > 0) {
        matchedTemplates.push(template.template_id);
        matchedProvides.push(...providedMatched);
      }
    }
    const uniqueProvides = Array.from(new Set(matchedProvides)).sort();
    return {
      capability,
      covered: matchedTemplates.length > 0,
      source_values: expectedMap.has(capability) ? expectedMap.get(capability).source_values : [],
      matched_templates: Array.from(new Set(matchedTemplates)).sort(),
      matched_provides: uniqueProvides
    };
  });

  const coveredCount = coverage.filter(item => item.covered).length;
  const uncovered = coverage.filter(item => !item.covered).map(item => item.capability);
  const coveragePercent = expected.length > 0
    ? Number(((coveredCount / expected.length) * 100).toFixed(2))
    : null;
  const minRequiredPercent = Number(policy.min_capability_coverage_percent);
  const passed = Number.isFinite(coveragePercent) && Number.isFinite(minRequiredPercent)
    ? coveragePercent >= minRequiredPercent
    : false;

  const payload = {
    mode: 'moqui-capability-coverage',
    generated_at: new Date().toISOString(),
    expected_capabilities: expected,
    summary: {
      total_capabilities: expected.length,
      covered_capabilities: coveredCount,
      uncovered_capabilities: expected.length - coveredCount,
      coverage_percent: coveragePercent,
      min_required_percent: Number.isFinite(minRequiredPercent) ? minRequiredPercent : 100,
      passed
    },
    coverage,
    gaps: uncovered,
    normalization,
    warnings: Array.from(new Set(warnings))
  };

  const previousPayload = await loadLatestMoquiCapabilityCoverageReport(projectPath);
  if (previousPayload) {
    payload.compare = buildCapabilityCoverageComparison(payload, previousPayload);
  }

  const outputJsonPath = path.join(projectPath, AUTO_HANDOFF_MOQUI_CAPABILITY_COVERAGE_JSON_FILE);
  const outputMarkdownPath = path.join(projectPath, AUTO_HANDOFF_MOQUI_CAPABILITY_COVERAGE_MARKDOWN_FILE);
  await fs.ensureDir(path.dirname(outputJsonPath));
  await fs.writeJson(outputJsonPath, payload, { spaces: 2 });
  await fs.writeFile(outputMarkdownPath, renderMoquiCapabilityCoverageMarkdown(payload), 'utf8');

  return {
    status: 'evaluated',
    generated: true,
    summary: payload.summary,
    coverage: payload.coverage,
    gaps: payload.gaps,
    normalization: payload.normalization,
    warnings: payload.warnings,
    compare: payload.compare || null,
    output: {
      json: toAutoHandoffCliPath(projectPath, outputJsonPath),
      markdown: toAutoHandoffCliPath(projectPath, outputMarkdownPath)
    }
  };
}

function collectAutoHandoffMoquiRemediationGoals(result) {
  const goals = [];
  const seen = new Set();
  const pushGoal = value => {
    const text = `${value || ''}`.trim();
    if (!text || seen.has(text)) {
      return;
    }
    seen.add(text);
    goals.push(text);
  };

  const moquiBaseline = result && result.moqui_baseline && typeof result.moqui_baseline === 'object'
    ? result.moqui_baseline
    : null;
  const baselineSummary = moquiBaseline && moquiBaseline.summary && typeof moquiBaseline.summary === 'object'
    ? moquiBaseline.summary
    : null;
  const baselineCompare = moquiBaseline && moquiBaseline.compare && typeof moquiBaseline.compare === 'object'
    ? moquiBaseline.compare
    : null;
  const baselineFailedTemplates = baselineCompare && baselineCompare.failed_templates && typeof baselineCompare.failed_templates === 'object'
    ? baselineCompare.failed_templates
    : {};

  if (moquiBaseline && moquiBaseline.status === 'error') {
    pushGoal('repair moqui baseline generation pipeline and regenerate baseline evidence');
  } else if (baselineSummary && baselineSummary.portfolio_passed === false) {
    pushGoal(
      `raise moqui baseline portfolio score (avg=${baselineSummary.avg_score || 'n/a'}, ` +
      `valid-rate=${baselineSummary.valid_rate_percent || 'n/a'}%) to pass thresholds`
    );
    const targetTemplates = Array.isArray(baselineFailedTemplates.current)
      ? baselineFailedTemplates.current
      : [];
    for (const templateId of targetTemplates) {
      pushGoal(`remediate moqui template ${templateId} ontology semantics and close baseline gaps`);
    }
  }

  const scenePackageBatch = result && result.scene_package_batch && typeof result.scene_package_batch === 'object'
    ? result.scene_package_batch
    : null;
  const sceneBatchSummary = scenePackageBatch && scenePackageBatch.summary && typeof scenePackageBatch.summary === 'object'
    ? scenePackageBatch.summary
    : null;
  const sceneBatchFailures = Array.isArray(scenePackageBatch && scenePackageBatch.failures)
    ? scenePackageBatch.failures
    : [];
  const sceneBatchGateFailures = scenePackageBatch
    && scenePackageBatch.batch_ontology_gate
    && Array.isArray(scenePackageBatch.batch_ontology_gate.failures)
    ? scenePackageBatch.batch_ontology_gate.failures
    : [];
  if (scenePackageBatch && scenePackageBatch.status === 'error') {
    pushGoal('repair scene package publish-batch dry-run gate pipeline and rerun handoff gate');
  } else if (scenePackageBatch && scenePackageBatch.status === 'failed') {
    pushGoal('fix scene package publish-batch dry-run failures before autonomous handoff execution');
    if (sceneBatchSummary) {
      pushGoal(
        `improve scene package batch ontology gate metrics ` +
        `(avg=${sceneBatchSummary.ontology_average_score || 'n/a'}, valid-rate=${sceneBatchSummary.ontology_valid_rate_percent || 'n/a'}%)`
      );
    }
    for (const item of sceneBatchFailures) {
      const spec = item && item.spec ? item.spec : '(unknown)';
      const reason = item && item.error ? item.error : 'publish failed';
      pushGoal(`repair scene package contract for ${spec}: ${reason}`);
    }
    for (const item of sceneBatchGateFailures) {
      const message = item && item.message ? item.message : null;
      if (message) {
        pushGoal(`resolve scene package batch ontology gate failure: ${message}`);
      }
    }
  }

  const capabilityCoverage = result && result.moqui_capability_coverage && typeof result.moqui_capability_coverage === 'object'
    ? result.moqui_capability_coverage
    : null;
  const capabilitySummary = capabilityCoverage && capabilityCoverage.summary && typeof capabilityCoverage.summary === 'object'
    ? capabilityCoverage.summary
    : null;
  const capabilityGaps = capabilityCoverage && Array.isArray(capabilityCoverage.gaps)
    ? capabilityCoverage.gaps
    : [];
  const capabilityNormalization = capabilityCoverage && capabilityCoverage.normalization && typeof capabilityCoverage.normalization === 'object'
    ? capabilityCoverage.normalization
    : null;
  if (
    capabilityCoverage &&
    capabilityCoverage.status === 'evaluated' &&
    capabilitySummary &&
    capabilitySummary.passed === false
  ) {
    pushGoal(
      `increase moqui capability coverage to >=${capabilitySummary.min_required_percent}% ` +
      `(current=${capabilitySummary.coverage_percent || 0}%)`
    );
    for (const capability of capabilityGaps) {
      pushGoal(`implement scene template or ontology mapping for moqui capability ${capability}`);
    }
  }
  if (
    capabilityNormalization &&
    Array.isArray(capabilityNormalization.expected_deprecated_aliases) &&
    capabilityNormalization.expected_deprecated_aliases.length > 0
  ) {
    for (const item of capabilityNormalization.expected_deprecated_aliases) {
      const raw = item && item.raw ? item.raw : '(unknown)';
      const canonical = item && item.canonical ? item.canonical : '(unknown)';
      pushGoal(`replace deprecated manifest capability alias ${raw} with canonical ${canonical}`);
    }
  }
  if (
    capabilityNormalization &&
    Array.isArray(capabilityNormalization.expected_unknown) &&
    capabilityNormalization.expected_unknown.length > 0
  ) {
    for (const item of capabilityNormalization.expected_unknown) {
      const raw = item && item.raw ? item.raw : '(unknown)';
      pushGoal(`align unknown manifest capability ${raw} with Moqui capability lexicon`);
    }
  }

  return goals;
}

async function maybeWriteAutoHandoffMoquiRemediationQueue(projectPath, result) {
  const goals = collectAutoHandoffMoquiRemediationGoals(result);
  if (goals.length === 0) {
    return null;
  }
  const queuePath = path.join(projectPath, AUTO_HANDOFF_MOQUI_REMEDIATION_QUEUE_FILE);
  await fs.ensureDir(path.dirname(queuePath));
  await fs.writeFile(queuePath, `${goals.join('\n')}\n`, 'utf8');
  return {
    file: queuePath,
    goal_count: goals.length,
    goals
  };
}

async function runAutoHandoff(projectPath, options = {}) {
  const startedAtMs = Date.now();
  const result = {
    mode: 'auto-handoff-run',
    status: 'running',
    generated_at: new Date().toISOString(),
    session_id: buildAutoHandoffRunSessionId(),
    manifest_path: null,
    source_project: null,
    policy: buildAutoHandoffRunPolicy(options),
    dry_run: Boolean(options.dryRun),
    phases: [],
    handoff: null,
    template_diff: null,
    queue: null,
    continued_from: null,
    dependency_execution: null,
    batch_summary: null,
    observability_snapshot: null,
    spec_status: null,
    ontology_validation: null,
    moqui_baseline: null,
    scene_package_batch: null,
    moqui_capability_coverage: null,
    remediation_queue: null,
    gates: null,
    regression: null,
    release_evidence: null,
    recommendations: [],
    warnings: [],
    error: null
  };

  try {
    const precheckPhase = beginAutoHandoffRunPhase(result, 'precheck', 'Plan and precheck');
    let plan = null;
    try {
      plan = await buildAutoHandoffPlan(projectPath, {
        manifest: options.manifest,
        strict: options.strict,
        strictWarnings: options.strictWarnings
      });
      result.manifest_path = plan.manifest_path;
      result.source_project = plan.source_project || null;
      result.handoff = plan.handoff;
      result.ontology_validation = evaluateHandoffOntologyValidation(
        plan && plan.handoff ? plan.handoff.ontology_validation : null
      );
      result.template_diff = await buildAutoHandoffTemplateDiff(projectPath, { manifest: options.manifest });
      completeAutoHandoffRunPhase(precheckPhase, {
        validation: plan.validation,
        phase_count: Array.isArray(plan.phases) ? plan.phases.length : 0,
        template_compatibility: result.template_diff.compatibility
      });
      const ontologyGateReasons = evaluateAutoHandoffOntologyGateReasons(
        result.policy,
        result.ontology_validation
      );
      if (ontologyGateReasons.length > 0) {
        throw new Error(`handoff ontology validation gate failed: ${ontologyGateReasons.join('; ')}`);
      }
    } catch (error) {
      failAutoHandoffRunPhase(precheckPhase, error);
      throw error;
    }

    const baselinePhase = beginAutoHandoffRunPhase(result, 'moqui-baseline', 'Moqui template baseline scorecard');
    try {
      result.moqui_baseline = await buildAutoHandoffMoquiBaselineSnapshot(projectPath);
      completeAutoHandoffRunPhase(
        baselinePhase,
        buildAutoHandoffMoquiBaselinePhaseDetails(result.moqui_baseline)
      );
      if (result.moqui_baseline && result.moqui_baseline.status === 'error') {
        result.warnings.push(`moqui baseline generation failed: ${result.moqui_baseline.error || 'unknown error'}`);
      }
      const moquiBaselineGateReasons = evaluateAutoHandoffMoquiBaselineGateReasons(
        result.policy,
        result.moqui_baseline
      );
      if (moquiBaselineGateReasons.length > 0) {
        throw new Error(`handoff moqui baseline gate failed: ${moquiBaselineGateReasons.join('; ')}`);
      }
    } catch (baselineError) {
      failAutoHandoffRunPhase(baselinePhase, baselineError);
      if (!result.moqui_baseline) {
        result.moqui_baseline = {
          status: 'error',
          generated: false,
          error: baselineError && baselineError.message ? baselineError.message : `${baselineError}`
        };
      }
      throw baselineError;
    }

    const sceneBatchPhase = beginAutoHandoffRunPhase(
      result,
      'scene-package-batch',
      'Scene package publish-batch dry-run gate'
    );
    try {
      result.scene_package_batch = await buildAutoHandoffScenePackageBatchSnapshot(
        projectPath,
        result.manifest_path
      );
      completeAutoHandoffRunPhase(
        sceneBatchPhase,
        buildAutoHandoffScenePackageBatchPhaseDetails(result.scene_package_batch)
      );
      if (result.scene_package_batch && result.scene_package_batch.status === 'error') {
        result.warnings.push(
          `scene package publish-batch dry-run failed: ${result.scene_package_batch.error || 'unknown error'}`
        );
      }
      const sceneBatchGateReasons = evaluateAutoHandoffScenePackageBatchGateReasons(
        result.policy,
        result.scene_package_batch
      );
      if (sceneBatchGateReasons.length > 0) {
        throw new Error(`handoff scene package batch gate failed: ${sceneBatchGateReasons.join('; ')}`);
      }
    } catch (sceneBatchError) {
      failAutoHandoffRunPhase(sceneBatchPhase, sceneBatchError);
      if (!result.scene_package_batch) {
        result.scene_package_batch = {
          status: 'error',
          generated: false,
          error: sceneBatchError && sceneBatchError.message ? sceneBatchError.message : `${sceneBatchError}`
        };
      }
      throw sceneBatchError;
    }

    const capabilityCoveragePhase = beginAutoHandoffRunPhase(
      result,
      'moqui-capability-coverage',
      'Moqui capability coverage matrix'
    );
    try {
      result.moqui_capability_coverage = await buildAutoHandoffCapabilityCoverageSnapshot(
        projectPath,
        result.handoff,
        result.policy
      );
      completeAutoHandoffRunPhase(capabilityCoveragePhase, {
        status: result.moqui_capability_coverage.status || 'unknown',
        coverage_percent: Number.isFinite(
          Number(
            result.moqui_capability_coverage &&
            result.moqui_capability_coverage.summary
              ? result.moqui_capability_coverage.summary.coverage_percent
              : null
          )
        )
          ? Number(result.moqui_capability_coverage.summary.coverage_percent)
          : null,
        passed: Boolean(
          result.moqui_capability_coverage &&
          result.moqui_capability_coverage.summary &&
          result.moqui_capability_coverage.summary.passed === true
        )
      });
      const capabilityCoverageGateReasons = evaluateAutoHandoffCapabilityCoverageGateReasons(
        result.policy,
        result.moqui_capability_coverage
      );
      if (capabilityCoverageGateReasons.length > 0) {
        throw new Error(`handoff capability coverage gate failed: ${capabilityCoverageGateReasons.join('; ')}`);
      }
    } catch (capabilityCoverageError) {
      failAutoHandoffRunPhase(capabilityCoveragePhase, capabilityCoverageError);
      if (!result.moqui_capability_coverage) {
        result.moqui_capability_coverage = {
          status: 'error',
          generated: false,
          error: capabilityCoverageError && capabilityCoverageError.message
            ? capabilityCoverageError.message
            : `${capabilityCoverageError}`
        };
      }
      throw capabilityCoverageError;
    }

    const queuePhase = beginAutoHandoffRunPhase(result, 'queue', 'Queue generation');
    let queue = null;
    try {
      if (options.continueFrom) {
        queue = await buildAutoHandoffQueueFromContinueSource(projectPath, plan, options);
      } else {
        queue = await buildAutoHandoffQueue(projectPath, {
          manifest: options.manifest,
          out: options.queueOut,
          append: options.append,
          includeKnownGaps: options.includeKnownGaps,
          dryRun: options.dryRun
        });
      }
      if (!queue.dry_run) {
        await writeAutoHandoffQueueFile(projectPath, queue, {
          out: options.queueOut,
          append: options.append
        });
      }
      result.queue = {
        goal_count: queue.goal_count,
        include_known_gaps: queue.include_known_gaps,
        output_file: queue.output_file || null,
        dependency_batching: result.policy.dependency_batching,
        resumed_from: queue.resumed_from || null
      };
      result.continued_from = queue.resumed_from || null;
      completeAutoHandoffRunPhase(queuePhase, {
        goal_count: queue.goal_count,
        output_file: queue.output_file || null,
        resumed_from: queue.resumed_from
          ? {
            session_id: queue.resumed_from.session_id,
            strategy: queue.resumed_from.strategy
          }
          : null
      });
    } catch (error) {
      failAutoHandoffRunPhase(queuePhase, error);
      throw error;
    }

    const continuationBaselineSummary = queue && queue.resume_context && queue.resume_context.previous_batch_summary
      ? queue.resume_context.previous_batch_summary
      : null;

    if (result.dry_run) {
      skipAutoHandoffRunPhase(result, 'execution', 'Autonomous close-loop-batch', 'dry-run');
      skipAutoHandoffRunPhase(result, 'observability', 'Observability snapshot', 'dry-run');
      result.dependency_execution = buildAutoHandoffExecutionBatches(
        result.handoff,
        Array.isArray(queue && queue.goals) ? queue.goals : [],
        result.policy.dependency_batching
      );
      result.spec_status = buildAutoHandoffSpecStatus(
        result.handoff && Array.isArray(result.handoff.specs) ? result.handoff.specs : [],
        null,
        continuationBaselineSummary
      );
      result.gates = evaluateAutoHandoffRunGates({
        policy: result.policy,
        dryRun: true,
        specStatus: result.spec_status,
        ontology: result.ontology_validation,
        moquiBaseline: result.moqui_baseline,
        scenePackageBatch: result.scene_package_batch,
        capabilityCoverage: result.moqui_capability_coverage,
        programKpi: {
          risk_level: 'low'
        }
      });
      result.status = 'dry-run';
      return result;
    }

    const executionPhase = beginAutoHandoffRunPhase(result, 'execution', 'Autonomous close-loop-batch');
    let executionResult = null;
    try {
      executionResult = await executeAutoHandoffExecutionBatches(projectPath, result.handoff, queue, {
        queueOut: options.queueOut,
        continueOnError: options.continueOnError,
        batchAutonomous: options.batchAutonomous,
        batchParallel: options.batchParallel,
        batchAgentBudget: options.batchAgentBudget,
        batchRetryRounds: options.batchRetryRounds,
        batchRetryUntilComplete: options.batchRetryUntilComplete,
        batchRetryMaxRounds: options.batchRetryMaxRounds,
        dependencyBatching: result.policy.dependency_batching
      });
      result.dependency_execution = executionResult.execution_plan;
      result.batch_summary = executionResult.summary;
      result.spec_status = buildAutoHandoffSpecStatus(
        result.handoff && Array.isArray(result.handoff.specs) ? result.handoff.specs : [],
        result.batch_summary,
        continuationBaselineSummary
      );
      completeAutoHandoffRunPhase(executionPhase, {
        status: result.batch_summary.status,
        processed_goals: result.batch_summary.processed_goals,
        failed_goals: result.batch_summary.failed_goals,
        execution_batches: Array.isArray(executionResult.execution_batches)
          ? executionResult.execution_batches.length
          : 0
      });
    } catch (error) {
      failAutoHandoffRunPhase(executionPhase, error);
      throw error;
    }

    const observabilityPhase = beginAutoHandoffRunPhase(result, 'observability', 'Observability snapshot');
    try {
      result.observability_snapshot = await buildAutoObservabilitySnapshot(projectPath, options);
      completeAutoHandoffRunPhase(observabilityPhase, {
        risk_level: result.observability_snapshot && result.observability_snapshot.highlights
          ? result.observability_snapshot.highlights.governance_risk_level
          : null
      });
    } catch (error) {
      failAutoHandoffRunPhase(observabilityPhase, error);
      throw error;
    }

    result.gates = evaluateAutoHandoffRunGates({
      policy: result.policy,
      dryRun: false,
      specStatus: result.spec_status,
      ontology: result.ontology_validation,
      moquiBaseline: result.moqui_baseline,
      scenePackageBatch: result.scene_package_batch,
      capabilityCoverage: result.moqui_capability_coverage,
      programKpi: buildProgramKpiSnapshot(result.batch_summary || {})
    });
    if (!result.gates.passed) {
      throw new Error(`handoff run gate failed: ${result.gates.reasons.join('; ')}`);
    }
    result.status = 'completed';
  } catch (error) {
    result.status = 'failed';
    result.error = error && error.message ? error.message : `${error}`;
  } finally {
    result.completed_at = new Date().toISOString();
    result.elapsed_ms = Math.max(0, Date.now() - startedAtMs);
    result.regression = await buildAutoHandoffRegression(projectPath, result);
    result.remediation_queue = await maybeWriteAutoHandoffMoquiRemediationQueue(projectPath, result);
    result.recommendations = buildAutoHandoffRunRecommendations(projectPath, result);
    await writeAutoHandoffRunReport(projectPath, result, options.out);
    if (result.dry_run) {
      result.release_evidence = {
        mode: 'auto-handoff-release-evidence',
        merged: false,
        skipped: true,
        reason: 'dry-run',
        file: path.join(projectPath, AUTO_HANDOFF_RELEASE_EVIDENCE_FILE)
      };
    } else {
      try {
        result.release_evidence = await mergeAutoHandoffRunIntoReleaseEvidence(projectPath, result, result.output_file);
      } catch (mergeError) {
        const message = mergeError && mergeError.message ? mergeError.message : `${mergeError}`;
        result.release_evidence = {
          mode: 'auto-handoff-release-evidence',
          merged: false,
          file: path.join(projectPath, AUTO_HANDOFF_RELEASE_EVIDENCE_FILE),
          error: message
        };
        result.warnings.push(`release evidence merge failed: ${message}`);
      }
    }
    try {
      await writeAutoHandoffRunReport(projectPath, result, options.out);
    } catch (refreshError) {
      const message = refreshError && refreshError.message ? refreshError.message : `${refreshError}`;
      result.warnings.push(`handoff run report refresh failed: ${message}`);
    }
  }

  return result;
}

function buildProgramKpiSnapshot(summary) {
  const results = Array.isArray(summary && summary.results) ? summary.results : [];
  const totalGoals = Number(summary && summary.total_goals) || results.length || 1;
  const completedGoals = Number(summary && summary.completed_goals) || 0;
  const failedGoals = Number(summary && summary.failed_goals) || 0;
  const processedGoals = Number(summary && summary.processed_goals) || results.length;
  const completionRate = Number(((completedGoals / totalGoals) * 100).toFixed(2));
  const failureRate = Number(((failedGoals / totalGoals) * 100).toFixed(2));
  const averageWaitTicks = Number(
    (
      results.reduce((sum, item) => sum + (Number(item && item.wait_ticks) || 0), 0) /
      (results.length || 1)
    ).toFixed(2)
  );
  const highComplexityGoals = results.filter(item => (Number(item && item.goal_weight) || 0) >= 3).length;
  const highComplexityRatioPercent = Number(((highComplexityGoals / totalGoals) * 100).toFixed(2));
  const retry = summary && summary.batch_retry ? summary.batch_retry : {};
  const retryHistory = Array.isArray(retry.history) ? retry.history : [];
  const firstRoundUnresolved = retryHistory.length > 0
    ? (Number(retryHistory[0].failed_goals) || 0) + (Number(retryHistory[0].unprocessed_goals) || 0)
    : failedGoals;
  const recoveredGoals = Math.max(0, firstRoundUnresolved - failedGoals);
  const retryRecoveryRatePercent = firstRoundUnresolved > 0
    ? Number(((recoveredGoals / firstRoundUnresolved) * 100).toFixed(2))
    : 100;

  let convergenceState = 'converged';
  if (summary && summary.status === 'partial-failed') {
    convergenceState = 'at-risk';
  } else if (summary && summary.status === 'failed') {
    convergenceState = 'blocked';
  }

  let riskLevel = 'low';
  if (failureRate > 20 || convergenceState === 'blocked') {
    riskLevel = 'high';
  } else if (failureRate > 0 || (Number(retry.performed_rounds) || 0) > 0) {
    riskLevel = 'medium';
  }

  return {
    generated_at: new Date().toISOString(),
    completion_rate_percent: completionRate,
    failure_rate_percent: failureRate,
    processed_goals: processedGoals,
    high_complexity_goal_ratio_percent: highComplexityRatioPercent,
    average_wait_ticks: averageWaitTicks,
    retry_rounds_performed: Number(retry.performed_rounds) || 0,
    retry_recovery_rate_percent: retryRecoveryRatePercent,
    convergence_state: convergenceState,
    risk_level: riskLevel
  };
}

function evaluateProgramConvergenceGate(summary, policy = {}) {
  const metrics = summary && summary.metrics && typeof summary.metrics === 'object'
    ? summary.metrics
    : {};
  const programKpi = summary && summary.program_kpi && typeof summary.program_kpi === 'object'
    ? summary.program_kpi
    : buildProgramKpiSnapshot(summary || {});
  const resolvedPolicy = resolveProgramGatePolicy(policy);
  const minSuccessRate = resolvedPolicy.minSuccessRate;
  const maxRiskLevel = resolvedPolicy.maxRiskLevel;
  const maxElapsedMinutes = resolvedPolicy.maxElapsedMinutes;
  const maxAgentBudget = resolvedPolicy.maxAgentBudget;
  const maxTotalSubSpecs = resolvedPolicy.maxTotalSubSpecs;
  const completionRateFromKpi = Number(programKpi.completion_rate_percent);
  const successRateFromMetrics = Number(metrics.success_rate_percent);
  const successRate = Number.isFinite(completionRateFromKpi)
    ? completionRateFromKpi
    : (Number.isFinite(successRateFromMetrics) ? successRateFromMetrics : null);
  const elapsedMsCandidate = Number(summary && summary.program_elapsed_ms);
  const elapsedMs = Number.isFinite(elapsedMsCandidate) && elapsedMsCandidate >= 0
    ? elapsedMsCandidate
    : null;
  const elapsedMinutes = elapsedMs === null
    ? null
    : Number((elapsedMs / 60000).toFixed(2));
  const resourcePlan = summary && summary.resource_plan && typeof summary.resource_plan === 'object'
    ? summary.resource_plan
    : {};
  const agentBudgetCandidate = Number(resourcePlan.agent_budget);
  const effectiveParallelCandidate = Number(resourcePlan.effective_goal_parallel);
  const batchParallelCandidate = Number(summary && summary.batch_parallel);
  const actualAgentBudget = Number.isFinite(agentBudgetCandidate) && agentBudgetCandidate > 0
    ? agentBudgetCandidate
    : Number.isFinite(effectiveParallelCandidate) && effectiveParallelCandidate > 0
      ? effectiveParallelCandidate
      : Number.isFinite(batchParallelCandidate) && batchParallelCandidate > 0
        ? batchParallelCandidate
        : null;
  const totalSubSpecsFromMetrics = Number(metrics.total_sub_specs);
  const totalSubSpecs = Number.isFinite(totalSubSpecsFromMetrics)
    ? totalSubSpecsFromMetrics
    : (
      Array.isArray(summary && summary.results)
        ? summary.results.reduce((sum, item) => sum + (Number(item && item.sub_spec_count) || 0), 0)
        : null
    );
  const riskLevel = `${programKpi.risk_level || 'high'}`.trim().toLowerCase();
  const riskRank = {
    low: 1,
    medium: 2,
    high: 3
  };
  const reasons = [];
  if (!Number.isFinite(successRate)) {
    reasons.push('success_rate_percent unavailable');
  } else if (successRate < minSuccessRate) {
    reasons.push(`success_rate_percent ${successRate} < required ${minSuccessRate}`);
  }
  if ((riskRank[riskLevel] || 3) > (riskRank[maxRiskLevel] || 3)) {
    reasons.push(`risk_level ${riskLevel} exceeds allowed ${maxRiskLevel}`);
  }
  if (maxElapsedMinutes !== null) {
    if (!Number.isFinite(elapsedMinutes)) {
      reasons.push('program_elapsed_minutes unavailable');
    } else if (elapsedMinutes > maxElapsedMinutes) {
      reasons.push(`program_elapsed_minutes ${elapsedMinutes} exceeds allowed ${maxElapsedMinutes}`);
    }
  }
  if (maxAgentBudget !== null) {
    if (!Number.isFinite(actualAgentBudget)) {
      reasons.push('agent_budget unavailable');
    } else if (actualAgentBudget > maxAgentBudget) {
      reasons.push(`agent_budget ${actualAgentBudget} exceeds allowed ${maxAgentBudget}`);
    }
  }
  if (maxTotalSubSpecs !== null) {
    if (!Number.isFinite(totalSubSpecs)) {
      reasons.push('total_sub_specs unavailable');
    } else if (totalSubSpecs > maxTotalSubSpecs) {
      reasons.push(`total_sub_specs ${totalSubSpecs} exceeds allowed ${maxTotalSubSpecs}`);
    }
  }

  return {
    passed: reasons.length === 0,
    policy: {
      profile: resolvedPolicy.profile,
      min_success_rate_percent: minSuccessRate,
      max_risk_level: maxRiskLevel,
      max_elapsed_minutes: maxElapsedMinutes,
      max_agent_budget: maxAgentBudget,
      max_total_sub_specs: maxTotalSubSpecs
    },
    actual: {
      success_rate_percent: Number.isFinite(successRate) ? successRate : null,
      risk_level: riskLevel,
      elapsed_minutes: Number.isFinite(elapsedMinutes) ? elapsedMinutes : null,
      agent_budget: Number.isFinite(actualAgentBudget) ? actualAgentBudget : null,
      total_sub_specs: Number.isFinite(totalSubSpecs) ? totalSubSpecs : null
    },
    reasons
  };
}

async function applyProgramGateOutcome(summary, context = {}) {
  const projectPath = context && context.projectPath ? context.projectPath : process.cwd();
  const options = context && context.options && typeof context.options === 'object'
    ? context.options
    : {};
  const resolvedPolicy = resolveProgramGatePolicy(context && context.programGatePolicy ? context.programGatePolicy : {});
  const gateFallbackChain = Array.isArray(context && context.gateFallbackChain)
    ? context.gateFallbackChain
    : [];
  const enableAutoRemediation = context && context.enableAutoRemediation !== undefined
    ? Boolean(context.enableAutoRemediation)
    : true;

  summary.program_gate = evaluateProgramConvergenceGate(summary, {
    profile: resolvedPolicy.profile,
    minSuccessRate: resolvedPolicy.minSuccessRate,
    maxRiskLevel: resolvedPolicy.maxRiskLevel,
    maxElapsedMinutes: resolvedPolicy.maxElapsedMinutes,
    maxAgentBudget: resolvedPolicy.maxAgentBudget,
    maxTotalSubSpecs: resolvedPolicy.maxTotalSubSpecs
  });

  let effectiveGatePassed = summary.program_gate.passed;
  let effectiveGateSource = 'primary';
  let matchedFallbackProfile = null;
  summary.program_gate_fallbacks = [];
  if (!effectiveGatePassed && gateFallbackChain.length > 0) {
    for (const fallbackProfile of gateFallbackChain) {
      const fallbackResult = evaluateProgramConvergenceGate(summary, {
        profile: fallbackProfile,
        maxElapsedMinutes: resolvedPolicy.maxElapsedMinutes,
        maxAgentBudget: resolvedPolicy.maxAgentBudget,
        maxTotalSubSpecs: resolvedPolicy.maxTotalSubSpecs
      });
      summary.program_gate_fallbacks.push(fallbackResult);
      if (fallbackResult.passed) {
        effectiveGatePassed = true;
        effectiveGateSource = 'fallback-chain';
        matchedFallbackProfile = fallbackProfile;
        break;
      }
    }
  }
  summary.program_gate_fallback = summary.program_gate_fallbacks.length > 0
    ? summary.program_gate_fallbacks[0]
    : null;
  summary.program_gate_effective = {
    passed: effectiveGatePassed,
    source: effectiveGateSource,
    primary_passed: Boolean(summary.program_gate && summary.program_gate.passed),
    fallback_profile: matchedFallbackProfile,
    fallback_chain: gateFallbackChain,
    fallback_passed: matchedFallbackProfile !== null,
    attempted_fallback_count: summary.program_gate_fallbacks.length
  };

  if (
    enableAutoRemediation &&
    (
      !summary.program_gate_effective.passed ||
      isSpecSessionBudgetHardFailure(summary) ||
      isSpecSessionGrowthGuardHardFailure(summary)
    )
  ) {
    summary.program_gate_auto_remediation = await applyProgramGateAutoRemediation(summary, {
      projectPath,
      options
    });
  }

  return summary;
}

function hasRecoverableProgramGoals(summary) {
  const failedStatuses = getBatchFailureStatusSet();
  const results = Array.isArray(summary && summary.results) ? summary.results : [];
  return results.some(item => failedStatuses.has(`${item && item.status ? item.status : ''}`.trim().toLowerCase()));
}

function applyAnomalyBatchConcurrencyReductionPatch(summary, patch, reasons, options, anomalyType) {
  const currentParallelCandidate = patch.batchParallel !== undefined && patch.batchParallel !== null
    ? patch.batchParallel
    : (
      options.batchParallel !== undefined && options.batchParallel !== null
        ? options.batchParallel
        : (summary && summary.batch_parallel ? summary.batch_parallel : 1)
    );
  const currentParallel = normalizeBatchParallel(currentParallelCandidate);
  if (currentParallel > 1) {
    patch.batchParallel = currentParallel - 1;
    reasons.push(`reduce batch parallel from ${currentParallel} to ${patch.batchParallel} due to ${anomalyType}`);
  }

  const currentAgentBudgetCandidate = patch.batchAgentBudget !== undefined && patch.batchAgentBudget !== null
    ? patch.batchAgentBudget
    : (
      options.batchAgentBudget !== undefined && options.batchAgentBudget !== null
        ? options.batchAgentBudget
        : (summary && summary.resource_plan ? summary.resource_plan.agent_budget : null)
    );
  const currentAgentBudget = normalizeBatchAgentBudget(currentAgentBudgetCandidate);
  if (currentAgentBudget !== null && currentAgentBudget > 1) {
    patch.batchAgentBudget = currentAgentBudget - 1;
    reasons.push(`reduce batch agent budget from ${currentAgentBudget} to ${patch.batchAgentBudget} due to ${anomalyType}`);
  }
}

function buildProgramAnomalyGovernancePatch(summary, anomalies, options = {}) {
  const sourceAnomalies = Array.isArray(anomalies) ? anomalies : [];
  const highAnomalies = sourceAnomalies.filter(item => `${item && item.severity ? item.severity : ''}`.trim().toLowerCase() === 'high');
  const patch = {};
  const reasons = [];

  const anomalyTypes = new Set(highAnomalies.map(item => `${item && item.type ? item.type : ''}`.trim().toLowerCase()));
  if (anomalyTypes.has('success-rate-drop')) {
    const currentRetryRounds = normalizeBatchRetryRounds(options.batchRetryRounds);
    patch.batchRetryRounds = Math.min(5, Math.max(1, currentRetryRounds + 1));
    patch.batchRetryUntilComplete = true;
    reasons.push('increase retry rounds due to success-rate-drop anomaly');
  }

  if (anomalyTypes.has('failed-goals-spike')) {
    applyAnomalyBatchConcurrencyReductionPatch(summary, patch, reasons, options, 'failed-goals-spike');
  }

  if (anomalyTypes.has('rate-limit-spike')) {
    applyAnomalyBatchConcurrencyReductionPatch(summary, patch, reasons, options, 'rate-limit-spike');
  }

  if (anomalyTypes.has('spec-growth-spike')) {
    patch.specSessionBudgetHardFail = true;
    reasons.push('enable spec-session budget hard-fail due to spec-growth-spike');
    if (options.specSessionMaxCreated === undefined || options.specSessionMaxCreated === null) {
      const estimatedCreated = Number(summary && summary.spec_session_budget && summary.spec_session_budget.estimated_created) || 0;
      patch.specSessionMaxCreated = Math.max(1, Math.ceil(estimatedCreated * 0.8));
      reasons.push(`set specSessionMaxCreated=${patch.specSessionMaxCreated} due to spec-growth-spike`);
    }
  }

  return {
    patch,
    reasons,
    anomaly_count: highAnomalies.length,
    anomaly_types: [...anomalyTypes]
  };
}

function applyProgramGovernancePatch(baseOptions, patch) {
  const merged = { ...baseOptions };
  const sourcePatch = patch && typeof patch === 'object' ? patch : {};
  for (const [key, value] of Object.entries(sourcePatch)) {
    if (value === undefined) {
      continue;
    }
    merged[key] = value;
  }
  return merged;
}

function buildProgramGovernanceReplayGoalsResult(baseGoalsResult, round, summary) {
  const source = baseGoalsResult && typeof baseGoalsResult === 'object'
    ? baseGoalsResult
    : { file: '(generated-from-goal)', goals: [] };
  const sourceSummary = summary && typeof summary === 'object' ? summary : {};
  return {
    ...source,
    file: source.file || '(generated-from-goal)',
    resumedFromSummary: {
      file: sourceSummary.batch_session && sourceSummary.batch_session.file
        ? sourceSummary.batch_session.file
        : '(program-governance-replay)',
      strategy: 'program-governance-replay',
      round,
      previous_status: sourceSummary.status || null,
      previous_total_goals: Number(sourceSummary.total_goals) || null,
      previous_processed_goals: Number(sourceSummary.processed_goals) || null
    }
  };
}

async function runProgramGovernanceLoop(context = {}) {
  let summary = context.summary && typeof context.summary === 'object' ? context.summary : {};
  const projectPath = context.projectPath || process.cwd();
  const baseProgramOptions = context.programOptions && typeof context.programOptions === 'object'
    ? context.programOptions
    : {};
  const baseGoalsResult = context.baseGoalsResult && typeof context.baseGoalsResult === 'object'
    ? context.baseGoalsResult
    : { file: '(generated-from-goal)', goals: [] };
  const enabled = Boolean(context.enabled);
  const maxRounds = normalizeProgramGovernMaxRounds(context.maxRounds);
  const maxDurationMinutes = normalizeProgramGovernMaxMinutes(context.maxMinutes);
  const maxDurationMs = maxDurationMinutes * 60 * 1000;
  const anomalyEnabled = context.anomalyEnabled !== false;
  const anomalyWeeks = normalizeProgramGovernAnomalyWeeks(context.anomalyWeeks);
  const anomalyPeriod = normalizeAutoKpiTrendPeriod(context.anomalyPeriod);
  const governUseAction = normalizeProgramGovernUseAction(context.governUseAction);
  const governAutoActionEnabled = context.governAutoActionEnabled !== false;
  const governActionEnabled = governAutoActionEnabled || governUseAction !== null;
  const programGatePolicy = resolveProgramGatePolicy(context.programGatePolicy || {});
  const gateFallbackChain = Array.isArray(context.gateFallbackChain) ? context.gateFallbackChain : [];
  const recoveryMemoryScope = context.recoveryMemoryScope || null;
  const normalizedRecoveryScope = normalizeRecoveryMemoryToken(recoveryMemoryScope || '') || 'default-scope';
  const recoverResumeStrategy = normalizeResumeStrategy(context.recoverResumeStrategy || 'pending');
  const recoverMaxRounds = normalizeRecoverMaxRounds(context.recoverMaxRounds);
  const recoverMaxMinutes = normalizeRecoverMaxMinutes(
    context.recoverMaxMinutes,
    '--program-recover-max-minutes'
  );
  const recoverMaxDurationMs = recoverMaxMinutes === null ? null : recoverMaxMinutes * 60 * 1000;
  const governanceStartedAt = Date.now();
  const history = [];
  let exhausted = false;
  let stopReason = enabled ? 'stable' : 'disabled';
  let settled = false;

  if (!enabled) {
    return {
      summary,
      governance: {
        enabled: false,
        anomaly_enabled: anomalyEnabled,
        anomaly_weeks: anomalyWeeks,
        anomaly_period: anomalyPeriod,
        auto_action_enabled: governAutoActionEnabled,
        action_selection_enabled: false,
        pinned_action_index: governUseAction,
        max_rounds: maxRounds,
        max_minutes: maxDurationMinutes,
        performed_rounds: 0,
        converged: Boolean(
          summary &&
          summary.program_gate_effective &&
          summary.program_gate_effective.passed &&
          !isSpecSessionBudgetHardFailure(summary) &&
          !isSpecSessionGrowthGuardHardFailure(summary)
        ),
        exhausted: false,
        stop_reason: 'disabled',
        history: []
      }
    };
  }

  for (let round = 1; round <= maxRounds; round += 1) {
    const elapsedBeforeRound = Date.now() - governanceStartedAt;
    if (elapsedBeforeRound >= maxDurationMs) {
      exhausted = true;
      stopReason = 'time-budget-exhausted';
      break;
    }

    let trendResult = null;
    let anomalies = [];
    if (anomalyEnabled) {
      trendResult = await buildAutoKpiTrend(projectPath, {
        weeks: anomalyWeeks,
        mode: 'program',
        period: anomalyPeriod
      });
      anomalies = Array.isArray(trendResult.anomalies) ? trendResult.anomalies : [];
      summary.program_kpi_trend = {
        generated_at: trendResult.generated_at,
        weeks: trendResult.weeks,
        period_unit: trendResult.period_unit,
        total_runs: trendResult.total_runs,
        overall: trendResult.overall,
        anomaly_detection: trendResult.anomaly_detection || null
      };
      summary.program_kpi_anomalies = anomalies;
    }

    const gateFailed = Boolean(
      !summary.program_gate_effective ||
      !summary.program_gate_effective.passed ||
      isSpecSessionBudgetHardFailure(summary) ||
      isSpecSessionGrowthGuardHardFailure(summary)
    );
    const highSeverityAnomalies = anomalies.filter(item => `${item && item.severity ? item.severity : ''}`.trim().toLowerCase() === 'high');
    const anomalyFailed = anomalyEnabled && highSeverityAnomalies.length > 0;
    if (!gateFailed && !anomalyFailed) {
      stopReason = 'stable';
      settled = true;
      break;
    }

    const gatePatch = summary && summary.program_gate_auto_remediation && summary.program_gate_auto_remediation.next_run_patch
      ? summary.program_gate_auto_remediation.next_run_patch
      : {};
    const anomalyPatch = buildProgramAnomalyGovernancePatch(summary, highSeverityAnomalies, baseProgramOptions);
    let governanceActionSelection = null;
    let governanceActionPatch = {};
    if (governActionEnabled) {
      const recoveryMemory = await loadCloseLoopRecoveryMemory(projectPath);
      const recoverySignature = buildRecoveryMemorySignature(summary, {
        scope: normalizedRecoveryScope
      });
      const recoveryMemoryEntry = getRecoveryMemoryEntry(recoveryMemory.payload, recoverySignature);
      governanceActionSelection = resolveRecoveryActionSelection(summary, governUseAction, {
        recoveryMemoryEntry,
        optionLabel: '--program-govern-use-action'
      });
      governanceActionPatch = governanceActionSelection &&
        governanceActionSelection.appliedPatch &&
        typeof governanceActionSelection.appliedPatch === 'object'
        ? governanceActionSelection.appliedPatch
        : {};
    }
    const roundPatch = {
      ...(governanceActionPatch && typeof governanceActionPatch === 'object' ? governanceActionPatch : {}),
      ...(anomalyPatch.patch || {}),
      ...(gatePatch && typeof gatePatch === 'object' ? gatePatch : {})
    };
    if (Object.keys(roundPatch).length === 0) {
      stopReason = 'no-actionable-patch';
      history.push({
        round,
        status_before: summary.status,
        status_after: summary.status,
        trigger: {
          gate_failed: gateFailed,
          anomaly_failed: anomalyFailed,
          anomaly_count: highSeverityAnomalies.length
        },
        selected_action_index: governanceActionSelection ? governanceActionSelection.selectedIndex : null,
        selected_action: governanceActionSelection && governanceActionSelection.selectedAction
          ? governanceActionSelection.selectedAction.action
          : null,
        selected_action_priority: governanceActionSelection && governanceActionSelection.selectedAction
          ? governanceActionSelection.selectedAction.priority
          : null,
        action_selection_source: governanceActionSelection ? governanceActionSelection.selectionSource : null,
        action_selection_explain: governanceActionSelection ? governanceActionSelection.selectionExplain || null : null,
        execution_mode: 'none',
        applied_patch: null,
        notes: [
          'No actionable governance patch generated.'
        ]
      });
      break;
    }

    const roundOptions = applyProgramGovernancePatch(baseProgramOptions, roundPatch);
    roundOptions.out = null;
    roundOptions.programKpiOut = null;
    roundOptions.programAuditOut = null;

    const statusBefore = summary.status;
    const failedGoalsBefore = Number(summary.failed_goals) || 0;
    const selectedGovernanceActionIndex = governanceActionSelection ? governanceActionSelection.selectedIndex : null;
    let executionMode = 'program-replay';
    let roundSummary = null;
    if (hasRecoverableProgramGoals(summary)) {
      executionMode = 'recover-cycle';
      const roundSourceSummary = summary.batch_session && summary.batch_session.file
        ? await loadCloseLoopBatchSummaryPayload(projectPath, summary.batch_session.file)
        : {
          file: '(program-governance-derived-summary)',
          payload: summary
        };
      const recoveryResult = await executeCloseLoopRecoveryCycle({
        projectPath,
        sourceSummary: roundSourceSummary,
        baseOptions: {
          ...roundOptions,
          useAction: selectedGovernanceActionIndex || context.programRecoverUseAction
        },
        recoverAutonomousEnabled: true,
        resumeStrategy: recoverResumeStrategy,
        recoverUntilComplete: true,
        recoverMaxRounds,
        recoverMaxDurationMs,
        recoveryMemoryScope,
        actionCandidate: selectedGovernanceActionIndex || context.programRecoverUseAction
      });
      roundSummary = mergeProgramRecoveryIntoProgramSummary(summary, recoveryResult.summary, {
        enabled: true,
        triggered: true,
        governance_round: round,
        recover_until_complete: true,
        source: 'governance-recover-cycle'
      });
      roundSummary.resource_plan = recoveryResult.summary && recoveryResult.summary.resource_plan
        ? recoveryResult.summary.resource_plan
        : roundSummary.resource_plan;
      roundSummary.batch_parallel = Number(recoveryResult.summary && recoveryResult.summary.batch_parallel) || roundSummary.batch_parallel;
    } else {
      const replayGoalsResult = buildProgramGovernanceReplayGoalsResult(baseGoalsResult, round, summary);
      const replaySummary = await executeCloseLoopBatch(
        replayGoalsResult,
        roundOptions,
        projectPath,
        'auto-close-loop-program'
      );
      roundSummary = {
        ...replaySummary,
        auto_recovery: summary && summary.auto_recovery ? summary.auto_recovery : null
      };
    }

    roundSummary.program_kpi = buildProgramKpiSnapshot(roundSummary);
    roundSummary.program_diagnostics = buildProgramDiagnostics(roundSummary);
    roundSummary.program_coordination = buildProgramCoordinationSnapshot(roundSummary);
    await applyProgramGateOutcome(roundSummary, {
      projectPath,
      options: roundOptions,
      programGatePolicy,
      gateFallbackChain,
      enableAutoRemediation: context.programGateAutoRemediate !== false
    });

    const failedGoalsAfter = Number(roundSummary.failed_goals) || 0;
    history.push({
      round,
      status_before: statusBefore,
      status_after: roundSummary.status,
      trigger: {
        gate_failed: gateFailed,
        anomaly_failed: anomalyFailed,
        anomaly_count: highSeverityAnomalies.length
      },
      selected_action_index: selectedGovernanceActionIndex,
      selected_action: governanceActionSelection && governanceActionSelection.selectedAction
        ? governanceActionSelection.selectedAction.action
        : null,
      selected_action_priority: governanceActionSelection && governanceActionSelection.selectedAction
        ? governanceActionSelection.selectedAction.priority
        : null,
      action_selection_source: governanceActionSelection ? governanceActionSelection.selectionSource : null,
      action_selection_explain: governanceActionSelection ? governanceActionSelection.selectionExplain || null : null,
      execution_mode: executionMode,
      applied_patch: roundPatch,
      patch_reasons: [
        ...(governanceActionSelection && governanceActionSelection.selectionExplain
          ? [`governance-action: ${governanceActionSelection.selectionExplain.reason}`]
          : []),
        ...(Array.isArray(anomalyPatch.reasons) ? anomalyPatch.reasons : []),
        ...(summary.program_gate_auto_remediation && Array.isArray(summary.program_gate_auto_remediation.reasons)
          ? summary.program_gate_auto_remediation.reasons
          : [])
      ],
      failed_goals_before: failedGoalsBefore,
      failed_goals_after: failedGoalsAfter
    });

    summary = roundSummary;
    if (
      summary.program_gate_effective &&
      summary.program_gate_effective.passed &&
      !isSpecSessionBudgetHardFailure(summary) &&
      !isSpecSessionGrowthGuardHardFailure(summary)
    ) {
      if (!anomalyEnabled) {
        stopReason = 'gate-stable';
        break;
      }
      const postTrend = await buildAutoKpiTrend(projectPath, {
        weeks: anomalyWeeks,
        mode: 'program',
        period: anomalyPeriod
      });
      const postAnomalies = Array.isArray(postTrend.anomalies) ? postTrend.anomalies : [];
      summary.program_kpi_trend = {
        generated_at: postTrend.generated_at,
        weeks: postTrend.weeks,
        period_unit: postTrend.period_unit,
        total_runs: postTrend.total_runs,
        overall: postTrend.overall,
        anomaly_detection: postTrend.anomaly_detection || null
      };
      summary.program_kpi_anomalies = postAnomalies;
      const hasHighPostAnomaly = postAnomalies.some(item => `${item && item.severity ? item.severity : ''}`.trim().toLowerCase() === 'high');
      if (!hasHighPostAnomaly) {
        stopReason = 'stable';
        settled = true;
        break;
      }
    }
  }

  if (!settled && history.length >= maxRounds && stopReason === 'stable') {
    stopReason = 'round-limit-reached';
    exhausted = true;
  }
  if (!settled && history.length >= maxRounds && stopReason !== 'stable') {
    exhausted = true;
  }

  return {
    summary,
    governance: {
      enabled: true,
      anomaly_enabled: anomalyEnabled,
      anomaly_weeks: anomalyWeeks,
      anomaly_period: anomalyPeriod,
      auto_action_enabled: governAutoActionEnabled,
      action_selection_enabled: governActionEnabled,
      pinned_action_index: governUseAction,
      max_rounds: maxRounds,
      max_minutes: maxDurationMinutes,
      performed_rounds: history.length,
      converged: Boolean(
        summary &&
        summary.program_gate_effective &&
        summary.program_gate_effective.passed &&
        !isSpecSessionBudgetHardFailure(summary) &&
        !isSpecSessionGrowthGuardHardFailure(summary)
      ),
      exhausted,
      stop_reason: stopReason,
      history
    }
  };
}

async function applyProgramGateAutoRemediation(summary, context = {}) {
  const projectPath = context && context.projectPath ? context.projectPath : process.cwd();
  const options = context && context.options && typeof context.options === 'object'
    ? context.options
    : {};
  const gate = summary && summary.program_gate && typeof summary.program_gate === 'object'
    ? summary.program_gate
    : null;
  const policy = gate && gate.policy && typeof gate.policy === 'object' ? gate.policy : {};
  const reasons = Array.isArray(gate && gate.reasons) ? gate.reasons : [];
  const actions = [];
  const nextRunPatch = {};

  const maxAgentBudget = Number(policy.max_agent_budget);
  if (
    reasons.some(reason => `${reason || ''}`.includes('agent_budget')) &&
    Number.isFinite(maxAgentBudget) &&
    maxAgentBudget > 0
  ) {
    const currentAgentBudget = Number(options.batchAgentBudget || (summary && summary.batch_parallel) || 0);
    nextRunPatch.batchAgentBudget = maxAgentBudget;
    nextRunPatch.batchParallel = Math.max(1, Math.min(currentAgentBudget || maxAgentBudget, maxAgentBudget));
    actions.push({
      type: 'reduce-agent-budget',
      applied: true,
      details: `Set batchAgentBudget=${nextRunPatch.batchAgentBudget}, batchParallel=${nextRunPatch.batchParallel}.`
    });
  }

  const maxTotalSubSpecs = Number(policy.max_total_sub_specs);
  if (
    reasons.some(reason => `${reason || ''}`.includes('total_sub_specs')) &&
    Number.isFinite(maxTotalSubSpecs) &&
    maxTotalSubSpecs > 0
  ) {
    const avgSubSpecs = Number(summary && summary.metrics && summary.metrics.average_sub_specs_per_goal) || 1;
    const totalGoals = Number(summary && summary.total_goals) || 2;
    const suggestedProgramGoals = Math.max(2, Math.min(totalGoals, Math.floor(maxTotalSubSpecs / Math.max(1, avgSubSpecs))));
    nextRunPatch.programGoals = suggestedProgramGoals;
    actions.push({
      type: 'shrink-goal-width',
      applied: true,
      details: `Set programGoals=${suggestedProgramGoals} using max_total_sub_specs=${maxTotalSubSpecs}.`
    });
  }

  const maxElapsedMinutes = Number(policy.max_elapsed_minutes);
  if (
    reasons.some(reason => `${reason || ''}`.includes('program_elapsed_minutes')) &&
    Number.isFinite(maxElapsedMinutes) &&
    maxElapsedMinutes > 0
  ) {
    const totalGoals = Number(summary && summary.total_goals) || 2;
    const reducedProgramGoals = Math.max(2, Math.min(totalGoals, Math.ceil(totalGoals * 0.8)));
    nextRunPatch.programGoals = Math.min(
      Number(nextRunPatch.programGoals) || reducedProgramGoals,
      reducedProgramGoals
    );
    nextRunPatch.batchRetryRounds = 0;
    actions.push({
      type: 'time-budget-constrain',
      applied: true,
      details: `Set programGoals=${nextRunPatch.programGoals}, batchRetryRounds=0 for elapsed budget ${maxElapsedMinutes}m.`
    });
  }

  let appliedSpecPrune = null;
  const specBudget = summary && summary.spec_session_budget && summary.spec_session_budget.enabled
    ? summary.spec_session_budget
    : null;
  if (specBudget && specBudget.over_limit_after && Number.isFinite(Number(specBudget.max_total))) {
    try {
      const currentRunSpecNames = collectSpecNamesFromBatchSummary(summary || {});
      appliedSpecPrune = await pruneSpecSessions(projectPath, {
        keep: Number(specBudget.max_total),
        olderThanDays: null,
        dryRun: false,
        protectActive: true,
        protectWindowDays: options.specSessionProtectWindowDays,
        additionalProtectedSpecs: currentRunSpecNames
      });
      summary.spec_session_auto_prune = appliedSpecPrune;
      const specsAfter = await readSpecSessionEntries(projectPath);
      const totalAfter = specsAfter.length;
      const prunedCount = Number(appliedSpecPrune && appliedSpecPrune.deleted_count) || 0;
      summary.spec_session_budget = {
        ...specBudget,
        total_after: totalAfter,
        pruned_count: (Number(specBudget.pruned_count) || 0) + prunedCount,
        estimated_created: Math.max(0, totalAfter + ((Number(specBudget.pruned_count) || 0) + prunedCount) - specBudget.total_before),
        over_limit_after: totalAfter > specBudget.max_total,
        hard_fail_triggered: Boolean(specBudget.hard_fail && totalAfter > specBudget.max_total)
      };
      actions.push({
        type: 'trigger-spec-prune',
        applied: true,
        details: `Pruned specs to enforce max_total=${specBudget.max_total}. deleted=${appliedSpecPrune.deleted_count}`
      });
    } catch (error) {
      actions.push({
        type: 'trigger-spec-prune',
        applied: false,
        error: error.message
      });
    }
  }

  const hasPatch = Object.keys(nextRunPatch).length > 0;
  return {
    enabled: true,
    attempted_at: new Date().toISOString(),
    reason_count: reasons.length,
    reasons,
    actions,
    next_run_patch: hasPatch ? nextRunPatch : null,
    applied_spec_prune: appliedSpecPrune
  };
}

function normalizeFailureSignatureFromError(errorMessage) {
  if (typeof errorMessage !== 'string' || !errorMessage.trim()) {
    return 'no-error-details';
  }

  return errorMessage
    .toLowerCase()
    .replace(/[0-9]+/g, '#')
    .replace(/[a-z]:\\[^ ]+/gi, '<path>')
    .replace(/\/[^ ]+/g, '<path>')
    .replace(/["'`]/g, '')
    .replace(/\s+/g, ' ')
    .trim()
    .slice(0, 120);
}

function buildProgramFailureClusters(results) {
  const failedStatuses = new Set(['failed', 'error', 'unknown', 'stopped']);
  const source = Array.isArray(results) ? results : [];
  const clusters = new Map();

  for (const item of source) {
    if (!item || typeof item !== 'object') {
      continue;
    }
    const status = `${item.status || 'unknown'}`.trim().toLowerCase();
    if (!failedStatuses.has(status)) {
      continue;
    }

    const signatureSeed = normalizeFailureSignatureFromError(item.error);
    const signature = `${status}:${signatureSeed}`;
    if (!clusters.has(signature)) {
      clusters.set(signature, {
        signature,
        status,
        count: 0,
        goal_indexes: [],
        example_goal: item.goal || null,
        example_error: item.error || null
      });
    }

    const cluster = clusters.get(signature);
    cluster.count += 1;
    const sourceIndex = Number.isInteger(item.source_index) ? item.source_index + 1 : Number(item.index);
    if (Number.isInteger(sourceIndex) && sourceIndex > 0) {
      cluster.goal_indexes.push(sourceIndex);
    }
  }

  return [...clusters.values()]
    .sort((left, right) => {
      if (right.count !== left.count) {
        return right.count - left.count;
      }
      return `${left.signature}`.localeCompare(`${right.signature}`);
    })
    .map(cluster => ({
      ...cluster,
      goal_indexes: cluster.goal_indexes.slice(0, 20)
    }));
}

function buildProgramRemediationActions(summary, failureClusters) {
  const failedGoals = Number(summary && summary.failed_goals) || 0;
  const retry = summary && summary.batch_retry ? summary.batch_retry : {};
  const actions = [];

  if (failedGoals === 0) {
    return [{
      priority: 'monitor',
      action: 'No remediation required. Program converged successfully.',
      reason: 'All goals completed in the current run.',
      suggested_command: null,
      strategy_patch: {}
    }];
  }

  actions.push({
    priority: 'high',
    action: 'Resume unresolved goals from latest program/batch summary.',
    reason: `${failedGoals} goals are unresolved after the current run.`,
    suggested_command: 'kse auto close-loop-recover latest --json',
    strategy_patch: {
      batchAutonomous: true,
      continueOnError: true,
      batchRetryUntilComplete: true
    }
  });

  if ((Number(retry.max_rounds) || 0) > 0 && (Number(retry.performed_rounds) || 0) >= (Number(retry.max_rounds) || 0)) {
    actions.push({
      priority: 'high',
      action: 'Increase retry ceiling or split the program into smaller sub-goal groups.',
      reason: 'Retry rounds were exhausted before convergence.',
      suggested_command: 'kse auto close-loop-recover latest --batch-retry-max-rounds 15 --json',
      strategy_patch: {
        batchRetryUntilComplete: true,
        batchRetryMaxRounds: 15
      }
    });
  }

  const failureText = (Array.isArray(failureClusters) ? failureClusters : [])
    .map(cluster => `${cluster.signature} ${cluster.example_error || ''}`)
    .join(' | ')
    .toLowerCase();

  if (/timeout|timed out|deadline|terminated|killed/.test(failureText)) {
    actions.push({
      priority: 'medium',
      action: 'Reduce parallel pressure and increase orchestration timeout budget.',
      reason: 'Failure clusters indicate timeout/resource-pressure symptoms.',
      suggested_command: 'kse auto close-loop-recover latest --batch-parallel 2 --batch-agent-budget 2 --json',
      strategy_patch: {
        batchParallel: 2,
        batchAgentBudget: 2,
        batchPriority: 'complex-first',
        batchAgingFactor: 2
      }
    });
  }

  if (/dod|test|validation|checklist|compliance/.test(failureText)) {
    actions.push({
      priority: 'medium',
      action: 'Run strict quality gates early to surface deterministic failures.',
      reason: 'Failure clusters indicate DoD/test/compliance gate issues.',
      suggested_command: 'kse auto close-loop-recover latest --dod-tests "npm run test:smoke" --dod-tasks-closed --json',
      strategy_patch: {
        dodTests: 'npm run test:smoke',
        dodTasksClosed: true
      }
    });
  }

  return actions.slice(0, 5);
}

function buildProgramDiagnostics(summary) {
  const failureClusters = buildProgramFailureClusters(summary && summary.results);
  return {
    failed_goal_count: Number(summary && summary.failed_goals) || 0,
    failure_clusters: failureClusters,
    remediation_actions: buildProgramRemediationActions(summary, failureClusters)
  };
}

async function maybeWriteProgramKpi(summary, outCandidate, projectPath) {
  if (!outCandidate) {
    return;
  }

  const outputPath = path.isAbsolute(outCandidate)
    ? outCandidate
    : path.join(projectPath, outCandidate);
  await fs.ensureDir(path.dirname(outputPath));
  await fs.writeJson(outputPath, {
    mode: summary.mode === 'auto-close-loop-recover'
      ? 'auto-close-loop-recover-kpi'
      : 'auto-close-loop-program-kpi',
    program_mode: summary.mode,
    status: summary.status,
    program_started_at: summary.program_started_at || null,
    program_completed_at: summary.program_completed_at || null,
    program_elapsed_ms: Number.isFinite(Number(summary.program_elapsed_ms))
      ? Number(summary.program_elapsed_ms)
      : null,
    total_goals: summary.total_goals,
    processed_goals: summary.processed_goals,
    completed_goals: summary.completed_goals,
    failed_goals: summary.failed_goals,
    metrics: summary.metrics,
    program_kpi: summary.program_kpi,
    program_diagnostics: summary.program_diagnostics,
    program_coordination: summary.program_coordination || null,
    auto_recovery: summary.auto_recovery || null,
    program_governance: summary.program_governance || null,
    program_kpi_trend: summary.program_kpi_trend || null,
    program_kpi_anomalies: Array.isArray(summary.program_kpi_anomalies) ? summary.program_kpi_anomalies : [],
    goal_input_guard: summary.goal_input_guard || null,
    spec_session_budget: summary.spec_session_budget || null,
    spec_session_growth_guard: summary.spec_session_growth_guard || null,
    spec_session_auto_prune: summary.spec_session_auto_prune || null,
    program_gate_auto_remediation: summary.program_gate_auto_remediation || null,
    program_gate: summary.program_gate || null,
    program_gate_fallback: summary.program_gate_fallback || null,
    program_gate_fallbacks: summary.program_gate_fallbacks || [],
    program_gate_effective: summary.program_gate_effective || null
  }, { spaces: 2 });
  summary.program_kpi_file = outputPath;
}

async function maybeWriteProgramAudit(summary, outCandidate, projectPath) {
  if (!outCandidate) {
    return;
  }
  const outputPath = path.isAbsolute(outCandidate)
    ? outCandidate
    : path.join(projectPath, outCandidate);
  await fs.ensureDir(path.dirname(outputPath));
  await fs.writeJson(outputPath, {
    mode: 'auto-close-loop-program-audit',
    generated_at: new Date().toISOString(),
    summary_mode: summary && summary.mode ? summary.mode : null,
    status: summary && summary.status ? summary.status : null,
    program_started_at: summary && summary.program_started_at ? summary.program_started_at : null,
    program_completed_at: summary && summary.program_completed_at ? summary.program_completed_at : null,
    program_elapsed_ms: Number.isFinite(Number(summary && summary.program_elapsed_ms))
      ? Number(summary && summary.program_elapsed_ms)
      : null,
    totals: {
      total_goals: Number(summary && summary.total_goals) || 0,
      processed_goals: Number(summary && summary.processed_goals) || 0,
      completed_goals: Number(summary && summary.completed_goals) || 0,
      failed_goals: Number(summary && summary.failed_goals) || 0
    },
    metrics: summary && summary.metrics ? summary.metrics : null,
    batch_retry: summary && summary.batch_retry ? summary.batch_retry : null,
    program_kpi: summary && summary.program_kpi ? summary.program_kpi : null,
    program_diagnostics: summary && summary.program_diagnostics ? summary.program_diagnostics : null,
    program_coordination: summary && summary.program_coordination ? summary.program_coordination : null,
    program_gate: summary && summary.program_gate ? summary.program_gate : null,
    program_gate_fallback: summary && summary.program_gate_fallback ? summary.program_gate_fallback : null,
    program_gate_fallbacks: Array.isArray(summary && summary.program_gate_fallbacks) ? summary.program_gate_fallbacks : [],
    program_gate_effective: summary && summary.program_gate_effective ? summary.program_gate_effective : null,
    auto_recovery: summary && summary.auto_recovery ? summary.auto_recovery : null,
    program_governance: summary && summary.program_governance ? summary.program_governance : null,
    program_kpi_trend: summary && summary.program_kpi_trend ? summary.program_kpi_trend : null,
    program_kpi_anomalies: Array.isArray(summary && summary.program_kpi_anomalies) ? summary.program_kpi_anomalies : [],
    recovery_cycle: summary && summary.recovery_cycle ? summary.recovery_cycle : null,
    recovery_plan: summary && summary.recovery_plan ? summary.recovery_plan : null,
    recovery_memory: summary && summary.recovery_memory ? summary.recovery_memory : null,
    goal_input_guard: summary && summary.goal_input_guard ? summary.goal_input_guard : null,
    spec_session_prune: summary && summary.spec_session_prune ? summary.spec_session_prune : null,
    spec_session_budget: summary && summary.spec_session_budget ? summary.spec_session_budget : null,
    spec_session_growth_guard: summary && summary.spec_session_growth_guard ? summary.spec_session_growth_guard : null,
    spec_session_auto_prune: summary && summary.spec_session_auto_prune ? summary.spec_session_auto_prune : null,
    program_gate_auto_remediation: summary && summary.program_gate_auto_remediation ? summary.program_gate_auto_remediation : null,
    resource_plan: summary && summary.resource_plan ? summary.resource_plan : null,
    results: Array.isArray(summary && summary.results) ? summary.results : []
  }, { spaces: 2 });
  summary.program_audit_file = outputPath;
}

function normalizeBatchSessionKeep(keepCandidate) {
  if (keepCandidate === undefined || keepCandidate === null) {
    return null;
  }

  const parsed = Number(keepCandidate);
  if (!Number.isInteger(parsed) || parsed < 0 || parsed > 1000) {
    throw new Error('--batch-session-keep must be an integer between 0 and 1000.');
  }
  return parsed;
}

function normalizeBatchSessionOlderThanDays(daysCandidate) {
  if (daysCandidate === undefined || daysCandidate === null) {
    return null;
  }

  const parsed = Number(daysCandidate);
  if (!Number.isInteger(parsed) || parsed < 0 || parsed > 36500) {
    throw new Error('--batch-session-older-than-days must be an integer between 0 and 36500.');
  }
  return parsed;
}

function sanitizeBatchSessionId(value) {
  return `${value || ''}`
    .replace(/[^a-zA-Z0-9._-]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .slice(0, 80);
}

function createBatchSessionId() {
  const timestamp = new Date().toISOString().replace(/[-:.TZ]/g, '');
  return `batch-${timestamp}`;
}

function getCloseLoopControllerSessionDir(projectPath) {
  return path.join(projectPath, '.kiro', 'auto', 'close-loop-controller-sessions');
}

function createControllerSessionId() {
  const timestamp = new Date().toISOString().replace(/[-:.TZ]/g, '');
  return `controller-${timestamp}`;
}

function getGovernanceCloseLoopSessionDir(projectPath) {
  return path.join(projectPath, '.kiro', 'auto', 'governance-close-loop-sessions');
}

function createGovernanceCloseLoopSessionId() {
  const timestamp = new Date().toISOString().replace(/[-:.TZ]/g, '');
  return `governance-${timestamp}`;
}

async function readGovernanceCloseLoopSessionEntries(projectPath) {
  const sessionDir = getGovernanceCloseLoopSessionDir(projectPath);
  if (!(await fs.pathExists(sessionDir))) {
    return [];
  }

  const files = (await fs.readdir(sessionDir))
    .filter(item => item.toLowerCase().endsWith('.json'));
  const sessions = [];

  for (const file of files) {
    const filePath = path.join(sessionDir, file);
    const stats = await fs.stat(filePath);
    const fallbackTimestamp = new Date(stats.mtimeMs).toISOString();
    const fallbackId = path.basename(file, '.json');
    let payload = null;
    let parseError = null;

    try {
      payload = await fs.readJson(filePath);
    } catch (error) {
      parseError = error;
    }

    sessions.push({
      id: payload && payload.governance_session && payload.governance_session.id
        ? payload.governance_session.id
        : fallbackId,
      file: filePath,
      mode: payload && typeof payload.mode === 'string'
        ? payload.mode
        : parseError
          ? 'invalid'
          : 'unknown',
      status: payload && typeof payload.status === 'string'
        ? payload.status
        : parseError
          ? 'invalid'
          : 'unknown',
      target_risk: payload && typeof payload.target_risk === 'string' ? payload.target_risk : null,
      final_risk: payload && payload.final_assessment && payload.final_assessment.health &&
        typeof payload.final_assessment.health.risk_level === 'string'
        ? payload.final_assessment.health.risk_level
        : null,
      performed_rounds: payload && Number.isInteger(Number(payload.performed_rounds))
        ? Number(payload.performed_rounds)
        : null,
      max_rounds: payload && Number.isInteger(Number(payload.max_rounds))
        ? Number(payload.max_rounds)
        : null,
      converged: payload && typeof payload.converged === 'boolean'
        ? payload.converged
        : null,
      execute_advisory: payload && typeof payload.execute_advisory === 'boolean'
        ? payload.execute_advisory
        : null,
      advisory_failed_actions: payload && payload.advisory_summary &&
        Number.isInteger(Number(payload.advisory_summary.failed_actions))
        ? Number(payload.advisory_summary.failed_actions)
        : null,
      stop_reason: payload && typeof payload.stop_reason === 'string'
        ? payload.stop_reason
        : null,
      resumed_from_governance_session_id:
        payload &&
        payload.resumed_from_governance_session &&
        typeof payload.resumed_from_governance_session.id === 'string'
          ? payload.resumed_from_governance_session.id
          : null,
      updated_at: payload && typeof payload.updated_at === 'string'
        ? payload.updated_at
        : fallbackTimestamp,
      parse_error: parseError ? parseError.message : null,
      mtime_ms: stats.mtimeMs
    });
  }

  sessions.sort((a, b) => b.mtime_ms - a.mtime_ms);
  return sessions;
}

async function resolveGovernanceCloseLoopSessionFile(projectPath, sessionCandidate) {
  if (typeof sessionCandidate !== 'string' || !sessionCandidate.trim()) {
    throw new Error('--governance-resume requires a session id/file or "latest".');
  }
  const normalizedCandidate = sessionCandidate.trim();

  if (normalizedCandidate.toLowerCase() === 'latest') {
    const sessions = await readGovernanceCloseLoopSessionEntries(projectPath);
    if (sessions.length === 0) {
      throw new Error(`No governance close-loop sessions found in: ${getGovernanceCloseLoopSessionDir(projectPath)}`);
    }
    return sessions[0].file;
  }

  if (path.isAbsolute(normalizedCandidate)) {
    return normalizedCandidate;
  }
  if (
    normalizedCandidate.includes('/') ||
    normalizedCandidate.includes('\\') ||
    normalizedCandidate.toLowerCase().endsWith('.json')
  ) {
    return path.join(projectPath, normalizedCandidate);
  }

  const byId = path.join(
    getGovernanceCloseLoopSessionDir(projectPath),
    `${sanitizeBatchSessionId(normalizedCandidate)}.json`
  );
  if (await fs.pathExists(byId)) {
    return byId;
  }
  return path.join(projectPath, normalizedCandidate);
}

async function loadGovernanceCloseLoopSessionPayload(projectPath, sessionCandidate) {
  const sessionFile = await resolveGovernanceCloseLoopSessionFile(projectPath, sessionCandidate);
  if (!(await fs.pathExists(sessionFile))) {
    throw new Error(`Governance close-loop session file not found: ${sessionFile}`);
  }
  let payload = null;
  try {
    payload = await fs.readJson(sessionFile);
  } catch (error) {
    throw new Error(`Invalid governance close-loop session JSON: ${sessionFile} (${error.message})`);
  }
  if (!payload || typeof payload !== 'object') {
    throw new Error(`Invalid governance close-loop session payload: ${sessionFile}`);
  }
  const sessionId = payload && payload.governance_session && payload.governance_session.id
    ? payload.governance_session.id
    : path.basename(sessionFile, '.json');
  return {
    id: sessionId,
    file: sessionFile,
    payload
  };
}

async function persistGovernanceCloseLoopSession(projectPath, sessionId, payload, status = 'running') {
  const safeSessionId = sanitizeBatchSessionId(sessionId);
  if (!safeSessionId) {
    return null;
  }
  const sessionDir = getGovernanceCloseLoopSessionDir(projectPath);
  const sessionFile = path.join(sessionDir, `${safeSessionId}.json`);
  const persisted = {
    ...payload,
    schema_version: AUTO_ARCHIVE_SCHEMA_VERSION,
    status,
    governance_session: {
      id: safeSessionId,
      file: sessionFile
    },
    updated_at: new Date().toISOString()
  };
  await fs.ensureDir(sessionDir);
  await fs.writeJson(sessionFile, persisted, { spaces: 2 });
  return {
    id: safeSessionId,
    file: sessionFile
  };
}

async function readCloseLoopControllerSessionEntries(projectPath) {
  const sessionDir = getCloseLoopControllerSessionDir(projectPath);
  if (!(await fs.pathExists(sessionDir))) {
    return [];
  }

  const files = (await fs.readdir(sessionDir))
    .filter(item => item.toLowerCase().endsWith('.json'));
  const sessions = [];
  for (const file of files) {
    const filePath = path.join(sessionDir, file);
    const stats = await fs.stat(filePath);
    const fallbackTimestamp = new Date(stats.mtimeMs).toISOString();
    const fallbackId = path.basename(file, '.json');
    let payload = null;
    let parseError = null;

    try {
      payload = await fs.readJson(filePath);
    } catch (error) {
      parseError = error;
    }

    sessions.push({
      id: payload && typeof payload.controller_session === 'object' && typeof payload.controller_session.id === 'string'
        ? payload.controller_session.id
        : fallbackId,
      file: filePath,
      status: payload && typeof payload.status === 'string'
        ? payload.status
        : parseError
          ? 'invalid'
          : 'unknown',
      queue_file: payload && typeof payload.queue_file === 'string' ? payload.queue_file : null,
      queue_format: payload && typeof payload.queue_format === 'string' ? payload.queue_format : null,
      processed_goals: payload && Number.isFinite(Number(payload.processed_goals))
        ? Number(payload.processed_goals)
        : null,
      pending_goals: payload && Number.isFinite(Number(payload.pending_goals))
        ? Number(payload.pending_goals)
        : null,
      updated_at: payload && typeof payload.updated_at === 'string'
        ? payload.updated_at
        : fallbackTimestamp,
      parse_error: parseError ? parseError.message : null,
      mtime_ms: stats.mtimeMs
    });
  }

  sessions.sort((a, b) => b.mtime_ms - a.mtime_ms);
  return sessions;
}

async function resolveCloseLoopControllerSessionFile(projectPath, sessionCandidate) {
  if (typeof sessionCandidate !== 'string' || !sessionCandidate.trim()) {
    throw new Error('--controller-resume requires a session id/file or "latest".');
  }

  const normalizedCandidate = sessionCandidate.trim();
  if (normalizedCandidate.toLowerCase() === 'latest') {
    const sessions = await readCloseLoopControllerSessionEntries(projectPath);
    if (sessions.length === 0) {
      throw new Error(`No controller sessions found in: ${getCloseLoopControllerSessionDir(projectPath)}`);
    }
    return sessions[0].file;
  }

  if (path.isAbsolute(normalizedCandidate)) {
    return normalizedCandidate;
  }
  if (
    normalizedCandidate.includes('/') ||
    normalizedCandidate.includes('\\') ||
    normalizedCandidate.toLowerCase().endsWith('.json')
  ) {
    return path.join(projectPath, normalizedCandidate);
  }

  const byId = path.join(
    getCloseLoopControllerSessionDir(projectPath),
    `${sanitizeBatchSessionId(normalizedCandidate)}.json`
  );
  if (await fs.pathExists(byId)) {
    return byId;
  }
  return path.join(projectPath, normalizedCandidate);
}

async function loadCloseLoopControllerSessionPayload(projectPath, sessionCandidate) {
  const sessionFile = await resolveCloseLoopControllerSessionFile(projectPath, sessionCandidate);
  if (!(await fs.pathExists(sessionFile))) {
    throw new Error(`Controller session file not found: ${sessionFile}`);
  }
  let payload = null;
  try {
    payload = await fs.readJson(sessionFile);
  } catch (error) {
    throw new Error(`Invalid controller session JSON: ${sessionFile} (${error.message})`);
  }
  const sessionId = payload && payload.controller_session && payload.controller_session.id
    ? payload.controller_session.id
    : path.basename(sessionFile, '.json');
  return {
    id: sessionId,
    file: sessionFile,
    payload: payload || {}
  };
}

async function pruneCloseLoopControllerSessions(projectPath, policy = {}) {
  const keep = policy.keep;
  const olderThanDays = policy.olderThanDays;
  const currentFile = policy.currentFile || null;
  const dryRun = Boolean(policy.dryRun);
  const sessions = await readCloseLoopControllerSessionEntries(projectPath);
  const cutoffMs = olderThanDays === null
    ? null
    : Date.now() - (olderThanDays * 24 * 60 * 60 * 1000);

  const keepLimit = Number.isInteger(keep) ? keep : Number.POSITIVE_INFINITY;
  const deletable = [];
  for (let index = 0; index < sessions.length; index += 1) {
    const session = sessions[index];
    if (session.file === currentFile) {
      continue;
    }
    const beyondKeep = Number.isFinite(keepLimit) ? index >= keepLimit : true;
    const beyondAge = cutoffMs === null || session.mtime_ms < cutoffMs;
    if (beyondKeep && beyondAge) {
      deletable.push(session);
    }
  }

  const deleted = [];
  const errors = [];
  if (!dryRun) {
    for (const session of deletable) {
      try {
        await fs.remove(session.file);
        deleted.push(session);
      } catch (error) {
        errors.push({
          id: session.id,
          file: session.file,
          error: error.message
        });
      }
    }
  }

  return {
    enabled: true,
    session_dir: getCloseLoopControllerSessionDir(projectPath),
    dry_run: dryRun,
    criteria: {
      keep: Number.isFinite(keepLimit) ? keepLimit : null,
      older_than_days: olderThanDays
    },
    total_sessions: sessions.length,
    kept_sessions: sessions.length - deletable.length,
    deleted_count: dryRun ? deletable.length : deleted.length,
    candidates: deletable.map(item => ({
      id: item.id,
      file: item.file,
      status: item.status,
      updated_at: item.updated_at
    })),
    errors
  };
}

async function maybePersistCloseLoopControllerSummary(summary, options, projectPath) {
  if (options.controllerSession === false) {
    return;
  }

  const keep = normalizeControllerSessionKeep(options.controllerSessionKeep);
  const olderThanDays = normalizeControllerSessionOlderThanDays(options.controllerSessionOlderThanDays);
  const requestedId = typeof options.controllerSessionId === 'string' && options.controllerSessionId.trim()
    ? sanitizeBatchSessionId(options.controllerSessionId.trim())
    : null;
  const sessionId = requestedId || createControllerSessionId();
  if (!sessionId) {
    throw new Error('--controller-session-id is invalid after sanitization.');
  }

  const sessionDir = getCloseLoopControllerSessionDir(projectPath);
  const sessionFile = path.join(sessionDir, `${sessionId}.json`);
  summary.controller_session = {
    id: sessionId,
    file: sessionFile
  };
  summary.schema_version = AUTO_ARCHIVE_SCHEMA_VERSION;

  await fs.ensureDir(sessionDir);
  await fs.writeJson(sessionFile, {
    ...summary,
    schema_version: AUTO_ARCHIVE_SCHEMA_VERSION,
    controller_session: {
      id: sessionId,
      file: sessionFile
    },
    updated_at: new Date().toISOString()
  }, { spaces: 2 });

  if (keep !== null || olderThanDays !== null) {
    summary.controller_session_prune = await pruneCloseLoopControllerSessions(projectPath, {
      keep: keep === null ? null : keep,
      olderThanDays,
      currentFile: sessionFile,
      dryRun: false
    });
  }
}

async function readCloseLoopBatchSummaryEntries(projectPath) {
  const summaryDir = getCloseLoopBatchSummaryDir(projectPath);
  if (!(await fs.pathExists(summaryDir))) {
    return [];
  }

  const files = (await fs.readdir(summaryDir))
    .filter(item => item.toLowerCase().endsWith('.json'));
  const sessions = [];
  for (const file of files) {
    const filePath = path.join(summaryDir, file);
    const stats = await fs.stat(filePath);
    const fallbackTimestamp = new Date(stats.mtimeMs).toISOString();
    const fallbackId = path.basename(file, '.json');
    let payload = null;
    let parseError = null;

    try {
      payload = await fs.readJson(filePath);
    } catch (error) {
      parseError = error;
    }

    sessions.push({
      id: payload && typeof payload.batch_session === 'object' && typeof payload.batch_session.id === 'string'
        ? payload.batch_session.id
        : fallbackId,
      file: filePath,
      status: payload && typeof payload.status === 'string'
        ? payload.status
        : parseError
          ? 'invalid'
          : 'unknown',
      goals_file: payload && typeof payload.goals_file === 'string' ? payload.goals_file : null,
      total_goals: payload && Number.isInteger(Number(payload.total_goals)) ? Number(payload.total_goals) : null,
      processed_goals: payload && Number.isInteger(Number(payload.processed_goals)) ? Number(payload.processed_goals) : null,
      updated_at: payload && typeof payload.updated_at === 'string'
        ? payload.updated_at
        : fallbackTimestamp,
      parse_error: parseError ? parseError.message : null,
      mtime_ms: stats.mtimeMs
    });
  }

  sessions.sort((a, b) => b.mtime_ms - a.mtime_ms);
  return sessions;
}

function normalizeAutoKpiTrendWeeks(weeksCandidate) {
  if (weeksCandidate === undefined || weeksCandidate === null) {
    return 8;
  }
  const parsed = Number(weeksCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 260) {
    throw new Error('--weeks must be an integer between 1 and 260.');
  }
  return parsed;
}

function normalizeAutoKpiTrendPeriod(periodCandidate) {
  const normalized = typeof periodCandidate === 'string'
    ? periodCandidate.trim().toLowerCase()
    : 'week';
  if (!['week', 'day'].includes(normalized)) {
    throw new Error('--period must be one of: week, day.');
  }
  return normalized;
}

function normalizeAutoKpiTrendMode(modeCandidate) {
  const normalized = typeof modeCandidate === 'string'
    ? modeCandidate.trim().toLowerCase()
    : 'all';
  if (!['all', 'batch', 'program', 'recover', 'controller'].includes(normalized)) {
    throw new Error('--mode must be one of: all, batch, program, recover, controller.');
  }
  return normalized;
}

function summaryModeMatchesFilter(summaryMode, filterMode) {
  const normalizedMode = `${summaryMode || ''}`.trim().toLowerCase();
  if (filterMode === 'all') {
    return true;
  }
  if (filterMode === 'batch') {
    return normalizedMode === 'auto-close-loop-batch';
  }
  if (filterMode === 'program') {
    return normalizedMode === 'auto-close-loop-program';
  }
  if (filterMode === 'recover') {
    return normalizedMode === 'auto-close-loop-recover';
  }
  if (filterMode === 'controller') {
    return normalizedMode === 'auto-close-loop-controller';
  }
  return false;
}

function resolveAutoKpiSummaryModeCategory(summaryMode) {
  const normalizedMode = `${summaryMode || ''}`.trim().toLowerCase();
  if (normalizedMode === 'auto-close-loop-batch') {
    return 'batch';
  }
  if (normalizedMode === 'auto-close-loop-program') {
    return 'program';
  }
  if (normalizedMode === 'auto-close-loop-recover') {
    return 'recover';
  }
  if (normalizedMode === 'auto-close-loop-controller') {
    return 'controller';
  }
  return 'other';
}

function normalizeAutoKpiTrendControllerMetrics(payload, nestedMetrics) {
  const status = `${payload && payload.status ? payload.status : ''}`.trim().toLowerCase();
  const processedGoals = Number(payload && payload.processed_goals);
  const completedGoals = Number(payload && payload.completed_goals);
  const failedGoals = Number(payload && payload.failed_goals);
  const pendingGoals = Number(payload && payload.pending_goals);
  const processed = Number.isFinite(processedGoals) ? processedGoals : 0;
  const completed = Number.isFinite(completedGoals) ? completedGoals : 0;
  const failed = Number.isFinite(failedGoals) ? failedGoals : 0;
  const pending = Number.isFinite(pendingGoals) ? pendingGoals : 0;
  const successRate = processed > 0
    ? Number(((completed / processed) * 100).toFixed(2))
    : status === 'completed'
      ? 100
      : 0;
  const completionRate = (processed + pending) > 0
    ? Number(((processed / (processed + pending)) * 100).toFixed(2))
    : status === 'completed'
      ? 100
      : 0;
  return {
    status,
    completed: status === 'completed',
    gate_passed: status === 'completed' && failed === 0,
    success_rate_percent: successRate,
    completion_rate_percent: completionRate,
    failed_goals: failed,
    total_sub_specs: nestedMetrics.total_sub_specs,
    estimated_spec_created: nestedMetrics.estimated_spec_created,
    rate_limit_signals: nestedMetrics.total_rate_limit_signals,
    rate_limit_backoff_ms: nestedMetrics.total_rate_limit_backoff_ms
  };
}

async function loadAutoKpiTrendControllerNestedMetrics(projectPath, payload) {
  const results = Array.isArray(payload && payload.results) ? payload.results : [];
  let totalSubSpecs = 0;
  let estimatedSpecCreated = 0;
  let totalRateLimitSignals = 0;
  let totalRateLimitBackoffMs = 0;
  for (const item of results) {
    if (!item || typeof item.batch_session_file !== 'string' || !item.batch_session_file.trim()) {
      continue;
    }
    const nestedFile = path.isAbsolute(item.batch_session_file)
      ? item.batch_session_file
      : path.join(projectPath, item.batch_session_file);
    if (!(await fs.pathExists(nestedFile))) {
      continue;
    }
    try {
      const nested = await fs.readJson(nestedFile);
      const nestedTotalSubSpecs = Number(nested && nested.metrics && nested.metrics.total_sub_specs);
      const nestedEstimatedCreated = Number(
        nested && nested.spec_session_budget && nested.spec_session_budget.estimated_created
      );
      const nestedRateLimitSignals = Number(nested && nested.metrics && nested.metrics.total_rate_limit_signals);
      const nestedRateLimitBackoffMs = Number(nested && nested.metrics && nested.metrics.total_rate_limit_backoff_ms);
      totalSubSpecs += Number.isFinite(nestedTotalSubSpecs) ? nestedTotalSubSpecs : 0;
      estimatedSpecCreated += Number.isFinite(nestedEstimatedCreated) ? nestedEstimatedCreated : 0;
      totalRateLimitSignals += Number.isFinite(nestedRateLimitSignals) ? nestedRateLimitSignals : 0;
      totalRateLimitBackoffMs += Number.isFinite(nestedRateLimitBackoffMs) ? nestedRateLimitBackoffMs : 0;
    } catch (error) {
      continue;
    }
  }
  return {
    total_sub_specs: totalSubSpecs,
    estimated_spec_created: estimatedSpecCreated,
    total_rate_limit_signals: totalRateLimitSignals,
    total_rate_limit_backoff_ms: totalRateLimitBackoffMs
  };
}

async function readAutoKpiTrendSessionEntries(projectPath) {
  const [batchSessions, controllerSessions] = await Promise.all([
    readCloseLoopBatchSummaryEntries(projectPath),
    readCloseLoopControllerSessionEntries(projectPath)
  ]);
  const sessions = [
    ...batchSessions.map(session => ({ ...session, source: 'batch-summary' })),
    ...controllerSessions.map(session => ({ ...session, source: 'controller-session' }))
  ];
  sessions.sort((left, right) => Number(right.mtime_ms || 0) - Number(left.mtime_ms || 0));
  return sessions;
}

function getIsoWeekPeriodKey(dateCandidate) {
  const date = new Date(dateCandidate || Date.now());
  if (Number.isNaN(date.getTime())) {
    return null;
  }
  const utcDate = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
  const dayNum = utcDate.getUTCDay() || 7;
  utcDate.setUTCDate(utcDate.getUTCDate() + 4 - dayNum);
  const yearStart = new Date(Date.UTC(utcDate.getUTCFullYear(), 0, 1));
  const weekNo = Math.ceil((((utcDate - yearStart) / 86400000) + 1) / 7);
  return `${utcDate.getUTCFullYear()}-W${String(weekNo).padStart(2, '0')}`;
}

function getIsoDayPeriodKey(dateCandidate) {
  const date = new Date(dateCandidate || Date.now());
  if (Number.isNaN(date.getTime())) {
    return null;
  }
  const year = date.getUTCFullYear();
  const month = String(date.getUTCMonth() + 1).padStart(2, '0');
  const day = String(date.getUTCDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function resolveAutoKpiTrendPeriodKey(dateCandidate, periodUnit) {
  if (periodUnit === 'day') {
    return getIsoDayPeriodKey(dateCandidate);
  }
  return getIsoWeekPeriodKey(dateCandidate);
}

function calculateAverage(items, field) {
  const list = Array.isArray(items) ? items : [];
  if (list.length === 0) {
    return 0;
  }
  const sum = list.reduce((acc, item) => {
    const value = Number(item && item[field]);
    return acc + (Number.isFinite(value) ? value : 0);
  }, 0);
  return Number((sum / list.length).toFixed(2));
}

function evaluateAutoKpiTrendAnomalies(trend) {
  const buckets = Array.isArray(trend) ? trend : [];
  const thresholds = {
    success_rate_drop_percent: 20,
    failed_goals_spike: 2,
    spec_growth_spike: 3,
    rate_limit_signal_spike: 1
  };
  if (buckets.length < 2) {
    return {
      enabled: true,
      latest_period: null,
      baseline_window: 0,
      thresholds,
      baseline: {
        success_rate_percent: 0,
        average_failed_goals: 0,
        average_estimated_spec_created: 0,
        average_rate_limit_signals: 0
      },
      anomalies: []
    };
  }

  const latest = buckets[buckets.length - 1];
  const baselineBuckets = buckets.slice(0, -1);
  const baseline = {
    success_rate_percent: calculateAverage(baselineBuckets, 'success_rate_percent'),
    average_failed_goals: calculateAverage(baselineBuckets, 'average_failed_goals'),
    average_estimated_spec_created: calculateAverage(baselineBuckets, 'average_estimated_spec_created'),
    average_rate_limit_signals: calculateAverage(baselineBuckets, 'average_rate_limit_signals')
  };
  const anomalies = [];

  const successRateDrop = Number((baseline.success_rate_percent - Number(latest.success_rate_percent || 0)).toFixed(2));
  if (successRateDrop >= thresholds.success_rate_drop_percent) {
    anomalies.push({
      type: 'success-rate-drop',
      severity: successRateDrop >= 35 ? 'high' : 'medium',
      period: latest.period,
      metric: 'success_rate_percent',
      baseline_value: baseline.success_rate_percent,
      latest_value: Number(latest.success_rate_percent || 0),
      delta: Number((-successRateDrop).toFixed(2)),
      explain: `Latest success rate dropped by ${successRateDrop}% compared to baseline.`
    });
  }

  const failedGoalsSpike = Number((Number(latest.average_failed_goals || 0) - baseline.average_failed_goals).toFixed(2));
  if (failedGoalsSpike >= thresholds.failed_goals_spike) {
    anomalies.push({
      type: 'failed-goals-spike',
      severity: failedGoalsSpike >= 4 ? 'high' : 'medium',
      period: latest.period,
      metric: 'average_failed_goals',
      baseline_value: baseline.average_failed_goals,
      latest_value: Number(latest.average_failed_goals || 0),
      delta: failedGoalsSpike,
      explain: `Latest failed-goal average increased by ${failedGoalsSpike} compared to baseline.`
    });
  }

  const specGrowthSpike = Number(
    (Number(latest.average_estimated_spec_created || 0) - baseline.average_estimated_spec_created).toFixed(2)
  );
  if (specGrowthSpike >= thresholds.spec_growth_spike) {
    anomalies.push({
      type: 'spec-growth-spike',
      severity: specGrowthSpike >= 6 ? 'high' : 'medium',
      period: latest.period,
      metric: 'average_estimated_spec_created',
      baseline_value: baseline.average_estimated_spec_created,
      latest_value: Number(latest.average_estimated_spec_created || 0),
      delta: specGrowthSpike,
      explain: `Latest spec growth increased by ${specGrowthSpike} compared to baseline.`
    });
  }

  const rateLimitSignalSpike = Number(
    (Number(latest.average_rate_limit_signals || 0) - baseline.average_rate_limit_signals).toFixed(2)
  );
  if (rateLimitSignalSpike >= thresholds.rate_limit_signal_spike) {
    anomalies.push({
      type: 'rate-limit-spike',
      severity: rateLimitSignalSpike >= 2 ? 'high' : 'medium',
      period: latest.period,
      metric: 'average_rate_limit_signals',
      baseline_value: baseline.average_rate_limit_signals,
      latest_value: Number(latest.average_rate_limit_signals || 0),
      delta: rateLimitSignalSpike,
      explain: `Latest rate-limit pressure increased by ${rateLimitSignalSpike} signal(s) per run compared to baseline.`
    });
  }

  return {
    enabled: true,
    latest_period: latest.period,
    baseline_window: baselineBuckets.length,
    thresholds,
    baseline,
    anomalies
  };
}

function formatAutoKpiTrendCsvRow(values) {
  return values.map(value => {
    if (value === null || value === undefined) {
      return '';
    }
    const stringValue = `${value}`;
    if (!/[",\r\n]/.test(stringValue)) {
      return stringValue;
    }
    return `"${stringValue.replace(/"/g, '""')}"`;
  }).join(',');
}

function formatAutoKpiTrendCsv(result) {
  const header = [
    'period',
    'runs',
    'completed_runs',
    'non_completed_runs',
    'gate_passed_runs',
    'success_rate_percent',
    'completion_rate_percent',
    'average_failed_goals',
    'average_total_sub_specs',
    'average_estimated_spec_created',
    'average_rate_limit_signals',
    'average_rate_limit_backoff_ms',
    'is_overall'
  ];
  const rows = [formatAutoKpiTrendCsvRow(header)];
  const trendRows = Array.isArray(result && result.trend) ? result.trend : [];
  for (const item of trendRows) {
    rows.push(
      formatAutoKpiTrendCsvRow([
        item.period,
        item.runs,
        item.completed_runs,
        item.non_completed_runs,
        item.gate_passed_runs,
        item.success_rate_percent,
        item.completion_rate_percent,
        item.average_failed_goals,
        item.average_total_sub_specs,
        item.average_estimated_spec_created,
        item.average_rate_limit_signals,
        item.average_rate_limit_backoff_ms,
        false
      ])
    );
  }
  const overall = result && result.overall && typeof result.overall === 'object' ? result.overall : {};
  rows.push(
    formatAutoKpiTrendCsvRow([
      'overall',
      overall.runs,
      overall.completed_runs,
      overall.non_completed_runs,
      overall.gate_passed_runs,
      overall.success_rate_percent,
      overall.completion_rate_percent,
      overall.average_failed_goals,
      overall.average_total_sub_specs,
      overall.average_estimated_spec_created,
      overall.average_rate_limit_signals,
      overall.average_rate_limit_backoff_ms,
      true
    ])
  );
  return `${rows.join('\n')}\n`;
}

function finalizeAutoKpiTrendBucket(period, bucket) {
  const runs = bucket.runs || 0;
  const successRate = runs > 0
    ? Number((bucket.success_rate_sum / runs).toFixed(2))
    : 0;
  const completionRate = runs > 0
    ? Number((bucket.completion_rate_sum / runs).toFixed(2))
    : 0;
  const avgFailedGoals = runs > 0
    ? Number((bucket.failed_goals_sum / runs).toFixed(2))
    : 0;
  const avgTotalSubSpecs = runs > 0
    ? Number((bucket.total_sub_specs_sum / runs).toFixed(2))
    : 0;
  const avgEstimatedSpecCreated = runs > 0
    ? Number((bucket.estimated_spec_created_sum / runs).toFixed(2))
    : 0;
  const avgRateLimitSignals = runs > 0
    ? Number((bucket.rate_limit_signals_sum / runs).toFixed(2))
    : 0;
  const avgRateLimitBackoffMs = runs > 0
    ? Number((bucket.rate_limit_backoff_ms_sum / runs).toFixed(2))
    : 0;
  return {
    period,
    runs,
    completed_runs: bucket.completed_runs,
    non_completed_runs: bucket.non_completed_runs,
    gate_passed_runs: bucket.gate_passed_runs,
    success_rate_percent: successRate,
    completion_rate_percent: completionRate,
    average_failed_goals: avgFailedGoals,
    average_total_sub_specs: avgTotalSubSpecs,
    average_estimated_spec_created: avgEstimatedSpecCreated,
    average_rate_limit_signals: avgRateLimitSignals,
    average_rate_limit_backoff_ms: avgRateLimitBackoffMs
  };
}

async function buildAutoKpiTrend(projectPath, options = {}) {
  const weeks = normalizeAutoKpiTrendWeeks(options.weeks);
  const mode = normalizeAutoKpiTrendMode(options.mode);
  const periodUnit = normalizeAutoKpiTrendPeriod(options.period);
  const sessions = await readAutoKpiTrendSessionEntries(projectPath);
  const cutoffMs = Date.now() - (weeks * 7 * 24 * 60 * 60 * 1000);
  const buckets = new Map();
  let totalRuns = 0;
  const overall = {
    runs: 0,
    completed_runs: 0,
    non_completed_runs: 0,
    gate_passed_runs: 0,
    success_rate_sum: 0,
    completion_rate_sum: 0,
    failed_goals_sum: 0,
    total_sub_specs_sum: 0,
    estimated_spec_created_sum: 0,
    rate_limit_signals_sum: 0,
    rate_limit_backoff_ms_sum: 0
  };
  const modeBreakdown = {
    batch: 0,
    program: 0,
    recover: 0,
    controller: 0,
    other: 0
  };

  for (const session of sessions) {
    if (Number(session && session.mtime_ms) < cutoffMs) {
      continue;
    }
    let payload = null;
    try {
      payload = await fs.readJson(session.file);
    } catch (error) {
      continue;
    }
    if (!summaryModeMatchesFilter(payload && payload.mode, mode)) {
      continue;
    }
    const modeCategory = resolveAutoKpiSummaryModeCategory(payload && payload.mode);
    modeBreakdown[modeCategory] += 1;

    const timestamp = payload.program_completed_at || payload.updated_at || session.updated_at;
    const period = resolveAutoKpiTrendPeriodKey(timestamp, periodUnit);
    if (!period) {
      continue;
    }

    if (!buckets.has(period)) {
      buckets.set(period, {
        runs: 0,
        completed_runs: 0,
        non_completed_runs: 0,
        gate_passed_runs: 0,
        success_rate_sum: 0,
        completion_rate_sum: 0,
        failed_goals_sum: 0,
        total_sub_specs_sum: 0,
        estimated_spec_created_sum: 0,
        rate_limit_signals_sum: 0,
        rate_limit_backoff_ms_sum: 0
      });
    }
    const bucket = buckets.get(period);
    const normalizedSummaryMode = `${payload && payload.mode ? payload.mode : ''}`.trim().toLowerCase();
    let metrics = null;
    if (normalizedSummaryMode === 'auto-close-loop-controller') {
      const nestedMetrics = await loadAutoKpiTrendControllerNestedMetrics(projectPath, payload);
      metrics = normalizeAutoKpiTrendControllerMetrics(payload, nestedMetrics);
    } else {
      const status = `${payload && payload.status ? payload.status : ''}`.trim().toLowerCase();
      const completed = status === 'completed';
      metrics = {
        status,
        completed,
        gate_passed: Boolean(
          payload &&
          payload.program_gate_effective &&
          payload.program_gate_effective.passed !== undefined
            ? payload.program_gate_effective.passed
            : payload && payload.program_gate
              ? payload.program_gate.passed
              : completed
        ),
        success_rate_percent: Number(payload && payload.metrics && payload.metrics.success_rate_percent),
        completion_rate_percent: Number(payload && payload.program_kpi && payload.program_kpi.completion_rate_percent),
        failed_goals: Number(payload && payload.failed_goals),
        total_sub_specs: Number(payload && payload.metrics && payload.metrics.total_sub_specs),
        estimated_spec_created: Number(payload && payload.spec_session_budget && payload.spec_session_budget.estimated_created),
        rate_limit_signals: Number(payload && payload.metrics && payload.metrics.total_rate_limit_signals),
        rate_limit_backoff_ms: Number(payload && payload.metrics && payload.metrics.total_rate_limit_backoff_ms)
      };
    }
    const completed = Boolean(metrics.completed);
    const gatePassed = Boolean(metrics.gate_passed);
    const successRate = Number(metrics.success_rate_percent);
    const completionRate = Number(metrics.completion_rate_percent);
    const failedGoals = Number(metrics.failed_goals);
    const totalSubSpecs = Number(metrics.total_sub_specs);
    const estimatedSpecCreated = Number(metrics.estimated_spec_created);
    const rateLimitSignals = Number(metrics.rate_limit_signals);
    const rateLimitBackoffMs = Number(metrics.rate_limit_backoff_ms);

    bucket.runs += 1;
    bucket.completed_runs += completed ? 1 : 0;
    bucket.non_completed_runs += completed ? 0 : 1;
    bucket.gate_passed_runs += gatePassed ? 1 : 0;
    bucket.success_rate_sum += Number.isFinite(successRate) ? successRate : 0;
    bucket.completion_rate_sum += Number.isFinite(completionRate) ? completionRate : (Number.isFinite(successRate) ? successRate : 0);
    bucket.failed_goals_sum += Number.isFinite(failedGoals) ? failedGoals : 0;
    bucket.total_sub_specs_sum += Number.isFinite(totalSubSpecs) ? totalSubSpecs : 0;
    bucket.estimated_spec_created_sum += Number.isFinite(estimatedSpecCreated) ? estimatedSpecCreated : 0;
    bucket.rate_limit_signals_sum += Number.isFinite(rateLimitSignals) ? rateLimitSignals : 0;
    bucket.rate_limit_backoff_ms_sum += Number.isFinite(rateLimitBackoffMs) ? rateLimitBackoffMs : 0;

    overall.runs += 1;
    overall.completed_runs += completed ? 1 : 0;
    overall.non_completed_runs += completed ? 0 : 1;
    overall.gate_passed_runs += gatePassed ? 1 : 0;
    overall.success_rate_sum += Number.isFinite(successRate) ? successRate : 0;
    overall.completion_rate_sum += Number.isFinite(completionRate) ? completionRate : (Number.isFinite(successRate) ? successRate : 0);
    overall.failed_goals_sum += Number.isFinite(failedGoals) ? failedGoals : 0;
    overall.total_sub_specs_sum += Number.isFinite(totalSubSpecs) ? totalSubSpecs : 0;
    overall.estimated_spec_created_sum += Number.isFinite(estimatedSpecCreated) ? estimatedSpecCreated : 0;
    overall.rate_limit_signals_sum += Number.isFinite(rateLimitSignals) ? rateLimitSignals : 0;
    overall.rate_limit_backoff_ms_sum += Number.isFinite(rateLimitBackoffMs) ? rateLimitBackoffMs : 0;
    totalRuns += 1;
  }

  const trend = [...buckets.entries()]
    .sort((left, right) => left[0].localeCompare(right[0]))
    .map(([period, bucket]) => finalizeAutoKpiTrendBucket(period, bucket));
  const overallSummary = finalizeAutoKpiTrendBucket('overall', overall);
  const { period: _overallPeriod, ...overallSnapshot } = overallSummary;
  const anomalyDetection = evaluateAutoKpiTrendAnomalies(trend);

  return {
    mode: 'auto-kpi-trend',
    generated_at: new Date().toISOString(),
    weeks,
    window_days: weeks * 7,
    period_unit: periodUnit,
    mode_filter: mode,
    total_runs: totalRuns,
    mode_breakdown: modeBreakdown,
    trend,
    overall: overallSnapshot,
    anomaly_detection: anomalyDetection,
    anomalies: anomalyDetection.anomalies
  };
}

async function pruneCloseLoopBatchSummarySessions(projectPath, policy = {}) {
  const keep = policy.keep;
  const olderThanDays = policy.olderThanDays;
  const currentFile = policy.currentFile || null;
  const dryRun = Boolean(policy.dryRun);
  const sessions = await readCloseLoopBatchSummaryEntries(projectPath);
  const cutoffMs = olderThanDays === null
    ? null
    : Date.now() - (olderThanDays * 24 * 60 * 60 * 1000);

  const keepLimit = Number.isInteger(keep) ? keep : Number.POSITIVE_INFINITY;
  const deletable = [];
  for (let index = 0; index < sessions.length; index += 1) {
    const session = sessions[index];
    if (session.file === currentFile) {
      continue;
    }

    const beyondKeep = Number.isFinite(keepLimit) ? index >= keepLimit : true;
    const beyondAge = cutoffMs === null || session.mtime_ms < cutoffMs;
    if (beyondKeep && beyondAge) {
      deletable.push(session);
    }
  }

  const deleted = [];
  const errors = [];
  if (!dryRun) {
    for (const session of deletable) {
      try {
        await fs.remove(session.file);
        deleted.push(session);
      } catch (error) {
        errors.push({
          id: session.id,
          file: session.file,
          error: error.message
        });
      }
    }
  }

  return {
    enabled: true,
    session_dir: getCloseLoopBatchSummaryDir(projectPath),
    dry_run: dryRun,
    criteria: {
      keep: Number.isFinite(keepLimit) ? keepLimit : null,
      older_than_days: olderThanDays
    },
    total_sessions: sessions.length,
    kept_sessions: sessions.length - deletable.length,
    deleted_count: dryRun ? deletable.length : deleted.length,
    candidates: deletable.map(item => ({
      id: item.id,
      file: item.file,
      status: item.status,
      updated_at: item.updated_at
    })),
    errors
  };
}

async function maybePersistCloseLoopBatchSummary(summary, options, projectPath) {
  if (options.batchSession === false) {
    return;
  }

  const keep = normalizeBatchSessionKeep(options.batchSessionKeep);
  const olderThanDays = normalizeBatchSessionOlderThanDays(options.batchSessionOlderThanDays);
  const requestedId = typeof options.batchSessionId === 'string' && options.batchSessionId.trim()
    ? sanitizeBatchSessionId(options.batchSessionId.trim())
    : null;
  const sessionId = requestedId || createBatchSessionId();
  if (!sessionId) {
    throw new Error('--batch-session-id is invalid after sanitization.');
  }

  const summaryDir = getCloseLoopBatchSummaryDir(projectPath);
  const summaryFile = path.join(summaryDir, `${sessionId}.json`);
  summary.batch_session = {
    id: sessionId,
    file: summaryFile
  };
  summary.schema_version = AUTO_ARCHIVE_SCHEMA_VERSION;

  await fs.ensureDir(summaryDir);
  await fs.writeJson(summaryFile, {
    ...summary,
    schema_version: AUTO_ARCHIVE_SCHEMA_VERSION,
    batch_session: {
      id: sessionId,
      file: summaryFile
    },
    updated_at: new Date().toISOString()
  }, { spaces: 2 });

  if (keep !== null || olderThanDays !== null) {
    summary.batch_session_prune = await pruneCloseLoopBatchSummarySessions(projectPath, {
      keep: keep === null ? null : keep,
      olderThanDays,
      currentFile: summaryFile,
      dryRun: false
    });
  }
}

function getCloseLoopSessionDir(projectPath) {
  return path.join(projectPath, '.kiro', 'auto', 'close-loop-sessions');
}

function getSpecSessionDir(projectPath) {
  return path.join(projectPath, '.kiro', 'specs');
}

function normalizeLimit(limitCandidate, fallback) {
  if (limitCandidate === undefined || limitCandidate === null) {
    return fallback;
  }

  const parsed = Number(limitCandidate);
  if (!Number.isInteger(parsed) || parsed < 0 || parsed > 1000) {
    throw new Error('Limit must be an integer between 0 and 1000.');
  }
  return parsed;
}

function normalizeStatusFilter(statusCandidate) {
  if (statusCandidate === undefined || statusCandidate === null) {
    return [];
  }
  const raw = `${statusCandidate}`.trim();
  if (!raw) {
    throw new Error('--status must include at least one non-empty status token.');
  }

  const seen = new Set();
  const normalized = [];
  const tokens = raw.split(',');
  for (const token of tokens) {
    const parsed = normalizeStatusToken(token);
    if (!parsed || seen.has(parsed)) {
      continue;
    }
    seen.add(parsed);
    normalized.push(parsed);
  }

  if (normalized.length === 0) {
    throw new Error('--status must include at least one non-empty status token.');
  }
  if (normalized.length > 20) {
    throw new Error('--status supports at most 20 status tokens.');
  }
  return normalized;
}

function normalizeStatsWindowDays(daysCandidate) {
  if (daysCandidate === undefined || daysCandidate === null) {
    return null;
  }
  const parsed = Number(daysCandidate);
  if (!Number.isInteger(parsed) || parsed < 0 || parsed > 36500) {
    throw new Error('--days must be an integer between 0 and 36500.');
  }
  return parsed;
}

function filterEntriesByStatus(entries, statusFilter = []) {
  if (!Array.isArray(statusFilter) || statusFilter.length === 0) {
    return Array.isArray(entries) ? entries : [];
  }
  const statusSet = new Set(statusFilter.map(item => normalizeStatusToken(item)).filter(Boolean));
  return (Array.isArray(entries) ? entries : []).filter(entry => statusSet.has(normalizeStatusToken(entry && entry.status)));
}

function filterGovernanceEntriesByResumeMode(entries, resumeOnly = false) {
  const safeEntries = Array.isArray(entries) ? entries : [];
  if (!resumeOnly) {
    return safeEntries;
  }
  return safeEntries.filter(entry => (
    typeof (entry && entry.resumed_from_governance_session_id) === 'string' &&
    `${entry.resumed_from_governance_session_id}`.trim().length > 0
  ));
}

function buildStatusCounts(entries) {
  const counts = {};
  const safeEntries = Array.isArray(entries) ? entries : [];
  for (const entry of safeEntries) {
    const status = normalizeStatusToken(entry && entry.status) || 'unknown';
    counts[status] = (counts[status] || 0) + 1;
  }
  return counts;
}

function buildQueueFormatCounts(entries) {
  const counts = {};
  const safeEntries = Array.isArray(entries) ? entries : [];
  for (const entry of safeEntries) {
    const format = `${entry && entry.queue_format ? entry.queue_format : ''}`.trim().toLowerCase() || 'unknown';
    counts[format] = (counts[format] || 0) + 1;
  }
  return counts;
}

function buildMasterSpecCounts(entries) {
  const counts = {};
  const safeEntries = Array.isArray(entries) ? entries : [];
  for (const entry of safeEntries) {
    const masterSpec = `${entry && entry.master_spec ? entry.master_spec : ''}`.trim();
    if (!masterSpec) {
      continue;
    }
    counts[masterSpec] = (counts[masterSpec] || 0) + 1;
  }
  return counts;
}

function normalizeKeep(keepCandidate) {
  if (keepCandidate === undefined || keepCandidate === null) {
    return 20;
  }

  const parsed = Number(keepCandidate);
  if (!Number.isInteger(parsed) || parsed < 0 || parsed > 1000) {
    throw new Error('--keep must be an integer between 0 and 1000.');
  }
  return parsed;
}

function normalizeSpecKeep(keepCandidate, fallback = 200) {
  if (keepCandidate === undefined || keepCandidate === null) {
    return fallback;
  }

  const parsed = Number(keepCandidate);
  if (!Number.isInteger(parsed) || parsed < 0 || parsed > 5000) {
    throw new Error('--keep must be an integer between 0 and 5000.');
  }
  return parsed;
}

function normalizeOlderThanDays(daysCandidate) {
  if (daysCandidate === undefined || daysCandidate === null) {
    return null;
  }

  const parsed = Number(daysCandidate);
  if (!Number.isInteger(parsed) || parsed < 0 || parsed > 36500) {
    throw new Error('--older-than-days must be an integer between 0 and 36500.');
  }
  return parsed;
}

function normalizeSpecSessionProtectWindowDays(daysCandidate) {
  if (daysCandidate === undefined || daysCandidate === null) {
    return 7;
  }

  const parsed = Number(daysCandidate);
  if (!Number.isInteger(parsed) || parsed < 0 || parsed > 36500) {
    throw new Error('--spec-session-protect-window-days must be an integer between 0 and 36500.');
  }
  return parsed;
}

function normalizeSpecSessionMaxTotal(maxTotalCandidate) {
  if (maxTotalCandidate === undefined || maxTotalCandidate === null) {
    return null;
  }

  const parsed = Number(maxTotalCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 500000) {
    throw new Error('--spec-session-max-total must be an integer between 1 and 500000.');
  }
  return parsed;
}

function normalizeSpecSessionMaxCreated(maxCreatedCandidate) {
  if (maxCreatedCandidate === undefined || maxCreatedCandidate === null) {
    return null;
  }
  const parsed = Number(maxCreatedCandidate);
  if (!Number.isInteger(parsed) || parsed < 0 || parsed > 500000) {
    throw new Error('--spec-session-max-created must be an integer between 0 and 500000.');
  }
  return parsed;
}

function normalizeSpecSessionMaxCreatedPerGoal(maxCreatedPerGoalCandidate) {
  if (maxCreatedPerGoalCandidate === undefined || maxCreatedPerGoalCandidate === null) {
    return null;
  }
  const parsed = Number(maxCreatedPerGoalCandidate);
  if (Number.isNaN(parsed) || parsed < 0 || parsed > 1000) {
    throw new Error('--spec-session-max-created-per-goal must be a number between 0 and 1000.');
  }
  return Number(parsed.toFixed(2));
}

function normalizeSpecSessionMaxDuplicateGoals(maxDuplicateGoalsCandidate) {
  if (maxDuplicateGoalsCandidate === undefined || maxDuplicateGoalsCandidate === null) {
    return null;
  }
  const parsed = Number(maxDuplicateGoalsCandidate);
  if (!Number.isInteger(parsed) || parsed < 0 || parsed > 500000) {
    throw new Error('--spec-session-max-duplicate-goals must be an integer between 0 and 500000.');
  }
  return parsed;
}

async function readSpecSessionEntries(projectPath) {
  const specDir = getSpecSessionDir(projectPath);
  if (!(await fs.pathExists(specDir))) {
    return [];
  }

  const entries = await fs.readdir(specDir, { withFileTypes: true });
  const specs = [];
  for (const entry of entries) {
    if (!entry.isDirectory() || entry.name.startsWith('.')) {
      continue;
    }
    const specPath = path.join(specDir, entry.name);
    const stats = await fs.stat(specPath);
    specs.push({
      id: entry.name,
      file: specPath,
      created_at: new Date(stats.birthtimeMs || stats.ctimeMs).toISOString(),
      updated_at: new Date(stats.mtimeMs).toISOString(),
      mtime_ms: stats.mtimeMs
    });
  }
  specs.sort((a, b) => b.mtime_ms - a.mtime_ms);
  return specs;
}

async function readCloseLoopSessionEntries(projectPath) {
  const sessionDir = getCloseLoopSessionDir(projectPath);
  if (!(await fs.pathExists(sessionDir))) {
    return [];
  }

  const files = (await fs.readdir(sessionDir))
    .filter(item => item.toLowerCase().endsWith('.json'));
  const sessions = [];

  for (const file of files) {
    const filePath = path.join(sessionDir, file);
    const stats = await fs.stat(filePath);
    const fallbackTimestamp = new Date(stats.mtimeMs).toISOString();
    const fallbackId = path.basename(file, '.json');
    let payload = null;
    let parseError = null;

    try {
      payload = await fs.readJson(filePath);
    } catch (error) {
      parseError = error;
    }

    const id = payload && typeof payload.session_id === 'string' && payload.session_id.trim()
      ? payload.session_id.trim()
      : fallbackId;
    const status = payload && typeof payload.status === 'string'
      ? payload.status
      : parseError
        ? 'invalid'
        : 'unknown';
    const goal = payload && typeof payload.goal === 'string'
      ? payload.goal
      : null;
    const createdAt = payload && typeof payload.created_at === 'string'
      ? payload.created_at
      : null;
    const updatedAt = payload && typeof payload.updated_at === 'string'
      ? payload.updated_at
      : fallbackTimestamp;
    const portfolio = payload && payload.portfolio && typeof payload.portfolio === 'object'
      ? payload.portfolio
      : {};
    const subSpecs = Array.isArray(portfolio.sub_specs) ? portfolio.sub_specs : [];

    sessions.push({
      id,
      file: filePath,
      status,
      goal,
      created_at: createdAt,
      updated_at: updatedAt,
      master_spec: typeof portfolio.master_spec === 'string' ? portfolio.master_spec : null,
      sub_spec_count: subSpecs.length,
      sub_specs: subSpecs,
      parse_error: parseError ? parseError.message : null,
      mtime_ms: stats.mtimeMs
    });
  }

  sessions.sort((a, b) => b.mtime_ms - a.mtime_ms);
  return sessions;
}

async function listSpecSessions(projectPath, options = {}) {
  const specs = await readSpecSessionEntries(projectPath);
  const limit = normalizeLimit(options.limit, 20);
  return {
    mode: 'auto-spec-session-list',
    spec_dir: getSpecSessionDir(projectPath),
    total: specs.length,
    specs: specs.slice(0, limit)
  };
}

async function listCloseLoopSessions(projectPath, options = {}) {
  const sessions = await readCloseLoopSessionEntries(projectPath);
  const statusFilter = normalizeStatusFilter(options.status);
  const filteredSessions = filterEntriesByStatus(sessions, statusFilter);
  const limit = normalizeLimit(options.limit, 20);
  return {
    mode: 'auto-session-list',
    session_dir: getCloseLoopSessionDir(projectPath),
    total: filteredSessions.length,
    status_filter: statusFilter,
    status_counts: buildStatusCounts(filteredSessions),
    sessions: filteredSessions.slice(0, limit)
  };
}

async function statsCloseLoopSessions(projectPath, options = {}) {
  const sessions = await readCloseLoopSessionEntries(projectPath);
  const days = normalizeStatsWindowDays(options.days);
  const statusFilter = normalizeStatusFilter(options.status);
  const cutoffMs = days === null
    ? null
    : Date.now() - (days * 24 * 60 * 60 * 1000);
  const withinWindow = sessions.filter(session => (
    cutoffMs === null || Number(session && session.mtime_ms) >= cutoffMs
  ));
  const filteredSessions = filterEntriesByStatus(withinWindow, statusFilter);

  let completedSessions = 0;
  let failedSessions = 0;
  let subSpecCountSum = 0;
  let sessionsWithSubSpecs = 0;
  for (const session of filteredSessions) {
    const status = normalizeStatusToken(session && session.status) || 'unknown';
    if (status === 'completed') {
      completedSessions += 1;
    }
    if (isFailedStatus(status)) {
      failedSessions += 1;
    }

    const subSpecCount = Number(session && session.sub_spec_count);
    if (Number.isFinite(subSpecCount)) {
      subSpecCountSum += subSpecCount;
      sessionsWithSubSpecs += 1;
    }
  }

  const totalSessions = filteredSessions.length;
  const completionRate = totalSessions > 0
    ? Number(((completedSessions / totalSessions) * 100).toFixed(2))
    : 0;
  const failureRate = totalSessions > 0
    ? Number(((failedSessions / totalSessions) * 100).toFixed(2))
    : 0;
  const masterSpecCounts = buildMasterSpecCounts(filteredSessions);
  const latestSession = totalSessions > 0 ? filteredSessions[0] : null;
  const oldestSession = totalSessions > 0 ? filteredSessions[totalSessions - 1] : null;

  return {
    mode: 'auto-session-stats',
    session_dir: getCloseLoopSessionDir(projectPath),
    criteria: {
      days,
      status_filter: statusFilter,
      since: cutoffMs === null ? null : new Date(cutoffMs).toISOString()
    },
    total_sessions: totalSessions,
    completed_sessions: completedSessions,
    failed_sessions: failedSessions,
    completion_rate_percent: completionRate,
    failure_rate_percent: failureRate,
    sub_spec_count_sum: subSpecCountSum,
    average_sub_specs_per_session: sessionsWithSubSpecs > 0
      ? Number((subSpecCountSum / sessionsWithSubSpecs).toFixed(2))
      : 0,
    unique_master_spec_count: Object.keys(masterSpecCounts).length,
    master_spec_counts: masterSpecCounts,
    status_counts: buildStatusCounts(filteredSessions),
    latest_updated_at: latestSession ? latestSession.updated_at : null,
    oldest_updated_at: oldestSession ? oldestSession.updated_at : null,
    latest_sessions: filteredSessions.slice(0, 10).map(item => ({
      id: item.id,
      status: item.status,
      goal: item.goal,
      master_spec: item.master_spec,
      sub_spec_count: item.sub_spec_count,
      updated_at: item.updated_at,
      parse_error: item.parse_error
    }))
  };
}

async function listGovernanceCloseLoopSessions(projectPath, options = {}) {
  const sessions = await readGovernanceCloseLoopSessionEntries(projectPath);
  const statusFilter = normalizeStatusFilter(options.status);
  const resumeOnly = Boolean(options.resumeOnly);
  const statusFiltered = filterEntriesByStatus(sessions, statusFilter);
  const filteredSessions = filterGovernanceEntriesByResumeMode(statusFiltered, resumeOnly);
  const limit = normalizeLimit(options.limit, 20);
  const resumedSessions = filteredSessions.filter(session => session && session.resumed_from_governance_session_id).length;

  return {
    mode: 'auto-governance-session-list',
    session_dir: getGovernanceCloseLoopSessionDir(projectPath),
    total: filteredSessions.length,
    status_filter: statusFilter,
    resume_only: resumeOnly,
    resumed_sessions: resumedSessions,
    fresh_sessions: filteredSessions.length - resumedSessions,
    status_counts: buildStatusCounts(filteredSessions),
    sessions: filteredSessions.slice(0, limit).map(item => ({
      id: item.id,
      status: item.status,
      target_risk: item.target_risk,
      final_risk: item.final_risk,
      performed_rounds: item.performed_rounds,
      max_rounds: item.max_rounds,
      converged: item.converged,
      execute_advisory: item.execute_advisory,
      advisory_failed_actions: item.advisory_failed_actions,
      stop_reason: item.stop_reason,
      resumed_from_governance_session_id: item.resumed_from_governance_session_id,
      updated_at: item.updated_at,
      parse_error: item.parse_error,
      file: item.file
    }))
  };
}

async function statsGovernanceCloseLoopSessions(projectPath, options = {}) {
  const sessions = await readGovernanceCloseLoopSessionEntries(projectPath);
  const days = normalizeStatsWindowDays(options.days);
  const statusFilter = normalizeStatusFilter(options.status);
  const resumeOnly = Boolean(options.resumeOnly);
  const cutoffMs = days === null
    ? null
    : Date.now() - (days * 24 * 60 * 60 * 1000);
  const withinWindow = sessions.filter(session => (
    cutoffMs === null || Number(session && session.mtime_ms) >= cutoffMs
  ));
  const statusFiltered = filterEntriesByStatus(withinWindow, statusFilter);
  const filteredSessions = filterGovernanceEntriesByResumeMode(statusFiltered, resumeOnly);

  let completedSessions = 0;
  let failedSessions = 0;
  let stoppedSessions = 0;
  let convergedSessions = 0;
  let advisoryEnabledSessions = 0;
  let advisoryFailedActionsSum = 0;
  let performedRoundsSum = 0;
  let sessionsWithRounds = 0;
  let resumedSessions = 0;
  const stopReasonCounts = {};
  const finalRiskCounts = {};
  const resumedFromCounts = {};

  for (const session of filteredSessions) {
    const status = normalizeStatusToken(session && session.status) || 'unknown';
    if (isCompletedStatus(status)) {
      completedSessions += 1;
    } else if (isFailedStatus(status)) {
      failedSessions += 1;
    } else if (status === 'stopped') {
      stoppedSessions += 1;
    }

    if (session && session.converged === true) {
      convergedSessions += 1;
    }
    if (session && session.execute_advisory === true) {
      advisoryEnabledSessions += 1;
    }
    advisoryFailedActionsSum += Number(session && session.advisory_failed_actions) || 0;

    const performedRounds = Number(session && session.performed_rounds);
    if (Number.isFinite(performedRounds)) {
      performedRoundsSum += performedRounds;
      sessionsWithRounds += 1;
    }
    if (session && session.resumed_from_governance_session_id) {
      resumedSessions += 1;
      const parentId = `${session.resumed_from_governance_session_id}`.trim() || 'unknown';
      resumedFromCounts[parentId] = (resumedFromCounts[parentId] || 0) + 1;
    }

    const stopReason = `${session && session.stop_reason ? session.stop_reason : ''}`.trim().toLowerCase() || 'unknown';
    stopReasonCounts[stopReason] = (stopReasonCounts[stopReason] || 0) + 1;

    const finalRisk = `${session && session.final_risk ? session.final_risk : ''}`.trim().toLowerCase() || 'unknown';
    finalRiskCounts[finalRisk] = (finalRiskCounts[finalRisk] || 0) + 1;
  }

  const totalSessions = filteredSessions.length;
  const completionRate = totalSessions > 0
    ? Number(((completedSessions / totalSessions) * 100).toFixed(2))
    : 0;
  const failureRate = totalSessions > 0
    ? Number(((failedSessions / totalSessions) * 100).toFixed(2))
    : 0;
  const averagePerformedRounds = sessionsWithRounds > 0
    ? Number((performedRoundsSum / sessionsWithRounds).toFixed(2))
    : 0;
  const resumedRate = totalSessions > 0
    ? Number(((resumedSessions / totalSessions) * 100).toFixed(2))
    : 0;
  const latestSession = totalSessions > 0 ? filteredSessions[0] : null;
  const oldestSession = totalSessions > 0 ? filteredSessions[totalSessions - 1] : null;

  return {
    mode: 'auto-governance-session-stats',
    session_dir: getGovernanceCloseLoopSessionDir(projectPath),
    criteria: {
      days,
      status_filter: statusFilter,
      resume_only: resumeOnly,
      since: cutoffMs === null ? null : new Date(cutoffMs).toISOString()
    },
    total_sessions: totalSessions,
    resumed_sessions: resumedSessions,
    fresh_sessions: totalSessions - resumedSessions,
    resumed_rate_percent: resumedRate,
    completed_sessions: completedSessions,
    failed_sessions: failedSessions,
    stopped_sessions: stoppedSessions,
    converged_sessions: convergedSessions,
    advisory_enabled_sessions: advisoryEnabledSessions,
    advisory_failed_actions_sum: advisoryFailedActionsSum,
    completion_rate_percent: completionRate,
    failure_rate_percent: failureRate,
    average_performed_rounds: averagePerformedRounds,
    status_counts: buildStatusCounts(filteredSessions),
    stop_reason_counts: stopReasonCounts,
    final_risk_counts: finalRiskCounts,
    resumed_from_counts: resumedFromCounts,
    latest_updated_at: latestSession ? latestSession.updated_at : null,
    oldest_updated_at: oldestSession ? oldestSession.updated_at : null,
    latest_sessions: filteredSessions.slice(0, 10).map(item => ({
      id: item.id,
      status: item.status,
      target_risk: item.target_risk,
      final_risk: item.final_risk,
      performed_rounds: item.performed_rounds,
      max_rounds: item.max_rounds,
      converged: item.converged,
      execute_advisory: item.execute_advisory,
      advisory_failed_actions: item.advisory_failed_actions,
      stop_reason: item.stop_reason,
      resumed_from_governance_session_id: item.resumed_from_governance_session_id,
      updated_at: item.updated_at,
      parse_error: item.parse_error
    }))
  };
}

async function pruneGovernanceCloseLoopSessions(projectPath, options = {}) {
  const keep = normalizeKeep(options.keep);
  const olderThanDays = normalizeOlderThanDays(options.olderThanDays);
  const dryRun = Boolean(options.dryRun);
  const currentFile = typeof options.currentFile === 'string' && options.currentFile.trim()
    ? path.resolve(options.currentFile.trim())
    : null;
  const sessions = await readGovernanceCloseLoopSessionEntries(projectPath);
  const cutoffMs = olderThanDays === null
    ? null
    : Date.now() - (olderThanDays * 24 * 60 * 60 * 1000);

  const keepSet = new Set(
    sessions.slice(0, keep).map(session => path.resolve(session.file))
  );
  if (currentFile) {
    keepSet.add(currentFile);
  }
  const deletable = sessions.filter(session => {
    const resolvedFile = path.resolve(session.file);
    if (keepSet.has(resolvedFile)) {
      return false;
    }
    if (cutoffMs === null) {
      return true;
    }
    return session.mtime_ms < cutoffMs;
  });

  const deleted = [];
  const errors = [];
  if (!dryRun) {
    for (const session of deletable) {
      try {
        await fs.remove(session.file);
        deleted.push(session);
      } catch (error) {
        errors.push({
          id: session.id,
          file: session.file,
          error: error.message
        });
      }
    }
  }

  return {
    mode: 'auto-governance-session-prune',
    session_dir: getGovernanceCloseLoopSessionDir(projectPath),
    dry_run: dryRun,
    criteria: {
      keep,
      older_than_days: olderThanDays
    },
    total_sessions: sessions.length,
    kept_sessions: sessions.length - deletable.length,
    deleted_count: dryRun ? deletable.length : deleted.length,
    candidates: deletable.map(item => ({
      id: item.id,
      file: item.file,
      status: item.status,
      updated_at: item.updated_at
    })),
    errors
  };
}

async function pruneSpecSessions(projectPath, options = {}) {
  const specs = await readSpecSessionEntries(projectPath);
  const keep = normalizeSpecKeep(
    options.keep,
    Object.prototype.hasOwnProperty.call(options, 'defaultKeep') ? options.defaultKeep : 200
  );
  const olderThanDays = normalizeOlderThanDays(options.olderThanDays);
  const dryRun = Boolean(options.dryRun);
  const protectActive = options.protectActive !== false;
  const showProtectionReasons = Boolean(options.showProtectionReasons);
  const protectWindowDays = normalizeSpecSessionProtectWindowDays(options.protectWindowDays);
  const cutoffMs = olderThanDays === null
    ? null
    : Date.now() - (olderThanDays * 24 * 60 * 60 * 1000);
  const protectionProfile = protectActive
    ? await collectProtectedSpecNames(projectPath, options.additionalProtectedSpecs, { protectWindowDays })
    : {
      names: new Set(
        (Array.isArray(options.additionalProtectedSpecs) ? options.additionalProtectedSpecs : [])
          .map(item => `${item || ''}`.trim())
          .filter(Boolean)
      ),
      reason_map: new Map(),
      ranking: [],
      breakdown: {
        additional: new Set(
          (Array.isArray(options.additionalProtectedSpecs) ? options.additionalProtectedSpecs : [])
            .map(item => `${item || ''}`.trim())
            .filter(Boolean)
        ).size,
        collaboration_active: 0,
        close_loop_session_recent_or_incomplete: 0,
        batch_summary_recent_or_incomplete: 0
      }
    };
  const protectedSpecSet = protectionProfile.names;
  const protectionRanking = Array.isArray(protectionProfile.ranking)
    ? protectionProfile.ranking
    : [];

  const deletable = [];
  const protectedSpecs = [];
  for (let index = 0; index < specs.length; index += 1) {
    const spec = specs[index];
    const beyondKeep = keep === null ? true : index >= keep;
    const beyondAge = cutoffMs === null || spec.mtime_ms < cutoffMs;
    if (protectedSpecSet.has(spec.id)) {
      if (beyondKeep && beyondAge) {
        protectedSpecs.push(spec);
      }
      continue;
    }
    if (beyondKeep && beyondAge) {
      deletable.push(spec);
    }
  }

  const deleted = [];
  const errors = [];
  if (!dryRun) {
    for (const spec of deletable) {
      try {
        await fs.remove(spec.file);
        deleted.push(spec);
      } catch (error) {
        errors.push({
          id: spec.id,
          file: spec.file,
          error: error.message
        });
      }
    }
  }

  return {
    mode: 'auto-spec-session-prune',
    spec_dir: getSpecSessionDir(projectPath),
    dry_run: dryRun,
    protect_active: protectActive,
    protect_window_days: protectWindowDays,
    protection_sources: protectionProfile.breakdown,
    criteria: {
      keep,
      older_than_days: olderThanDays
    },
    total_specs: specs.length,
    kept_specs: specs.length - deletable.length,
    protected_count: protectedSpecs.length,
    deleted_count: dryRun ? deletable.length : deleted.length,
    protected_specs: protectedSpecs.slice(0, 200).map(item => ({
      id: item.id,
      file: item.file,
      updated_at: item.updated_at,
      reasons: showProtectionReasons
        ? buildSpecProtectionReasonPayload(item.id, protectionProfile.reason_map)
        : undefined
    })),
    protection_ranking_top: protectionRanking.slice(0, 20),
    protection_ranking: showProtectionReasons ? protectionRanking.slice(0, 500) : undefined,
    candidates: deletable.map(item => ({
      id: item.id,
      file: item.file,
      updated_at: item.updated_at
    })),
    errors
  };
}

function normalizeStatusToken(statusCandidate) {
  return `${statusCandidate || ''}`.trim().toLowerCase();
}

function isCompletedStatus(statusCandidate) {
  return normalizeStatusToken(statusCandidate) === 'completed';
}

function isFailedStatus(statusCandidate) {
  return ['failed', 'partial-failed', 'error', 'invalid'].includes(normalizeStatusToken(statusCandidate));
}

function collectSpecNamesFromBatchSummary(summary) {
  const names = new Set();
  const results = Array.isArray(summary && summary.results) ? summary.results : [];
  for (const item of results) {
    const masterSpec = `${item && item.master_spec ? item.master_spec : ''}`.trim();
    if (masterSpec) {
      names.add(masterSpec);
    }
  }
  return [...names];
}

function collectSpecNamesFromCloseLoopSessionPayload(payload) {
  const names = new Set();
  const portfolio = payload && payload.portfolio && typeof payload.portfolio === 'object'
    ? payload.portfolio
    : {};
  const masterSpec = `${portfolio.master_spec || ''}`.trim();
  if (masterSpec) {
    names.add(masterSpec);
  }
  const subSpecs = Array.isArray(portfolio.sub_specs) ? portfolio.sub_specs : [];
  for (const item of subSpecs) {
    const specName = `${item || ''}`.trim();
    if (specName) {
      names.add(specName);
    }
  }
  return names;
}

function collectSpecNamesFromBatchSummaryPayload(payload, includeCompleted = false) {
  const names = new Set();
  const results = Array.isArray(payload && payload.results) ? payload.results : [];
  for (const item of results) {
    const status = normalizeStatusToken(item && item.status);
    if (!includeCompleted && status === 'completed') {
      continue;
    }
    const masterSpec = `${item && item.master_spec ? item.master_spec : ''}`.trim();
    if (masterSpec) {
      names.add(masterSpec);
    }
  }
  return names;
}

function createProtectionReasonRecord() {
  return {
    additional: 0,
    collaboration_active: 0,
    close_loop_session_recent_or_incomplete: 0,
    batch_summary_recent_or_incomplete: 0,
    controller_session_recent_or_incomplete: 0,
    total_references: 0
  };
}

function ensureProtectionReasonRecord(reasonMap, specName) {
  const key = `${specName || ''}`.trim();
  if (!key) {
    return null;
  }
  if (!reasonMap.has(key)) {
    reasonMap.set(key, createProtectionReasonRecord());
  }
  return reasonMap.get(key);
}

function incrementProtectionReason(reasonMap, specName, reasonKey, delta = 1) {
  if (!Number.isFinite(delta) || delta <= 0) {
    return;
  }
  const record = ensureProtectionReasonRecord(reasonMap, specName);
  if (!record) {
    return;
  }
  const normalizedReason = `${reasonKey || ''}`.trim();
  if (!normalizedReason || !Object.prototype.hasOwnProperty.call(record, normalizedReason)) {
    return;
  }
  record[normalizedReason] += delta;
  record.total_references += delta;
}

function buildProtectionRanking(reasonMap) {
  const entries = [];
  for (const [spec, reasons] of reasonMap.entries()) {
    entries.push({
      spec,
      total_references: Number(reasons.total_references) || 0,
      reasons: {
        additional: Number(reasons.additional) || 0,
        collaboration_active: Number(reasons.collaboration_active) || 0,
        close_loop_session_recent_or_incomplete: Number(reasons.close_loop_session_recent_or_incomplete) || 0,
        batch_summary_recent_or_incomplete: Number(reasons.batch_summary_recent_or_incomplete) || 0,
        controller_session_recent_or_incomplete: Number(reasons.controller_session_recent_or_incomplete) || 0
      }
    });
  }
  entries.sort((left, right) => {
    if (right.total_references !== left.total_references) {
      return right.total_references - left.total_references;
    }
    return left.spec.localeCompare(right.spec);
  });
  return entries;
}

function buildSpecProtectionReasonPayload(specName, reasonMap) {
  if (!reasonMap || typeof reasonMap.get !== 'function') {
    return null;
  }
  const record = reasonMap.get(specName);
  if (!record) {
    return null;
  }
  return {
    total_references: Number(record.total_references) || 0,
    additional: Number(record.additional) || 0,
    collaboration_active: Number(record.collaboration_active) || 0,
    close_loop_session_recent_or_incomplete: Number(record.close_loop_session_recent_or_incomplete) || 0,
    batch_summary_recent_or_incomplete: Number(record.batch_summary_recent_or_incomplete) || 0,
    controller_session_recent_or_incomplete: Number(record.controller_session_recent_or_incomplete) || 0
  };
}

async function collectProtectedSpecNamesFromCollaboration(projectPath) {
  const reasonCounts = new Map();
  const specEntries = await readSpecSessionEntries(projectPath);
  for (const spec of specEntries) {
    const collaborationFile = path.join(spec.file, 'collaboration.json');
    if (!(await fs.pathExists(collaborationFile))) {
      continue;
    }
    try {
      const payload = await fs.readJson(collaborationFile);
      const status = normalizeStatusToken(payload && payload.status);
      if (!status || !isCompletedStatus(status)) {
        incrementProtectionReason(reasonCounts, spec.id, 'collaboration_active', 1);
      }
    } catch (error) {
      // Treat unreadable collaboration metadata as active to avoid unsafe deletion.
      incrementProtectionReason(reasonCounts, spec.id, 'collaboration_active', 1);
    }
  }
  return reasonCounts;
}

async function collectProtectedSpecNamesFromCloseLoopSessions(projectPath, recentWindowMs) {
  const reasonCounts = new Map();
  const sessions = await readCloseLoopSessionEntries(projectPath);
  for (const session of sessions) {
    const isRecent = Number(session && session.mtime_ms) >= (Date.now() - recentWindowMs);
    const isIncomplete = !isCompletedStatus(session && session.status);
    if (!isRecent && !isIncomplete) {
      continue;
    }
    const referencedSpecs = new Set();
    const masterSpec = `${session && session.master_spec ? session.master_spec : ''}`.trim();
    if (masterSpec) {
      referencedSpecs.add(masterSpec);
    }
    const subSpecs = Array.isArray(session && session.sub_specs) ? session.sub_specs : [];
    for (const item of subSpecs) {
      const specName = `${item || ''}`.trim();
      if (specName) {
        referencedSpecs.add(specName);
      }
    }
    for (const specName of referencedSpecs) {
      incrementProtectionReason(reasonCounts, specName, 'close_loop_session_recent_or_incomplete', 1);
    }
  }
  return reasonCounts;
}

async function collectProtectedSpecNamesFromBatchSummaries(projectPath, recentWindowMs) {
  const reasonCounts = new Map();
  const sessions = await readCloseLoopBatchSummaryEntries(projectPath);
  for (const session of sessions) {
    const isRecent = Number(session && session.mtime_ms) >= (Date.now() - recentWindowMs);
    const isIncompleteSummary = !isCompletedStatus(session && session.status);
    if (!isRecent && !isIncompleteSummary) {
      continue;
    }
    try {
      const payload = await fs.readJson(session.file);
      const includeCompleted = isRecent;
      const names = collectSpecNamesFromBatchSummaryPayload(payload, includeCompleted);
      for (const name of names) {
        incrementProtectionReason(reasonCounts, name, 'batch_summary_recent_or_incomplete', 1);
      }
    } catch (error) {
      // Ignore unreadable summary payloads for protection derivation.
    }
  }
  return reasonCounts;
}

async function collectProtectedSpecNamesFromControllerSessions(projectPath, recentWindowMs) {
  const reasonCounts = new Map();
  const sessions = await readCloseLoopControllerSessionEntries(projectPath);
  for (const session of sessions) {
    const isRecent = Number(session && session.mtime_ms) >= (Date.now() - recentWindowMs);
    const isIncompleteSummary = !isCompletedStatus(session && session.status);
    if (!isRecent && !isIncompleteSummary) {
      continue;
    }
    let payload = null;
    try {
      payload = await fs.readJson(session.file);
    } catch (error) {
      continue;
    }
    const includeCompleted = isRecent;
    const results = Array.isArray(payload && payload.results) ? payload.results : [];
    for (const item of results) {
      const nestedSummaryCandidate = `${item && item.batch_session_file ? item.batch_session_file : ''}`.trim();
      if (!nestedSummaryCandidate) {
        continue;
      }
      const nestedSummaryFile = path.isAbsolute(nestedSummaryCandidate)
        ? nestedSummaryCandidate
        : path.join(projectPath, nestedSummaryCandidate);
      if (!(await fs.pathExists(nestedSummaryFile))) {
        continue;
      }
      try {
        const nestedSummary = await fs.readJson(nestedSummaryFile);
        const names = collectSpecNamesFromBatchSummaryPayload(nestedSummary, includeCompleted);
        for (const name of names) {
          incrementProtectionReason(reasonCounts, name, 'controller_session_recent_or_incomplete', 1);
        }
      } catch (error) {
        // Ignore unreadable nested summaries for protection derivation.
      }
    }
  }
  return reasonCounts;
}

async function collectProtectedSpecNames(projectPath, additionalProtectedSpecs = [], options = {}) {
  const protectWindowDays = normalizeSpecSessionProtectWindowDays(options.protectWindowDays);
  const normalizedAdditionalSpecs = (Array.isArray(additionalProtectedSpecs) ? additionalProtectedSpecs : [])
    .map(item => `${item || ''}`.trim())
    .filter(Boolean);
  const reasonMap = new Map();
  for (const specName of normalizedAdditionalSpecs) {
    incrementProtectionReason(reasonMap, specName, 'additional', 1);
  }
  const recentWindowMs = protectWindowDays * 24 * 60 * 60 * 1000;
  const fromCollaboration = await collectProtectedSpecNamesFromCollaboration(projectPath);
  const fromSessions = await collectProtectedSpecNamesFromCloseLoopSessions(projectPath, recentWindowMs);
  const fromBatchSessions = await collectProtectedSpecNamesFromBatchSummaries(projectPath, recentWindowMs);
  const fromControllerSessions = await collectProtectedSpecNamesFromControllerSessions(projectPath, recentWindowMs);
  for (const [specName, record] of fromCollaboration.entries()) {
    incrementProtectionReason(
      reasonMap,
      specName,
      'collaboration_active',
      Number(record && record.collaboration_active) || 0
    );
  }
  for (const [specName, record] of fromSessions.entries()) {
    incrementProtectionReason(
      reasonMap,
      specName,
      'close_loop_session_recent_or_incomplete',
      Number(record && record.close_loop_session_recent_or_incomplete) || 0
    );
  }
  for (const [specName, record] of fromBatchSessions.entries()) {
    incrementProtectionReason(
      reasonMap,
      specName,
      'batch_summary_recent_or_incomplete',
      Number(record && record.batch_summary_recent_or_incomplete) || 0
    );
  }
  for (const [specName, record] of fromControllerSessions.entries()) {
    incrementProtectionReason(
      reasonMap,
      specName,
      'controller_session_recent_or_incomplete',
      Number(record && record.controller_session_recent_or_incomplete) || 0
    );
  }
  const protectedNames = new Set([...reasonMap.keys()]);
  const ranking = buildProtectionRanking(reasonMap);
  return {
    names: protectedNames,
    reason_map: reasonMap,
    ranking,
    breakdown: {
      additional: new Set(normalizedAdditionalSpecs).size,
      collaboration_active: fromCollaboration.size,
      close_loop_session_recent_or_incomplete: fromSessions.size,
      batch_summary_recent_or_incomplete: fromBatchSessions.size,
      controller_session_recent_or_incomplete: fromControllerSessions.size
    }
  };
}

async function maybePruneSpecSessionsWithPolicy(projectPath, options = {}, additionalProtectedSpecs = []) {
  const keepProvided = options.specSessionKeep !== undefined && options.specSessionKeep !== null;
  const ageProvided = options.specSessionOlderThanDays !== undefined && options.specSessionOlderThanDays !== null;
  if (!keepProvided && !ageProvided) {
    return null;
  }

  return pruneSpecSessions(projectPath, {
    keep: keepProvided ? options.specSessionKeep : null,
    olderThanDays: ageProvided ? options.specSessionOlderThanDays : null,
    dryRun: false,
    protectActive: options.specSessionProtectActive !== false,
    protectWindowDays: options.specSessionProtectWindowDays,
    additionalProtectedSpecs,
    defaultKeep: null
  });
}

async function listCloseLoopBatchSummarySessions(projectPath, options = {}) {
  const sessions = await readCloseLoopBatchSummaryEntries(projectPath);
  const statusFilter = normalizeStatusFilter(options.status);
  const filteredSessions = filterEntriesByStatus(sessions, statusFilter);
  const limit = normalizeLimit(options.limit, 20);
  return {
    mode: 'auto-batch-session-list',
    session_dir: getCloseLoopBatchSummaryDir(projectPath),
    total: filteredSessions.length,
    status_filter: statusFilter,
    status_counts: buildStatusCounts(filteredSessions),
    sessions: filteredSessions.slice(0, limit).map(item => ({
      id: item.id,
      file: item.file,
      status: item.status,
      goals_file: item.goals_file,
      total_goals: item.total_goals,
      processed_goals: item.processed_goals,
      updated_at: item.updated_at,
      parse_error: item.parse_error
    }))
  };
}

async function statsCloseLoopBatchSummarySessions(projectPath, options = {}) {
  const sessions = await readCloseLoopBatchSummaryEntries(projectPath);
  const days = normalizeStatsWindowDays(options.days);
  const statusFilter = normalizeStatusFilter(options.status);
  const cutoffMs = days === null
    ? null
    : Date.now() - (days * 24 * 60 * 60 * 1000);
  const withinWindow = sessions.filter(session => (
    cutoffMs === null || Number(session && session.mtime_ms) >= cutoffMs
  ));
  const filteredSessions = filterEntriesByStatus(withinWindow, statusFilter);

  let completedSessions = 0;
  let failedSessions = 0;
  let totalGoalsSum = 0;
  let processedGoalsSum = 0;
  let sessionsWithTotalGoals = 0;
  let sessionsWithProcessedGoals = 0;
  for (const session of filteredSessions) {
    const status = normalizeStatusToken(session && session.status) || 'unknown';
    if (status === 'completed') {
      completedSessions += 1;
    }
    if (isFailedStatus(status)) {
      failedSessions += 1;
    }

    const totalGoals = Number(session && session.total_goals);
    if (Number.isFinite(totalGoals)) {
      totalGoalsSum += totalGoals;
      sessionsWithTotalGoals += 1;
    }
    const processedGoals = Number(session && session.processed_goals);
    if (Number.isFinite(processedGoals)) {
      processedGoalsSum += processedGoals;
      sessionsWithProcessedGoals += 1;
    }
  }

  const totalSessions = filteredSessions.length;
  const completionRate = totalSessions > 0
    ? Number(((completedSessions / totalSessions) * 100).toFixed(2))
    : 0;
  const failureRate = totalSessions > 0
    ? Number(((failedSessions / totalSessions) * 100).toFixed(2))
    : 0;
  const processedRatio = totalGoalsSum > 0
    ? Number(((processedGoalsSum / totalGoalsSum) * 100).toFixed(2))
    : 0;
  const latestSession = totalSessions > 0 ? filteredSessions[0] : null;
  const oldestSession = totalSessions > 0 ? filteredSessions[totalSessions - 1] : null;

  return {
    mode: 'auto-batch-session-stats',
    session_dir: getCloseLoopBatchSummaryDir(projectPath),
    criteria: {
      days,
      status_filter: statusFilter,
      since: cutoffMs === null ? null : new Date(cutoffMs).toISOString()
    },
    total_sessions: totalSessions,
    completed_sessions: completedSessions,
    failed_sessions: failedSessions,
    completion_rate_percent: completionRate,
    failure_rate_percent: failureRate,
    total_goals_sum: totalGoalsSum,
    processed_goals_sum: processedGoalsSum,
    unprocessed_goals_sum: Math.max(0, totalGoalsSum - processedGoalsSum),
    average_total_goals_per_session: sessionsWithTotalGoals > 0
      ? Number((totalGoalsSum / sessionsWithTotalGoals).toFixed(2))
      : 0,
    average_processed_goals_per_session: sessionsWithProcessedGoals > 0
      ? Number((processedGoalsSum / sessionsWithProcessedGoals).toFixed(2))
      : 0,
    average_processed_ratio_percent: processedRatio,
    status_counts: buildStatusCounts(filteredSessions),
    latest_updated_at: latestSession ? latestSession.updated_at : null,
    oldest_updated_at: oldestSession ? oldestSession.updated_at : null,
    latest_sessions: filteredSessions.slice(0, 10).map(item => ({
      id: item.id,
      status: item.status,
      goals_file: item.goals_file,
      total_goals: item.total_goals,
      processed_goals: item.processed_goals,
      updated_at: item.updated_at,
      parse_error: item.parse_error
    }))
  };
}

async function listCloseLoopControllerSessions(projectPath, options = {}) {
  const sessions = await readCloseLoopControllerSessionEntries(projectPath);
  const statusFilter = normalizeStatusFilter(options.status);
  const filteredSessions = filterEntriesByStatus(sessions, statusFilter);
  const limit = normalizeLimit(options.limit, 20);
  return {
    mode: 'auto-controller-session-list',
    session_dir: getCloseLoopControllerSessionDir(projectPath),
    total: filteredSessions.length,
    status_filter: statusFilter,
    status_counts: buildStatusCounts(filteredSessions),
    sessions: filteredSessions.slice(0, limit).map(item => ({
      id: item.id,
      file: item.file,
      status: item.status,
      queue_file: item.queue_file,
      queue_format: item.queue_format,
      processed_goals: item.processed_goals,
      pending_goals: item.pending_goals,
      updated_at: item.updated_at,
      parse_error: item.parse_error
    }))
  };
}

async function statsCloseLoopControllerSessions(projectPath, options = {}) {
  const sessions = await readCloseLoopControllerSessionEntries(projectPath);
  const days = normalizeStatsWindowDays(options.days);
  const statusFilter = normalizeStatusFilter(options.status);
  const cutoffMs = days === null
    ? null
    : Date.now() - (days * 24 * 60 * 60 * 1000);

  const withinWindow = sessions.filter(session => (
    cutoffMs === null || Number(session && session.mtime_ms) >= cutoffMs
  ));
  const filteredSessions = filterEntriesByStatus(withinWindow, statusFilter);

  let completedSessions = 0;
  let failedSessions = 0;
  let processedGoalsSum = 0;
  let pendingGoalsSum = 0;
  let sessionsWithProcessed = 0;
  let sessionsWithPending = 0;

  for (const session of filteredSessions) {
    const status = normalizeStatusToken(session && session.status) || 'unknown';
    if (status === 'completed') {
      completedSessions += 1;
    }
    if (isFailedStatus(status)) {
      failedSessions += 1;
    }

    const processedGoals = Number(session && session.processed_goals);
    if (Number.isFinite(processedGoals)) {
      processedGoalsSum += processedGoals;
      sessionsWithProcessed += 1;
    }
    const pendingGoals = Number(session && session.pending_goals);
    if (Number.isFinite(pendingGoals)) {
      pendingGoalsSum += pendingGoals;
      sessionsWithPending += 1;
    }
  }

  const totalSessions = filteredSessions.length;
  const completionRate = totalSessions > 0
    ? Number(((completedSessions / totalSessions) * 100).toFixed(2))
    : 0;
  const failureRate = totalSessions > 0
    ? Number(((failedSessions / totalSessions) * 100).toFixed(2))
    : 0;
  const latestSession = totalSessions > 0 ? filteredSessions[0] : null;
  const oldestSession = totalSessions > 0 ? filteredSessions[totalSessions - 1] : null;

  return {
    mode: 'auto-controller-session-stats',
    session_dir: getCloseLoopControllerSessionDir(projectPath),
    criteria: {
      days,
      status_filter: statusFilter,
      since: cutoffMs === null ? null : new Date(cutoffMs).toISOString()
    },
    total_sessions: totalSessions,
    completed_sessions: completedSessions,
    failed_sessions: failedSessions,
    completion_rate_percent: completionRate,
    failure_rate_percent: failureRate,
    processed_goals_sum: processedGoalsSum,
    pending_goals_sum: pendingGoalsSum,
    average_processed_goals_per_session: sessionsWithProcessed > 0
      ? Number((processedGoalsSum / sessionsWithProcessed).toFixed(2))
      : 0,
    average_pending_goals_per_session: sessionsWithPending > 0
      ? Number((pendingGoalsSum / sessionsWithPending).toFixed(2))
      : 0,
    status_counts: buildStatusCounts(filteredSessions),
    queue_format_counts: buildQueueFormatCounts(filteredSessions),
    latest_updated_at: latestSession ? latestSession.updated_at : null,
    oldest_updated_at: oldestSession ? oldestSession.updated_at : null,
    latest_sessions: filteredSessions.slice(0, 10).map(item => ({
      id: item.id,
      status: item.status,
      queue_file: item.queue_file,
      queue_format: item.queue_format,
      processed_goals: item.processed_goals,
      pending_goals: item.pending_goals,
      updated_at: item.updated_at,
      parse_error: item.parse_error
    }))
  };
}

function calculatePercent(numerator, denominator) {
  const safeNumerator = Number(numerator) || 0;
  const safeDenominator = Number(denominator) || 0;
  if (safeDenominator <= 0) {
    return 0;
  }
  return Number(((safeNumerator / safeDenominator) * 100).toFixed(2));
}

function buildTopCountEntries(counterMap, limit = 10) {
  const source = counterMap && typeof counterMap === 'object'
    ? counterMap
    : {};
  const maxItems = Number.isInteger(limit) && limit > 0 ? limit : 10;
  return Object.entries(source)
    .map(([key, count]) => ({
      key,
      count: Number(count) || 0
    }))
    .sort((left, right) => {
      if (right.count !== left.count) {
        return right.count - left.count;
      }
      return left.key.localeCompare(right.key);
    })
    .slice(0, maxItems);
}

function deriveGovernanceRiskLevel(summary) {
  const failureRate = Number(summary && summary.failure_rate_percent) || 0;
  const pendingGoals = Number(summary && summary.pending_goals_sum) || 0;
  const failedSessions = Number(summary && summary.failed_sessions) || 0;

  if (failureRate >= 40 || pendingGoals >= 5) {
    return 'high';
  }
  if (failureRate >= 20 || pendingGoals > 0 || failedSessions > 0) {
    return 'medium';
  }
  return 'low';
}

function buildGovernanceConcerns(summary) {
  const concerns = [];
  const totalSessions = Number(summary && summary.total_sessions) || 0;
  const failedSessions = Number(summary && summary.failed_sessions) || 0;
  const pendingGoals = Number(summary && summary.pending_goals_sum) || 0;
  const failureRate = Number(summary && summary.failure_rate_percent) || 0;
  const recoverySignatures = Number(summary && summary.recovery_signature_count) || 0;

  if (totalSessions === 0) {
    concerns.push('No archived sessions found for the selected filter window.');
  }
  if (failedSessions > 0) {
    concerns.push(`${failedSessions} failed session(s) detected across governance archives.`);
  }
  if (pendingGoals > 0) {
    concerns.push(`${pendingGoals} pending controller goal(s) remain unprocessed.`);
  }
  if (failureRate >= 20) {
    concerns.push(`Overall session failure rate is elevated at ${failureRate}%.`);
  }
  if (failedSessions > 0 && recoverySignatures === 0) {
    concerns.push('Recovery memory has no signatures despite failed sessions.');
  }

  return concerns;
}

function buildGovernanceRecommendations(summary) {
  const recommendations = [];
  const failedSessions = Number(summary && summary.failed_sessions) || 0;
  const pendingGoals = Number(summary && summary.pending_goals_sum) || 0;
  const riskLevel = `${summary && summary.risk_level ? summary.risk_level : 'low'}`.trim().toLowerCase();

  if (failedSessions > 0) {
    recommendations.push('Run `kse auto close-loop-recover latest --recover-until-complete --json` to drain failed goals.');
  }
  if (pendingGoals > 0) {
    recommendations.push('Run `kse auto close-loop-controller --controller-resume latest --json` to continue pending queue work.');
  }
  if (riskLevel === 'low') {
    recommendations.push('Keep daily governance checks with `kse auto governance stats --days 14 --json`.');
  } else if (riskLevel === 'high') {
    recommendations.push('Apply stricter gate policy (`--program-gate-profile staging|prod`) before next program-scale run.');
  }

  return recommendations;
}

async function buildAutoGovernanceStats(projectPath, options = {}) {
  const days = normalizeStatsWindowDays(options.days);
  const statusFilter = normalizeStatusFilter(options.status);
  const normalizedOptions = {
    days,
    status: statusFilter.length > 0 ? statusFilter.join(',') : undefined
  };

  const [sessionStats, batchStats, controllerStats, recoveryMemory] = await Promise.all([
    statsCloseLoopSessions(projectPath, normalizedOptions),
    statsCloseLoopBatchSummarySessions(projectPath, normalizedOptions),
    statsCloseLoopControllerSessions(projectPath, normalizedOptions),
    showCloseLoopRecoveryMemory(projectPath, {})
  ]);

  const totalSessions =
    (Number(sessionStats.total_sessions) || 0) +
    (Number(batchStats.total_sessions) || 0) +
    (Number(controllerStats.total_sessions) || 0);
  const completedSessions =
    (Number(sessionStats.completed_sessions) || 0) +
    (Number(batchStats.completed_sessions) || 0) +
    (Number(controllerStats.completed_sessions) || 0);
  const failedSessions =
    (Number(sessionStats.failed_sessions) || 0) +
    (Number(batchStats.failed_sessions) || 0) +
    (Number(controllerStats.failed_sessions) || 0);
  const pendingGoalsSum = Number(controllerStats.pending_goals_sum) || 0;
  const recoverySignatureCount = Number(recoveryMemory && recoveryMemory.stats && recoveryMemory.stats.signature_count) || 0;
  const summary = {
    total_sessions: totalSessions,
    completed_sessions: completedSessions,
    failed_sessions: failedSessions,
    failure_rate_percent: calculatePercent(failedSessions, totalSessions),
    completion_rate_percent: calculatePercent(completedSessions, totalSessions),
    pending_goals_sum: pendingGoalsSum,
    recovery_signature_count: recoverySignatureCount
  };
  const riskLevel = deriveGovernanceRiskLevel(summary);
  const concerns = buildGovernanceConcerns(summary);
  const recommendations = buildGovernanceRecommendations({
    ...summary,
    risk_level: riskLevel
  });

  return {
    mode: 'auto-governance-stats',
    generated_at: new Date().toISOString(),
    criteria: {
      days,
      status_filter: statusFilter,
      since: days === null
        ? null
        : new Date(Date.now() - (days * 24 * 60 * 60 * 1000)).toISOString()
    },
    totals: {
      total_sessions: totalSessions,
      completed_sessions: completedSessions,
      failed_sessions: failedSessions,
      completion_rate_percent: summary.completion_rate_percent,
      failure_rate_percent: summary.failure_rate_percent
    },
    throughput: {
      sub_spec_count_sum: Number(sessionStats.sub_spec_count_sum) || 0,
      batch_total_goals_sum: Number(batchStats.total_goals_sum) || 0,
      batch_processed_goals_sum: Number(batchStats.processed_goals_sum) || 0,
      controller_processed_goals_sum: Number(controllerStats.processed_goals_sum) || 0,
      controller_pending_goals_sum: pendingGoalsSum
    },
    top_master_specs: buildTopCountEntries(sessionStats.master_spec_counts, 10),
    health: {
      risk_level: riskLevel,
      concerns,
      recommendations
    },
    recovery_memory: {
      file: recoveryMemory.file,
      scope: recoveryMemory.scope,
      signature_count: recoverySignatureCount,
      action_count: Number(recoveryMemory && recoveryMemory.stats && recoveryMemory.stats.action_count) || 0
    },
    archives: {
      session: sessionStats,
      batch_session: batchStats,
      controller_session: controllerStats
    }
  };
}

async function buildAutoObservabilitySnapshot(projectPath, options = {}) {
  const days = normalizeStatsWindowDays(options.days);
  const statusFilter = normalizeStatusFilter(options.status);
  const normalizedStatsOptions = {
    days,
    status: statusFilter.length > 0 ? statusFilter.join(',') : undefined
  };
  const normalizedTrendOptions = {
    weeks: options.weeks,
    mode: options.trendMode,
    period: options.trendPeriod
  };

  const [
    sessionStats,
    batchStats,
    controllerStats,
    governanceSessionStats,
    governanceHealth,
    trend
  ] = await Promise.all([
    statsCloseLoopSessions(projectPath, normalizedStatsOptions),
    statsCloseLoopBatchSummarySessions(projectPath, normalizedStatsOptions),
    statsCloseLoopControllerSessions(projectPath, normalizedStatsOptions),
    statsGovernanceCloseLoopSessions(projectPath, normalizedStatsOptions),
    buildAutoGovernanceStats(projectPath, normalizedStatsOptions),
    buildAutoKpiTrend(projectPath, normalizedTrendOptions)
  ]);

  const totalSessions =
    (Number(sessionStats.total_sessions) || 0) +
    (Number(batchStats.total_sessions) || 0) +
    (Number(controllerStats.total_sessions) || 0) +
    (Number(governanceSessionStats.total_sessions) || 0);
  const completedSessions =
    (Number(sessionStats.completed_sessions) || 0) +
    (Number(batchStats.completed_sessions) || 0) +
    (Number(controllerStats.completed_sessions) || 0) +
    (Number(governanceSessionStats.completed_sessions) || 0);
  const failedSessions =
    (Number(sessionStats.failed_sessions) || 0) +
    (Number(batchStats.failed_sessions) || 0) +
    (Number(controllerStats.failed_sessions) || 0) +
    (Number(governanceSessionStats.failed_sessions) || 0);

  return {
    mode: 'auto-observability-snapshot',
    generated_at: new Date().toISOString(),
    schema_version: AUTO_ARCHIVE_SCHEMA_VERSION,
    criteria: {
      days,
      status_filter: statusFilter,
      trend_weeks: trend.weeks,
      trend_mode: trend.mode,
      trend_period: trend.period_unit
    },
    highlights: {
      total_sessions: totalSessions,
      completed_sessions: completedSessions,
      failed_sessions: failedSessions,
      completion_rate_percent: calculatePercent(completedSessions, totalSessions),
      failure_rate_percent: calculatePercent(failedSessions, totalSessions),
      governance_risk_level: governanceHealth && governanceHealth.health
        ? governanceHealth.health.risk_level
        : 'unknown',
      kpi_anomaly_count: Array.isArray(trend.anomalies) ? trend.anomalies.length : 0
    },
    snapshots: {
      close_loop_session: sessionStats,
      batch_session: batchStats,
      controller_session: controllerStats,
      governance_session: governanceSessionStats,
      governance_health: governanceHealth,
      kpi_trend: trend
    }
  };
}

function normalizeSpecName(specNameCandidate) {
  const specName = `${specNameCandidate || ''}`.trim();
  if (!specName) {
    throw new Error('Spec name is required.');
  }
  if (specName.includes('..')) {
    throw new Error('Spec name is invalid.');
  }
  return specName;
}

async function resolveSpecDirectory(projectPath, specNameCandidate) {
  const specName = normalizeSpecName(specNameCandidate);
  const specPath = path.join(projectPath, '.kiro', 'specs', specName);
  if (!(await fs.pathExists(specPath))) {
    throw new Error(`Spec not found: ${specName}`);
  }
  const stats = await fs.stat(specPath);
  if (!stats.isDirectory()) {
    throw new Error(`Spec is not a directory: ${specName}`);
  }
  return {
    name: specName,
    path: specPath
  };
}

async function readOptionalJson(filePath) {
  if (!(await fs.pathExists(filePath))) {
    return {
      exists: false,
      payload: null,
      error: null
    };
  }
  try {
    return {
      exists: true,
      payload: await fs.readJson(filePath),
      error: null
    };
  } catch (error) {
    return {
      exists: true,
      payload: null,
      error: error.message
    };
  }
}

async function readOptionalText(filePath) {
  if (!(await fs.pathExists(filePath))) {
    return {
      exists: false,
      content: '',
      error: null
    };
  }
  try {
    return {
      exists: true,
      content: await fs.readFile(filePath, 'utf8'),
      error: null
    };
  } catch (error) {
    return {
      exists: true,
      content: '',
      error: error.message
    };
  }
}

function parseTaskChecklist(content) {
  const lines = `${content || ''}`.split(/\r?\n/);
  let total = 0;
  let closed = 0;
  const openTasks = [];
  for (const line of lines) {
    const match = line.match(/^\s*-\s*\[([ xX])\]\s*(.+)\s*$/);
    if (!match) {
      continue;
    }
    total += 1;
    const isClosed = `${match[1]}`.toLowerCase() === 'x';
    if (isClosed) {
      closed += 1;
      continue;
    }
    openTasks.push(match[2].trim());
  }
  return {
    total,
    closed,
    open: Math.max(0, total - closed),
    completion_rate_percent: total > 0
      ? Number(((closed / total) * 100).toFixed(2))
      : 0,
    open_tasks: openTasks
  };
}

function summarizeDocExcerpt(content, maxLines = 12) {
  const lines = `${content || ''}`
    .split(/\r?\n/)
    .map(item => item.trim())
    .filter(Boolean);
  if (lines.length === 0) {
    return '';
  }
  return lines.slice(0, maxLines).join('\n');
}

async function buildAutoSpecStatus(projectPath, specNameCandidate) {
  const spec = await resolveSpecDirectory(projectPath, specNameCandidate);
  const requirementsFile = path.join(spec.path, 'requirements.md');
  const designFile = path.join(spec.path, 'design.md');
  const tasksFile = path.join(spec.path, 'tasks.md');
  const collaborationFile = path.join(spec.path, 'collaboration.json');

  const [requirements, design, tasks, collaboration] = await Promise.all([
    readOptionalText(requirementsFile),
    readOptionalText(designFile),
    readOptionalText(tasksFile),
    readOptionalJson(collaborationFile)
  ]);

  const taskProgress = parseTaskChecklist(tasks.content);
  const collaborationPayload = collaboration.payload && typeof collaboration.payload === 'object'
    ? collaboration.payload
    : null;
  const collaborationStatus =
    collaborationPayload &&
    collaborationPayload.status &&
    typeof collaborationPayload.status === 'object' &&
    typeof collaborationPayload.status.current === 'string'
      ? collaborationPayload.status.current
      : collaborationPayload && typeof collaborationPayload.status === 'string'
        ? collaborationPayload.status
        : collaboration.exists && collaboration.error
          ? 'invalid'
          : 'unknown';
  const dependencies = Array.isArray(collaborationPayload && collaborationPayload.dependencies)
    ? collaborationPayload.dependencies
      .map(item => (item && typeof item.spec === 'string' ? item.spec.trim() : ''))
      .filter(Boolean)
    : [];

  const docs = {
    requirements: requirements.exists,
    design: design.exists,
    tasks: tasks.exists,
    all_required_present: requirements.exists && design.exists && tasks.exists
  };

  const blockers = [];
  if (!docs.all_required_present) {
    blockers.push('missing-required-docs');
  }
  if (collaboration.exists && collaboration.error) {
    blockers.push('invalid-collaboration-json');
  }
  if (`${collaborationStatus || ''}`.trim().toLowerCase() === 'blocked') {
    blockers.push('collaboration-blocked');
  }

  return {
    mode: 'auto-spec-status',
    generated_at: new Date().toISOString(),
    spec,
    docs,
    task_progress: {
      total: taskProgress.total,
      closed: taskProgress.closed,
      open: taskProgress.open,
      completion_rate_percent: taskProgress.completion_rate_percent
    },
    collaboration: {
      file: collaborationFile,
      exists: collaboration.exists,
      status: collaborationStatus,
      type: collaborationPayload && typeof collaborationPayload.type === 'string'
        ? collaborationPayload.type
        : null,
      master_spec: collaborationPayload && typeof collaborationPayload.masterSpec === 'string'
        ? collaborationPayload.masterSpec
        : null,
      dependencies,
      parse_error: collaboration.error
    },
    health: {
      ready_for_execution: blockers.length === 0,
      blockers
    }
  };
}

async function buildAutoSpecInstructions(projectPath, specNameCandidate) {
  const specStatus = await buildAutoSpecStatus(projectPath, specNameCandidate);
  const specPath = specStatus.spec.path;
  const tasksFile = path.join(specPath, 'tasks.md');
  const requirementsFile = path.join(specPath, 'requirements.md');
  const designFile = path.join(specPath, 'design.md');

  const [requirements, design, tasks] = await Promise.all([
    readOptionalText(requirementsFile),
    readOptionalText(designFile),
    readOptionalText(tasksFile)
  ]);

  const taskChecklist = parseTaskChecklist(tasks.content);
  const dependencyLine = specStatus.collaboration.dependencies.length > 0
    ? `Resolve dependencies first: ${specStatus.collaboration.dependencies.join(', ')}.`
    : 'No explicit dependencies detected; this spec can execute immediately.';
  const nextActions = [
    dependencyLine,
    taskChecklist.open_tasks.length > 0
      ? `Execute open tasks in order and keep checklist in sync (open: ${taskChecklist.open}).`
      : 'No open checklist tasks detected; verify completion evidence and close out collaboration status.',
    'Update collaboration status after each milestone and before handoff.'
  ];

  return {
    mode: 'auto-spec-instructions',
    generated_at: new Date().toISOString(),
    spec: specStatus.spec,
    status: {
      collaboration_status: specStatus.collaboration.status,
      docs_complete: specStatus.docs.all_required_present,
      task_completion_rate_percent: specStatus.task_progress.completion_rate_percent
    },
    instructions: {
      next_actions: nextActions,
      priority_open_tasks: taskChecklist.open_tasks.slice(0, 20),
      recommended_commands: [
        `kse auto spec status ${specStatus.spec.name} --json`,
        `kse orchestrate ${specStatus.spec.name} --json`
      ],
      document_excerpts: {
        requirements: summarizeDocExcerpt(requirements.content),
        design: summarizeDocExcerpt(design.content),
        tasks: summarizeDocExcerpt(tasks.content)
      }
    }
  };
}

function normalizeSchemaScope(scopeCandidate) {
  const allowed = new Set([
    'close-loop-session',
    'batch-session',
    'controller-session',
    'governance-session'
  ]);
  const raw = `${scopeCandidate || 'all'}`.trim().toLowerCase();
  const tokens = raw.split(',').map(item => item.trim()).filter(Boolean);
  if (tokens.length === 0 || tokens.includes('all')) {
    return [...allowed];
  }
  const normalized = [];
  for (const token of tokens) {
    if (!allowed.has(token)) {
      throw new Error('--only must be one of: all, close-loop-session, batch-session, controller-session, governance-session');
    }
    if (!normalized.includes(token)) {
      normalized.push(token);
    }
  }
  return normalized;
}

function normalizeTargetSchemaVersion(targetVersionCandidate) {
  const normalized = `${targetVersionCandidate || ''}`.trim();
  if (!normalized) {
    throw new Error('--target-version is required.');
  }
  if (normalized.length > 32) {
    throw new Error('--target-version must be 32 characters or fewer.');
  }
  return normalized;
}

function getAutoArchiveSchemaTargets(projectPath, scope) {
  const allTargets = [
    {
      id: 'close-loop-session',
      directory: getCloseLoopSessionDir(projectPath)
    },
    {
      id: 'batch-session',
      directory: getCloseLoopBatchSummaryDir(projectPath)
    },
    {
      id: 'controller-session',
      directory: getCloseLoopControllerSessionDir(projectPath)
    },
    {
      id: 'governance-session',
      directory: getGovernanceCloseLoopSessionDir(projectPath)
    }
  ];
  const scopeSet = new Set(scope);
  return allTargets.filter(item => scopeSet.has(item.id));
}

function classifyArchiveSchemaCompatibility(schemaVersion) {
  const normalized = typeof schemaVersion === 'string' ? schemaVersion.trim() : '';
  if (!normalized) {
    return 'missing_schema_version';
  }
  if (AUTO_ARCHIVE_SCHEMA_SUPPORTED_VERSIONS.has(normalized)) {
    return 'compatible';
  }
  return 'incompatible';
}

async function checkAutoArchiveSchema(projectPath, options = {}) {
  const scope = normalizeSchemaScope(options.only);
  const targets = getAutoArchiveSchemaTargets(projectPath, scope);
  const archives = [];

  for (const target of targets) {
    const archiveSummary = {
      id: target.id,
      directory: target.directory,
      total_files: 0,
      compatible_files: 0,
      missing_schema_version_files: 0,
      incompatible_files: 0,
      parse_error_files: 0,
      issues: []
    };
    if (!(await fs.pathExists(target.directory))) {
      archives.push(archiveSummary);
      continue;
    }
    const files = (await fs.readdir(target.directory))
      .filter(item => item.toLowerCase().endsWith('.json'))
      .sort((left, right) => left.localeCompare(right));
    archiveSummary.total_files = files.length;

    for (const file of files) {
      const filePath = path.join(target.directory, file);
      let payload = null;
      try {
        payload = await fs.readJson(filePath);
      } catch (error) {
        archiveSummary.parse_error_files += 1;
        archiveSummary.issues.push({
          file: filePath,
          compatibility: 'parse_error',
          error: error.message
        });
        continue;
      }
      if (!payload || typeof payload !== 'object' || Array.isArray(payload)) {
        archiveSummary.parse_error_files += 1;
        archiveSummary.issues.push({
          file: filePath,
          compatibility: 'parse_error',
          error: 'invalid JSON root type'
        });
        continue;
      }
      const schemaVersion = typeof payload.schema_version === 'string'
        ? payload.schema_version.trim()
        : '';
      const compatibility = classifyArchiveSchemaCompatibility(schemaVersion);
      if (compatibility === 'compatible') {
        archiveSummary.compatible_files += 1;
      } else if (compatibility === 'missing_schema_version') {
        archiveSummary.missing_schema_version_files += 1;
        archiveSummary.issues.push({
          file: filePath,
          compatibility,
          schema_version: null
        });
      } else {
        archiveSummary.incompatible_files += 1;
        archiveSummary.issues.push({
          file: filePath,
          compatibility,
          schema_version: schemaVersion
        });
      }
    }
    archives.push(archiveSummary);
  }

  const totals = archives.reduce((acc, item) => ({
    total_files: acc.total_files + item.total_files,
    compatible_files: acc.compatible_files + item.compatible_files,
    missing_schema_version_files: acc.missing_schema_version_files + item.missing_schema_version_files,
    incompatible_files: acc.incompatible_files + item.incompatible_files,
    parse_error_files: acc.parse_error_files + item.parse_error_files
  }), {
    total_files: 0,
    compatible_files: 0,
    missing_schema_version_files: 0,
    incompatible_files: 0,
    parse_error_files: 0
  });

  return {
    mode: 'auto-schema-check',
    generated_at: new Date().toISOString(),
    supported_versions: [...AUTO_ARCHIVE_SCHEMA_SUPPORTED_VERSIONS],
    scope,
    summary: {
      ...totals,
      compatibility_rate_percent: calculatePercent(totals.compatible_files, totals.total_files)
    },
    archives
  };
}

async function migrateAutoArchiveSchema(projectPath, options = {}) {
  const scope = normalizeSchemaScope(options.only);
  const targetVersion = normalizeTargetSchemaVersion(options.targetVersion || AUTO_ARCHIVE_SCHEMA_VERSION);
  const dryRun = !options.apply;
  const targets = getAutoArchiveSchemaTargets(projectPath, scope);
  const archives = [];

  for (const target of targets) {
    const archiveSummary = {
      id: target.id,
      directory: target.directory,
      total_files: 0,
      candidate_files: 0,
      updated_files: 0,
      skipped_compatible_files: 0,
      parse_error_files: 0,
      updates: [],
      errors: []
    };
    if (!(await fs.pathExists(target.directory))) {
      archives.push(archiveSummary);
      continue;
    }

    const files = (await fs.readdir(target.directory))
      .filter(item => item.toLowerCase().endsWith('.json'))
      .sort((left, right) => left.localeCompare(right));
    archiveSummary.total_files = files.length;

    for (const file of files) {
      const filePath = path.join(target.directory, file);
      let payload = null;
      try {
        payload = await fs.readJson(filePath);
      } catch (error) {
        archiveSummary.parse_error_files += 1;
        archiveSummary.errors.push({
          file: filePath,
          error: error.message
        });
        continue;
      }
      if (!payload || typeof payload !== 'object' || Array.isArray(payload)) {
        archiveSummary.parse_error_files += 1;
        archiveSummary.errors.push({
          file: filePath,
          error: 'invalid JSON root type'
        });
        continue;
      }

      const previousVersion = typeof payload.schema_version === 'string'
        ? payload.schema_version.trim()
        : '';
      if (previousVersion === targetVersion) {
        archiveSummary.skipped_compatible_files += 1;
        continue;
      }

      archiveSummary.candidate_files += 1;
      if (dryRun) {
        archiveSummary.updates.push({
          file: filePath,
          from: previousVersion || null,
          to: targetVersion
        });
        continue;
      }

      payload.schema_version = targetVersion;
      await fs.writeJson(filePath, payload, { spaces: 2 });
      archiveSummary.updated_files += 1;
      archiveSummary.updates.push({
        file: filePath,
        from: previousVersion || null,
        to: targetVersion
      });
    }
    archives.push(archiveSummary);
  }

  const totals = archives.reduce((acc, item) => ({
    total_files: acc.total_files + item.total_files,
    candidate_files: acc.candidate_files + item.candidate_files,
    updated_files: acc.updated_files + item.updated_files,
    skipped_compatible_files: acc.skipped_compatible_files + item.skipped_compatible_files,
    parse_error_files: acc.parse_error_files + item.parse_error_files
  }), {
    total_files: 0,
    candidate_files: 0,
    updated_files: 0,
    skipped_compatible_files: 0,
    parse_error_files: 0
  });

  return {
    mode: 'auto-schema-migrate',
    generated_at: new Date().toISOString(),
    dry_run: dryRun,
    target_version: targetVersion,
    scope,
    summary: totals,
    archives
  };
}

function normalizeGovernanceKeepOption(keepCandidate, flagName, fallback = 50) {
  if (keepCandidate === undefined || keepCandidate === null) {
    return fallback;
  }
  const parsed = Number(keepCandidate);
  if (!Number.isInteger(parsed) || parsed < 0 || parsed > 1000) {
    throw new Error(`${flagName} must be an integer between 0 and 1000.`);
  }
  return parsed;
}

function normalizeGovernanceRecoveryOlderThanDays(daysCandidate, fallback = 90) {
  if (daysCandidate === undefined || daysCandidate === null) {
    return fallback;
  }
  const parsed = Number(daysCandidate);
  if (!Number.isInteger(parsed) || parsed < 0 || parsed > 36500) {
    throw new Error('--recovery-memory-older-than-days must be an integer between 0 and 36500.');
  }
  return parsed;
}

function normalizeGovernanceTargetRiskLevel(levelCandidate) {
  const normalized = `${levelCandidate || 'low'}`.trim().toLowerCase();
  if (!['low', 'medium', 'high'].includes(normalized)) {
    throw new Error('--target-risk must be one of: low, medium, high.');
  }
  return normalized;
}

function normalizeGovernanceMaxRounds(roundsCandidate, fallback = 3) {
  if (roundsCandidate === undefined || roundsCandidate === null) {
    return fallback;
  }
  const parsed = Number(roundsCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 20) {
    throw new Error('--max-rounds must be an integer between 1 and 20.');
  }
  return parsed;
}

function normalizeGovernanceSessionKeep(keepCandidate) {
  if (keepCandidate === undefined || keepCandidate === null) {
    return null;
  }
  const parsed = Number(keepCandidate);
  if (!Number.isInteger(parsed) || parsed < 0 || parsed > 1000) {
    throw new Error('--governance-session-keep must be an integer between 0 and 1000.');
  }
  return parsed;
}

function normalizeGovernanceSessionOlderThanDays(daysCandidate) {
  if (daysCandidate === undefined || daysCandidate === null) {
    return null;
  }
  const parsed = Number(daysCandidate);
  if (!Number.isInteger(parsed) || parsed < 0 || parsed > 36500) {
    throw new Error('--governance-session-older-than-days must be an integer between 0 and 36500.');
  }
  return parsed;
}

function normalizeGovernanceAdvisoryRecoverMaxRounds(roundsCandidate, fallback = 3) {
  if (roundsCandidate === undefined || roundsCandidate === null) {
    return fallback;
  }
  const parsed = Number(roundsCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 20) {
    throw new Error('--advisory-recover-max-rounds must be an integer between 1 and 20.');
  }
  return parsed;
}

function normalizeGovernanceAdvisoryControllerMaxCycles(cyclesCandidate, fallback = 20) {
  if (cyclesCandidate === undefined || cyclesCandidate === null) {
    return fallback;
  }
  const parsed = Number(cyclesCandidate);
  if (!Number.isInteger(parsed) || parsed < 1 || parsed > 100000) {
    throw new Error('--advisory-controller-max-cycles must be an integer between 1 and 100000.');
  }
  return parsed;
}

function getCommandOptionSources(command, optionNames = []) {
  if (!command || typeof command.getOptionValueSource !== 'function') {
    return {};
  }
  const sources = {};
  for (const optionName of optionNames) {
    if (typeof optionName !== 'string' || !optionName.trim()) {
      continue;
    }
    sources[optionName] = command.getOptionValueSource(optionName);
  }
  return sources;
}

function isExplicitOptionSource(source) {
  return Boolean(source) && source !== 'default';
}

function compareRiskLevel(left, right) {
  const rank = { low: 1, medium: 2, high: 3 };
  const leftRank = rank[`${left || ''}`.trim().toLowerCase()] || 99;
  const rightRank = rank[`${right || ''}`.trim().toLowerCase()] || 99;
  return leftRank - rightRank;
}

function buildAutoGovernanceMaintenancePlan(assessment, policy, dryRun = false) {
  const sessionTotal = Number(assessment && assessment.archives && assessment.archives.session && assessment.archives.session.total_sessions) || 0;
  const batchTotal = Number(assessment && assessment.archives && assessment.archives.batch_session && assessment.archives.batch_session.total_sessions) || 0;
  const controllerTotal = Number(assessment && assessment.archives && assessment.archives.controller_session && assessment.archives.controller_session.total_sessions) || 0;
  const recoverySignatureCount = Number(assessment && assessment.recovery_memory && assessment.recovery_memory.signature_count) || 0;
  const failedSessions = Number(assessment && assessment.totals && assessment.totals.failed_sessions) || 0;
  const pendingGoals = Number(assessment && assessment.throughput && assessment.throughput.controller_pending_goals_sum) || 0;

  const sessionCommand = `kse auto session prune --keep ${policy.session_keep}${dryRun ? ' --dry-run' : ''} --json`;
  const batchCommand = `kse auto batch-session prune --keep ${policy.batch_session_keep}${dryRun ? ' --dry-run' : ''} --json`;
  const controllerCommand = `kse auto controller-session prune --keep ${policy.controller_session_keep}${dryRun ? ' --dry-run' : ''} --json`;
  const recoveryCommand = `kse auto recovery-memory prune --older-than-days ${policy.recovery_memory_older_than_days}${dryRun ? ' --dry-run' : ''} --json`;

  const plan = [
    {
      id: 'session-prune',
      type: 'maintenance',
      apply_supported: true,
      enabled: sessionTotal > policy.session_keep,
      reason: sessionTotal > policy.session_keep
        ? `close-loop session archive ${sessionTotal} exceeds keep policy ${policy.session_keep}`
        : 'close-loop session archive is within keep policy',
      command: sessionCommand,
      target_total: sessionTotal,
      keep: policy.session_keep
    },
    {
      id: 'batch-session-prune',
      type: 'maintenance',
      apply_supported: true,
      enabled: batchTotal > policy.batch_session_keep,
      reason: batchTotal > policy.batch_session_keep
        ? `batch session archive ${batchTotal} exceeds keep policy ${policy.batch_session_keep}`
        : 'batch session archive is within keep policy',
      command: batchCommand,
      target_total: batchTotal,
      keep: policy.batch_session_keep
    },
    {
      id: 'controller-session-prune',
      type: 'maintenance',
      apply_supported: true,
      enabled: controllerTotal > policy.controller_session_keep,
      reason: controllerTotal > policy.controller_session_keep
        ? `controller session archive ${controllerTotal} exceeds keep policy ${policy.controller_session_keep}`
        : 'controller session archive is within keep policy',
      command: controllerCommand,
      target_total: controllerTotal,
      keep: policy.controller_session_keep
    },
    {
      id: 'recovery-memory-prune',
      type: 'maintenance',
      apply_supported: true,
      enabled: recoverySignatureCount > 0,
      reason: recoverySignatureCount > 0
        ? `recovery memory contains ${recoverySignatureCount} signature(s), prune stale entries`
        : 'recovery memory is empty',
      command: recoveryCommand,
      target_total: recoverySignatureCount,
      older_than_days: policy.recovery_memory_older_than_days
    },
    {
      id: 'recover-latest',
      type: 'advisory',
      apply_supported: false,
      enabled: failedSessions > 0,
      reason: failedSessions > 0
        ? `${failedSessions} failed session(s) detected, run recovery drain`
        : 'no failed sessions detected',
      command: 'kse auto close-loop-recover latest --recover-until-complete --json'
    },
    {
      id: 'controller-resume-latest',
      type: 'advisory',
      apply_supported: false,
      enabled: pendingGoals > 0,
      reason: pendingGoals > 0
        ? `${pendingGoals} pending controller goal(s) detected, resume controller queue`
        : 'no pending controller goals detected',
      command: 'kse auto close-loop-controller --controller-resume latest --json'
    }
  ];

  return plan;
}

function summarizeGovernanceMaintenanceExecution(plan, executedActions) {
  const safePlan = Array.isArray(plan) ? plan : [];
  const safeExecuted = Array.isArray(executedActions) ? executedActions : [];
  const plannedActions = safePlan.filter(item => item && item.enabled).length;
  const applicableActions = safePlan.filter(item => item && item.enabled && item.apply_supported).length;
  const advisoryActions = safePlan.filter(item => item && item.enabled && !item.apply_supported).length;
  const appliedActions = safeExecuted.filter(item => item && item.status === 'applied').length;
  const failedActions = safeExecuted.filter(item => item && item.status === 'failed').length;
  return {
    planned_actions: plannedActions,
    applicable_actions: applicableActions,
    advisory_actions: advisoryActions,
    applied_actions: appliedActions,
    failed_actions: failedActions
  };
}

async function runAutoGovernanceMaintenance(projectPath, options = {}) {
  const days = normalizeStatsWindowDays(options.days);
  const statusFilter = normalizeStatusFilter(options.status);
  const assessmentOptions = {
    days,
    status: statusFilter.length > 0 ? statusFilter.join(',') : undefined
  };
  const policy = {
    session_keep: normalizeGovernanceKeepOption(options.sessionKeep, '--session-keep', 50),
    batch_session_keep: normalizeGovernanceKeepOption(options.batchSessionKeep, '--batch-session-keep', 50),
    controller_session_keep: normalizeGovernanceKeepOption(options.controllerSessionKeep, '--controller-session-keep', 50),
    recovery_memory_older_than_days: normalizeGovernanceRecoveryOlderThanDays(options.recoveryMemoryOlderThanDays, 90)
  };
  const apply = Boolean(options.apply);
  const dryRun = Boolean(options.dryRun);
  const assessment = await buildAutoGovernanceStats(projectPath, assessmentOptions);
  const plan = buildAutoGovernanceMaintenancePlan(assessment, policy, dryRun);
  const executedActions = [];

  if (apply) {
    for (const action of plan) {
      if (!action.enabled || !action.apply_supported) {
        continue;
      }
      try {
        let result = null;
        if (action.id === 'session-prune') {
          result = await pruneCloseLoopSessions(projectPath, {
            keep: policy.session_keep,
            olderThanDays: null,
            dryRun
          });
        } else if (action.id === 'batch-session-prune') {
          result = await pruneCloseLoopBatchSummarySessionsCli(projectPath, {
            keep: policy.batch_session_keep,
            olderThanDays: null,
            dryRun
          });
        } else if (action.id === 'controller-session-prune') {
          result = await pruneCloseLoopControllerSessionsCli(projectPath, {
            keep: policy.controller_session_keep,
            olderThanDays: null,
            dryRun
          });
        } else if (action.id === 'recovery-memory-prune') {
          result = await pruneCloseLoopRecoveryMemory(projectPath, {
            olderThanDays: policy.recovery_memory_older_than_days,
            dryRun
          });
        }
        executedActions.push({
          id: action.id,
          status: 'applied',
          result
        });
      } catch (error) {
        executedActions.push({
          id: action.id,
          status: 'failed',
          error: error.message
        });
      }
    }
  }

  const afterAssessment = apply && !dryRun
    ? await buildAutoGovernanceStats(projectPath, assessmentOptions)
    : null;
  return {
    mode: 'auto-governance-maintain',
    generated_at: new Date().toISOString(),
    apply,
    dry_run: dryRun,
    criteria: {
      days,
      status_filter: statusFilter,
      since: days === null
        ? null
        : new Date(Date.now() - (days * 24 * 60 * 60 * 1000)).toISOString()
    },
    policy,
    assessment,
    plan,
    executed_actions: executedActions,
    summary: summarizeGovernanceMaintenanceExecution(plan, executedActions),
    after_assessment: afterAssessment
  };
}

async function resolveLatestRecoverableBatchSummary(projectPath, resumeStrategy = 'pending') {
  const entries = await readCloseLoopBatchSummaryEntries(projectPath);
  for (const entry of entries) {
    if (!entry || !entry.file) {
      continue;
    }
    let loaded = null;
    try {
      loaded = await loadCloseLoopBatchSummaryPayload(projectPath, entry.file);
      const goalsResult = await buildCloseLoopBatchGoalsFromSummaryPayload(
        loaded.payload,
        loaded.file,
        projectPath,
        'auto',
        resumeStrategy
      );
      if (Array.isArray(goalsResult.goals) && goalsResult.goals.length > 0) {
        return loaded;
      }
    } catch (error) {
      continue;
    }
  }
  return null;
}

async function resolveLatestPendingControllerSession(projectPath) {
  const sessions = await readCloseLoopControllerSessionEntries(projectPath);
  const pendingSession = sessions.find(session => Number(session && session.pending_goals) > 0);
  if (!pendingSession || !pendingSession.file) {
    return null;
  }
  try {
    return await loadCloseLoopControllerSessionPayload(projectPath, pendingSession.file);
  } catch (error) {
    return null;
  }
}

async function executeGovernanceAdvisoryRecover(projectPath, options = {}) {
  const recoverMaxRounds = normalizeGovernanceAdvisoryRecoverMaxRounds(options.recoverMaxRounds, 3);
  const dryRun = Boolean(options.dryRun);
  const summaryCandidate = typeof options.summary === 'string' && options.summary.trim()
    ? options.summary.trim()
    : 'latest';
  const explicitSummary = summaryCandidate.toLowerCase() !== 'latest';
  let sourceSummary = null;

  if (explicitSummary) {
    try {
      sourceSummary = await loadCloseLoopBatchSummaryPayload(projectPath, summaryCandidate);
    } catch (error) {
      return {
        id: 'recover-latest',
        status: 'failed',
        recover_max_rounds: recoverMaxRounds,
        dry_run: dryRun,
        error: error.message
      };
    }
  } else {
    sourceSummary = await resolveLatestRecoverableBatchSummary(projectPath, 'pending');
  }

  if (!sourceSummary) {
    return {
      id: 'recover-latest',
      status: 'skipped',
      recover_max_rounds: recoverMaxRounds,
      dry_run: dryRun,
      error: 'No recoverable batch summary with pending goals was found.'
    };
  }

  try {
    const recoveryMemoryScope = await resolveRecoveryMemoryScope(projectPath, options.recoveryMemoryScope);
    const recoveryResult = await executeCloseLoopRecoveryCycle({
      projectPath,
      sourceSummary,
      baseOptions: {
        dryRun,
        run: dryRun ? false : undefined,
        resumeStrategy: 'pending',
        batchAutonomous: true,
        continueOnError: true
      },
      recoverAutonomousEnabled: true,
      resumeStrategy: 'pending',
      recoverUntilComplete: true,
      recoverMaxRounds,
      recoverMaxDurationMs: null,
      recoveryMemoryTtlDays: null,
      recoveryMemoryScope,
      actionCandidate: null
    });
    const recoverySummary = recoveryResult && recoveryResult.summary ? recoveryResult.summary : null;
    const recoveryStatus = `${recoverySummary && recoverySummary.status ? recoverySummary.status : ''}`
      .trim()
      .toLowerCase();
    const failed = recoveryStatus === 'failed' || recoveryStatus === 'partial-failed';

    return {
      id: 'recover-latest',
      status: failed ? 'failed' : 'applied',
      recover_max_rounds: recoverMaxRounds,
      dry_run: dryRun,
      source_summary_file: sourceSummary.file,
      result: recoverySummary
        ? {
          status: recoverySummary.status,
          processed_goals: Number(recoverySummary.processed_goals) || 0,
          failed_goals: Number(recoverySummary.failed_goals) || 0,
          recovery_cycle: recoverySummary.recovery_cycle || null,
          batch_session_file: recoverySummary.batch_session && recoverySummary.batch_session.file
            ? recoverySummary.batch_session.file
            : null
        }
        : null,
      error: failed && recoverySummary
        ? `Recovery finished with status: ${recoverySummary.status}`
        : null
    };
  } catch (error) {
    return {
      id: 'recover-latest',
      status: 'failed',
      recover_max_rounds: recoverMaxRounds,
      dry_run: dryRun,
      source_summary_file: sourceSummary.file,
      error: error.message
    };
  }
}

async function executeGovernanceAdvisoryControllerResume(projectPath, options = {}) {
  const maxCycles = normalizeGovernanceAdvisoryControllerMaxCycles(options.maxCycles, 20);
  const dryRun = Boolean(options.dryRun);
  const sessionCandidate = typeof options.session === 'string' && options.session.trim()
    ? options.session.trim()
    : 'latest';
  const explicitSession = sessionCandidate.toLowerCase() !== 'latest';
  let sourceSession = null;

  if (explicitSession) {
    try {
      sourceSession = await loadCloseLoopControllerSessionPayload(projectPath, sessionCandidate);
    } catch (error) {
      return {
        id: 'controller-resume-latest',
        status: 'failed',
        max_cycles: maxCycles,
        dry_run: dryRun,
        error: error.message
      };
    }
  } else {
    sourceSession = await resolveLatestPendingControllerSession(projectPath);
  }

  if (!sourceSession) {
    return {
      id: 'controller-resume-latest',
      status: 'skipped',
      max_cycles: maxCycles,
      dry_run: dryRun,
      error: 'No controller session with pending goals was found.'
    };
  }

  try {
    const controllerSummary = await runCloseLoopController(null, {
      maxCycles,
      dryRun,
      run: dryRun ? false : undefined,
      waitOnEmpty: false,
      stopOnGoalFailure: false,
      controllerPrintProgramSummary: false,
      controllerOut: null,
      out: null,
      json: false
    }, {
      projectPath,
      resumedSession: sourceSession
    });
    const controllerStatus = `${controllerSummary && controllerSummary.status ? controllerSummary.status : ''}`
      .trim()
      .toLowerCase();
    const failed = controllerStatus === 'failed' || controllerStatus === 'partial-failed';

    return {
      id: 'controller-resume-latest',
      status: failed ? 'failed' : 'applied',
      max_cycles: maxCycles,
      dry_run: dryRun,
      source_controller_session_file: sourceSession.file,
      result: controllerSummary
        ? {
          status: controllerSummary.status,
          cycles_performed: Number(controllerSummary.cycles_performed) || 0,
          processed_goals: Number(controllerSummary.processed_goals) || 0,
          failed_goals: Number(controllerSummary.failed_goals) || 0,
          pending_goals: Number(controllerSummary.pending_goals) || 0,
          stop_reason: controllerSummary.stop_reason || null,
          controller_session_file: controllerSummary.controller_session && controllerSummary.controller_session.file
            ? controllerSummary.controller_session.file
            : null
        }
        : null,
      error: failed && controllerSummary
        ? `Controller resume finished with status: ${controllerSummary.status}`
        : null
    };
  } catch (error) {
    return {
      id: 'controller-resume-latest',
      status: 'failed',
      max_cycles: maxCycles,
      dry_run: dryRun,
      source_controller_session_file: sourceSession.file,
      error: error.message
    };
  }
}

function resolveGovernanceCloseLoopRunStatus(stopReason, converged) {
  if (converged) {
    return 'completed';
  }
  if (['maintenance-action-failed', 'advisory-action-failed'].includes(`${stopReason || ''}`.trim().toLowerCase())) {
    return 'failed';
  }
  return 'stopped';
}

async function runAutoGovernanceCloseLoop(projectPath, options = {}) {
  let resumedGovernanceSession = null;
  if (options.governanceResume) {
    resumedGovernanceSession = await loadGovernanceCloseLoopSessionPayload(projectPath, options.governanceResume);
  }

  const resumePayload = resumedGovernanceSession && resumedGovernanceSession.payload && typeof resumedGovernanceSession.payload === 'object'
    ? resumedGovernanceSession.payload
    : null;
  const optionSources = options && options.optionSources && typeof options.optionSources === 'object'
    ? options.optionSources
    : {};
  const isExplicitOption = optionName => isExplicitOptionSource(optionSources[optionName]);
  const allowResumeDrift = Boolean(options.governanceResumeAllowDrift);

  const maxRounds = normalizeGovernanceMaxRounds(
    options.maxRounds !== undefined && options.maxRounds !== null
      ? options.maxRounds
      : (resumePayload && resumePayload.max_rounds !== undefined && resumePayload.max_rounds !== null
        ? resumePayload.max_rounds
        : undefined),
    3
  );
  const resumeTargetRisk = resumedGovernanceSession && resumePayload && typeof resumePayload.target_risk === 'string'
    ? normalizeGovernanceTargetRiskLevel(resumePayload.target_risk)
    : null;
  const targetRisk = normalizeGovernanceTargetRiskLevel(
    resumedGovernanceSession && !isExplicitOption('targetRisk')
      ? (resumePayload && resumePayload.target_risk !== undefined && resumePayload.target_risk !== null
        ? resumePayload.target_risk
        : options.targetRisk)
      : options.targetRisk
  );
  const resumeExecuteAdvisory = resumedGovernanceSession && resumePayload && typeof resumePayload.execute_advisory === 'boolean'
    ? resumePayload.execute_advisory
    : false;
  const executeAdvisory = resumedGovernanceSession && !isExplicitOption('executeAdvisory')
    ? resumeExecuteAdvisory
    : Boolean(options.executeAdvisory);
  const resumeAdvisoryPolicy = resumePayload && resumePayload.advisory_policy && typeof resumePayload.advisory_policy === 'object'
    ? resumePayload.advisory_policy
    : null;
  const resumeAdvisoryRecoverMaxRounds = resumeAdvisoryPolicy && resumeAdvisoryPolicy.recover_max_rounds !== undefined &&
    resumeAdvisoryPolicy.recover_max_rounds !== null
    ? normalizeGovernanceAdvisoryRecoverMaxRounds(resumeAdvisoryPolicy.recover_max_rounds, 3)
    : 3;
  const resumeAdvisoryControllerMaxCycles = resumeAdvisoryPolicy && resumeAdvisoryPolicy.controller_max_cycles !== undefined &&
    resumeAdvisoryPolicy.controller_max_cycles !== null
    ? normalizeGovernanceAdvisoryControllerMaxCycles(resumeAdvisoryPolicy.controller_max_cycles, 20)
    : 20;
  const governanceSessionEnabled = options.governanceSession !== false;
  const governanceSessionKeep = normalizeGovernanceSessionKeep(options.governanceSessionKeep);
  const governanceSessionOlderThanDays = normalizeGovernanceSessionOlderThanDays(options.governanceSessionOlderThanDays);
  if (governanceSessionOlderThanDays !== null && governanceSessionKeep === null) {
    throw new Error('--governance-session-older-than-days requires --governance-session-keep.');
  }
  const requestedGovernanceSessionId = options.governanceSessionId !== undefined && options.governanceSessionId !== null
    ? sanitizeBatchSessionId(options.governanceSessionId)
    : null;
  if (options.governanceSessionId && !requestedGovernanceSessionId) {
    throw new Error('--governance-session-id is invalid after sanitization.');
  }
  let governanceSessionId = requestedGovernanceSessionId
    || (resumedGovernanceSession && resumedGovernanceSession.id ? sanitizeBatchSessionId(resumedGovernanceSession.id) : null)
    || (governanceSessionEnabled ? createGovernanceCloseLoopSessionId() : null);
  if (governanceSessionEnabled && !governanceSessionId) {
    throw new Error('Failed to resolve governance close-loop session id.');
  }
  if (
    !executeAdvisory &&
    options.advisoryRecoverMaxRounds !== undefined &&
    options.advisoryRecoverMaxRounds !== null
  ) {
    throw new Error('--advisory-recover-max-rounds requires --execute-advisory.');
  }
  if (
    !executeAdvisory &&
    options.advisoryControllerMaxCycles !== undefined &&
    options.advisoryControllerMaxCycles !== null
  ) {
    throw new Error('--advisory-controller-max-cycles requires --execute-advisory.');
  }
  const advisoryRecoverMaxRounds = normalizeGovernanceAdvisoryRecoverMaxRounds(
    resumedGovernanceSession && !isExplicitOption('advisoryRecoverMaxRounds')
      ? (resumeAdvisoryPolicy && resumeAdvisoryPolicy.recover_max_rounds !== undefined &&
        resumeAdvisoryPolicy.recover_max_rounds !== null
        ? resumeAdvisoryPolicy.recover_max_rounds
        : options.advisoryRecoverMaxRounds)
      : options.advisoryRecoverMaxRounds,
    3
  );
  const advisoryControllerMaxCycles = normalizeGovernanceAdvisoryControllerMaxCycles(
    resumedGovernanceSession && !isExplicitOption('advisoryControllerMaxCycles')
      ? (resumeAdvisoryPolicy && resumeAdvisoryPolicy.controller_max_cycles !== undefined &&
        resumeAdvisoryPolicy.controller_max_cycles !== null
        ? resumeAdvisoryPolicy.controller_max_cycles
        : options.advisoryControllerMaxCycles)
      : options.advisoryControllerMaxCycles,
    20
  );
  const planOnly = Boolean(options.planOnly);
  const dryRun = Boolean(options.dryRun);
  const days = normalizeStatsWindowDays(options.days);
  const statusFilter = normalizeStatusFilter(options.status);
  const assessmentOptions = {
    days,
    status: statusFilter.length > 0 ? statusFilter.join(',') : undefined
  };
  const apply = !planOnly;
  const rounds = Array.isArray(resumePayload && resumePayload.rounds)
    ? [...resumePayload.rounds]
    : [];
  if (
    resumedGovernanceSession &&
    !allowResumeDrift &&
    isExplicitOption('maxRounds') &&
    maxRounds < rounds.length
  ) {
    throw new Error(
      `--max-rounds (${maxRounds}) is lower than resumed performed rounds (${rounds.length}). ` +
      'Use --governance-resume-allow-drift to override.'
    );
  }
  if (resumedGovernanceSession && !allowResumeDrift) {
    const driftIssues = [];
    if (isExplicitOption('targetRisk') && resumeTargetRisk && targetRisk !== resumeTargetRisk) {
      driftIssues.push(`target-risk resumed=${resumeTargetRisk} requested=${targetRisk}`);
    }
    if (isExplicitOption('executeAdvisory') && executeAdvisory !== resumeExecuteAdvisory) {
      driftIssues.push(
        `execute-advisory resumed=${resumeExecuteAdvisory ? 'enabled' : 'disabled'} ` +
        `requested=${executeAdvisory ? 'enabled' : 'disabled'}`
      );
    }
    if (
      executeAdvisory &&
      resumeExecuteAdvisory &&
      isExplicitOption('advisoryRecoverMaxRounds') &&
      advisoryRecoverMaxRounds !== resumeAdvisoryRecoverMaxRounds
    ) {
      driftIssues.push(
        `advisory-recover-max-rounds resumed=${resumeAdvisoryRecoverMaxRounds} requested=${advisoryRecoverMaxRounds}`
      );
    }
    if (
      executeAdvisory &&
      resumeExecuteAdvisory &&
      isExplicitOption('advisoryControllerMaxCycles') &&
      advisoryControllerMaxCycles !== resumeAdvisoryControllerMaxCycles
    ) {
      driftIssues.push(
        `advisory-controller-max-cycles resumed=${resumeAdvisoryControllerMaxCycles} ` +
        `requested=${advisoryControllerMaxCycles}`
      );
    }
    if (driftIssues.length > 0) {
      throw new Error(
        `Governance resume option drift detected: ${driftIssues.join('; ')}. ` +
        'Use --governance-resume-allow-drift to override.'
      );
    }
  }
  let stopReason = 'max-rounds-exhausted';
  let converged = Boolean(resumePayload && resumePayload.converged);
  let initialAssessment = resumePayload && resumePayload.initial_assessment
    ? resumePayload.initial_assessment
    : null;
  let finalAssessment = resumePayload && resumePayload.final_assessment
    ? resumePayload.final_assessment
    : null;
  const advisorySummary = {
    planned_actions: Number(resumePayload && resumePayload.advisory_summary && resumePayload.advisory_summary.planned_actions) || 0,
    executed_actions: Number(resumePayload && resumePayload.advisory_summary && resumePayload.advisory_summary.executed_actions) || 0,
    failed_actions: Number(resumePayload && resumePayload.advisory_summary && resumePayload.advisory_summary.failed_actions) || 0,
    skipped_actions: Number(resumePayload && resumePayload.advisory_summary && resumePayload.advisory_summary.skipped_actions) || 0
  };
  let governanceSessionPrune = null;

  const buildGovernanceCloseLoopResult = () => ({
    mode: 'auto-governance-close-loop',
    generated_at: new Date().toISOString(),
    apply,
    plan_only: planOnly,
    dry_run: dryRun,
    target_risk: targetRisk,
    max_rounds: maxRounds,
    performed_rounds: rounds.length,
    converged,
    execute_advisory: executeAdvisory,
    advisory_policy: {
      recover_max_rounds: advisoryRecoverMaxRounds,
      controller_max_cycles: advisoryControllerMaxCycles
    },
    advisory_summary: advisorySummary,
    stop_reason: stopReason,
    initial_assessment: initialAssessment,
    final_assessment: finalAssessment,
    resumed_from_governance_session: resumedGovernanceSession
      ? {
        id: resumedGovernanceSession.id,
        file: resumedGovernanceSession.file,
        status: resumePayload && resumePayload.status ? resumePayload.status : null
      }
      : null,
    governance_session: governanceSessionEnabled
      ? {
        id: governanceSessionId,
        file: path.join(getGovernanceCloseLoopSessionDir(projectPath), `${governanceSessionId}.json`)
      }
      : null,
    governance_session_prune: governanceSessionPrune,
    rounds
  });

  const persistGovernanceState = async status => {
    if (!governanceSessionEnabled) {
      return;
    }
    const persisted = await persistGovernanceCloseLoopSession(projectPath, governanceSessionId, buildGovernanceCloseLoopResult(), status);
    if (persisted && persisted.id) {
      governanceSessionId = persisted.id;
    }
  };

  if (converged) {
    stopReason = 'already-converged';
  } else if (rounds.length >= maxRounds) {
    stopReason = 'max-rounds-already-reached';
  } else {
    await persistGovernanceState('running');
  }

  for (let round = rounds.length + 1; round <= maxRounds && stopReason === 'max-rounds-exhausted'; round += 1) {
    const roundResult = await runAutoGovernanceMaintenance(projectPath, {
      ...options,
      apply,
      dryRun
    });
    if (!initialAssessment) {
      initialAssessment = roundResult.assessment;
    }
    const roundPlan = Array.isArray(roundResult.plan) ? roundResult.plan : [];
    const advisoryPlannedActions = roundPlan.filter(item => item && item.enabled && !item.apply_supported).length;
    const advisoryActions = [];

    if (executeAdvisory && apply) {
      const shouldRecover = roundPlan.some(item => item && item.id === 'recover-latest' && item.enabled);
      if (shouldRecover) {
        advisoryActions.push(await executeGovernanceAdvisoryRecover(projectPath, {
          recoverMaxRounds: advisoryRecoverMaxRounds,
          dryRun,
          recoveryMemoryScope: options.recoveryMemoryScope
        }));
      }

      const shouldResumeController = roundPlan.some(item => item && item.id === 'controller-resume-latest' && item.enabled);
      if (shouldResumeController) {
        advisoryActions.push(await executeGovernanceAdvisoryControllerResume(projectPath, {
          maxCycles: advisoryControllerMaxCycles,
          dryRun
        }));
      }
    }

    const advisoryExecutedActions = advisoryActions.filter(item => item && item.status === 'applied').length;
    const advisoryFailedActions = advisoryActions.filter(item => item && item.status === 'failed').length;
    const advisorySkippedActions = advisoryActions.filter(item => item && item.status === 'skipped').length;
    advisorySummary.planned_actions += advisoryPlannedActions;
    advisorySummary.executed_actions += advisoryExecutedActions;
    advisorySummary.failed_actions += advisoryFailedActions;
    advisorySummary.skipped_actions += advisorySkippedActions;

    let effectiveAfterAssessment = roundResult.after_assessment || roundResult.assessment;
    if (executeAdvisory && advisoryActions.length > 0) {
      effectiveAfterAssessment = await buildAutoGovernanceStats(projectPath, assessmentOptions);
    }
    finalAssessment = effectiveAfterAssessment;
    rounds.push({
      round,
      risk_before: roundResult.assessment && roundResult.assessment.health
        ? roundResult.assessment.health.risk_level
        : null,
      risk_after: effectiveAfterAssessment && effectiveAfterAssessment.health
        ? effectiveAfterAssessment.health.risk_level
        : null,
      planned_actions: roundResult.summary.planned_actions,
      applicable_actions: roundResult.summary.applicable_actions,
      applied_actions: roundResult.summary.applied_actions,
      failed_actions: roundResult.summary.failed_actions,
      advisory_planned_actions: advisoryPlannedActions,
      advisory_executed_actions: advisoryExecutedActions,
      advisory_failed_actions: advisoryFailedActions,
      advisory_skipped_actions: advisorySkippedActions,
      advisory_actions: advisoryActions
    });

    if (roundResult.summary.failed_actions > 0) {
      stopReason = 'maintenance-action-failed';
      break;
    }
    if (executeAdvisory && advisoryFailedActions > 0) {
      stopReason = 'advisory-action-failed';
      break;
    }
    if (planOnly || dryRun) {
      stopReason = 'non-mutating-mode';
      break;
    }
    if (compareRiskLevel(effectiveAfterAssessment.health.risk_level, targetRisk) <= 0) {
      converged = true;
      stopReason = 'target-risk-reached';
      break;
    }
    if (
      roundResult.summary.applicable_actions === 0 &&
      !(executeAdvisory && (advisoryExecutedActions > 0 || advisoryFailedActions > 0))
    ) {
      stopReason = 'no-applicable-actions';
      break;
    }

    await persistGovernanceState('running');
  }

  if (!initialAssessment || !finalAssessment) {
    throw new Error('Governance close-loop did not produce any assessment.');
  }

  const result = buildGovernanceCloseLoopResult();
  if (governanceSessionEnabled) {
    const persistedSession = await persistGovernanceCloseLoopSession(
      projectPath,
      governanceSessionId,
      result,
      resolveGovernanceCloseLoopRunStatus(stopReason, converged)
    );
    if (persistedSession && persistedSession.id) {
      governanceSessionId = persistedSession.id;
    }
  }
  if (governanceSessionKeep !== null) {
    governanceSessionPrune = await pruneGovernanceCloseLoopSessions(projectPath, {
      keep: governanceSessionKeep,
      olderThanDays: governanceSessionOlderThanDays,
      dryRun,
      currentFile: governanceSessionEnabled
        ? path.join(getGovernanceCloseLoopSessionDir(projectPath), `${governanceSessionId}.json`)
        : null
    });
    result.governance_session_prune = governanceSessionPrune;
  }
  return result;
}

async function pruneCloseLoopBatchSummarySessionsCli(projectPath, options = {}) {
  const keep = normalizeKeep(options.keep);
  const olderThanDays = normalizeOlderThanDays(options.olderThanDays);
  const dryRun = Boolean(options.dryRun);
  const result = await pruneCloseLoopBatchSummarySessions(projectPath, {
    keep,
    olderThanDays,
    currentFile: null,
    dryRun
  });

  return {
    mode: 'auto-batch-session-prune',
    ...result
  };
}

async function pruneCloseLoopControllerSessionsCli(projectPath, options = {}) {
  const keep = normalizeKeep(options.keep);
  const olderThanDays = normalizeOlderThanDays(options.olderThanDays);
  const dryRun = Boolean(options.dryRun);
  const result = await pruneCloseLoopControllerSessions(projectPath, {
    keep,
    olderThanDays,
    currentFile: null,
    dryRun
  });

  return {
    mode: 'auto-controller-session-prune',
    ...result
  };
}

async function pruneCloseLoopSessions(projectPath, options = {}) {
  const keep = normalizeKeep(options.keep);
  const olderThanDays = normalizeOlderThanDays(options.olderThanDays);
  const dryRun = Boolean(options.dryRun);
  const sessions = await readCloseLoopSessionEntries(projectPath);
  const cutoffMs = olderThanDays === null
    ? null
    : Date.now() - (olderThanDays * 24 * 60 * 60 * 1000);

  const keepSet = new Set(
    sessions.slice(0, keep).map(session => session.file)
  );
  const deletable = sessions.filter(session => {
    if (keepSet.has(session.file)) {
      return false;
    }
    if (cutoffMs === null) {
      return true;
    }
    return session.mtime_ms < cutoffMs;
  });

  const deleted = [];
  const errors = [];
  if (!dryRun) {
    for (const session of deletable) {
      try {
        await fs.remove(session.file);
        deleted.push(session);
      } catch (error) {
        errors.push({
          id: session.id,
          file: session.file,
          error: error.message
        });
      }
    }
  }

  return {
    mode: 'auto-session-prune',
    session_dir: getCloseLoopSessionDir(projectPath),
    dry_run: dryRun,
    criteria: {
      keep,
      older_than_days: olderThanDays
    },
    total_sessions: sessions.length,
    kept_sessions: sessions.length - deletable.length,
    deleted_count: dryRun ? deletable.length : deleted.length,
    candidates: deletable.map(item => ({
      id: item.id,
      file: item.file,
      status: item.status,
      updated_at: item.updated_at
    })),
    errors
  };
}

module.exports = {
  registerAutoCommands,
  listCloseLoopSessions,
  pruneCloseLoopSessions,
  listCloseLoopBatchSummarySessions,
  pruneCloseLoopBatchSummarySessionsCli,
  loadCloseLoopBatchGoals,
  loadCloseLoopBatchGoalsFromSummary
};
