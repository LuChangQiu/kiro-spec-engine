name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node-version: [16.x, 18.x, 20.x, 22.x]
        exclude:
          - os: macos-latest
            node-version: 16.x
          - os: macos-latest
            node-version: 18.x
          - os: macos-latest
            node-version: 20.x
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run tests
        run: npm test
      
      - name: Check coverage
        if: matrix.os == 'ubuntu-latest' && matrix.node-version == '20.x'
        run: npm run coverage -- --runInBand

  publish:
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20.x'
          registry-url: 'https://registry.npmjs.org'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci

      - name: Resolve previous Moqui baseline asset
        id: moqui_baseline_prev
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF_NAME}"
          NOTES_DIR=".kiro/reports/release-evidence"
          LATEST_RELEASE_FILE="${NOTES_DIR}/latest-release-${TAG}.json"
          PREVIOUS_BASELINE_FILE="${NOTES_DIR}/moqui-template-baseline-prev-${TAG}.json"
          LATEST_RELEASE_API="https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/latest"

          mkdir -p "${NOTES_DIR}"
          echo "previous_file=" >> "$GITHUB_OUTPUT"

          if curl -fsSL \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            "${LATEST_RELEASE_API}" \
            -o "${LATEST_RELEASE_FILE}"; then
            BASELINE_ASSET_URL="$(node -e "const fs=require('fs');const payload=JSON.parse(fs.readFileSync(process.argv[1],'utf8'));const assets=Array.isArray(payload.assets)?payload.assets:[];const hit=assets.find(item=>item&&item.name==='moqui-template-baseline.json');if(hit&&hit.url){process.stdout.write(hit.url);}" "${LATEST_RELEASE_FILE}")"
            if [[ -n "${BASELINE_ASSET_URL}" ]]; then
              if curl -fsSL \
                -H "Authorization: Bearer ${GITHUB_TOKEN}" \
                -H "Accept: application/octet-stream" \
                "${BASELINE_ASSET_URL}" \
                -o "${PREVIOUS_BASELINE_FILE}"; then
                echo "previous_file=${PREVIOUS_BASELINE_FILE}" >> "$GITHUB_OUTPUT"
              fi
            fi
          fi
          rm -f "${LATEST_RELEASE_FILE}"

      - name: Build Moqui template baseline scorecard
        id: moqui_baseline
        shell: bash
        env:
          PREVIOUS_MOQUI_BASELINE_FILE: ${{ steps.moqui_baseline_prev.outputs.previous_file }}
          MOQUI_BASELINE_ENFORCE: ${{ vars.KSE_MOQUI_BASELINE_ENFORCE }}
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF_NAME}"
          NOTES_DIR=".kiro/reports/release-evidence"
          BASELINE_JSON="${NOTES_DIR}/moqui-template-baseline.json"
          BASELINE_MD="${NOTES_DIR}/moqui-template-baseline.md"
          BASELINE_STDOUT="${NOTES_DIR}/moqui-template-baseline-${TAG}.stdout.json"

          mkdir -p "${NOTES_DIR}"

          BASELINE_ENFORCE_RAW="${MOQUI_BASELINE_ENFORCE:-true}"
          BASELINE_ENFORCE_NORMALIZED="$(printf '%s' "${BASELINE_ENFORCE_RAW}" | tr '[:upper:]' '[:lower:]')"
          BASELINE_FAIL_FLAG=""
          if [[ -z "${BASELINE_ENFORCE_NORMALIZED}" || "${BASELINE_ENFORCE_NORMALIZED}" == "1" || "${BASELINE_ENFORCE_NORMALIZED}" == "true" || "${BASELINE_ENFORCE_NORMALIZED}" == "yes" || "${BASELINE_ENFORCE_NORMALIZED}" == "y" || "${BASELINE_ENFORCE_NORMALIZED}" == "on" ]]; then
            BASELINE_FAIL_FLAG="--fail-on-portfolio-fail"
            echo "[moqui-baseline] mode=enforce"
          else
            echo "[moqui-baseline] mode=advisory"
          fi

          if [[ -n "${PREVIOUS_MOQUI_BASELINE_FILE}" && -f "${PREVIOUS_MOQUI_BASELINE_FILE}" ]]; then
            node scripts/moqui-template-baseline-report.js \
              --out "${BASELINE_JSON}" \
              --markdown-out "${BASELINE_MD}" \
              --compare-with "${PREVIOUS_MOQUI_BASELINE_FILE}" \
              ${BASELINE_FAIL_FLAG} \
              --json > "${BASELINE_STDOUT}"
          else
            node scripts/moqui-template-baseline-report.js \
              --out "${BASELINE_JSON}" \
              --markdown-out "${BASELINE_MD}" \
              ${BASELINE_FAIL_FLAG} \
              --json > "${BASELINE_STDOUT}"
          fi

          cat "${BASELINE_STDOUT}"
          rm -f "${BASELINE_STDOUT}"
          echo "json_file=${BASELINE_JSON}" >> "$GITHUB_OUTPUT"
          echo "markdown_file=${BASELINE_MD}" >> "$GITHUB_OUTPUT"

      - name: Run Moqui core regression suite
        id: moqui_core_regression
        shell: bash
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF_NAME}"
          NOTES_DIR=".kiro/reports/release-evidence"
          REGRESSION_JSON="${NOTES_DIR}/moqui-core-regression-suite-${TAG}.json"
          REGRESSION_MD="${NOTES_DIR}/moqui-core-regression-suite-${TAG}.md"
          REGRESSION_STDOUT="${NOTES_DIR}/moqui-core-regression-suite-${TAG}.stdout.json"

          mkdir -p "${NOTES_DIR}"
          node scripts/moqui-core-regression-suite.js \
            --out "${REGRESSION_JSON}" \
            --markdown-out "${REGRESSION_MD}" \
            --json > "${REGRESSION_STDOUT}"
          cat "${REGRESSION_STDOUT}"
          rm -f "${REGRESSION_STDOUT}"
          echo "json_file=${REGRESSION_JSON}" >> "$GITHUB_OUTPUT"
          echo "markdown_file=${REGRESSION_MD}" >> "$GITHUB_OUTPUT"

      - name: Build release evidence notes
        id: release_notes
        shell: bash
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF_NAME}"
          RELEASE_DATE="$(date -u +%F)"
          NOTES_DIR=".kiro/reports/release-evidence"
          EVIDENCE_FILE="${NOTES_DIR}/handoff-runs.json"
          REVIEW_FILE="${NOTES_DIR}/handoff-evidence-review-${TAG}.md"
          DRAFT_FILE="${NOTES_DIR}/release-notes-${TAG}.md"
          FALLBACK_FILE="${NOTES_DIR}/release-notes-fallback-${TAG}.md"
          SUMMARY_FILE="${NOTES_DIR}/release-evidence-summary-${TAG}.json"
          GATE_FILE="${NOTES_DIR}/release-gate-${TAG}.json"
          HISTORY_FILE="${NOTES_DIR}/release-gate-history.json"
          HISTORY_SUMMARY_FILE="${NOTES_DIR}/release-gate-history-${TAG}.json"
          HISTORY_CARD_FILE="${NOTES_DIR}/release-gate-history-${TAG}.md"

          mkdir -p "${NOTES_DIR}"

          if [[ -f "${EVIDENCE_FILE}" ]]; then
            if node bin/sce.js auto handoff evidence \
              --file "${EVIDENCE_FILE}" \
              --review-out "${REVIEW_FILE}" \
              --release-draft "${DRAFT_FILE}" \
              --release-version "${TAG}" \
              --release-date "${RELEASE_DATE}" \
              --json > "${SUMMARY_FILE}"; then
              if [[ -f "${DRAFT_FILE}" ]]; then
                echo "release_body_file=${DRAFT_FILE}" >> "$GITHUB_OUTPUT"
                echo "summary_file=${SUMMARY_FILE}" >> "$GITHUB_OUTPUT"
                echo "gate_file=${GATE_FILE}" >> "$GITHUB_OUTPUT"
                echo "evidence_used=true" >> "$GITHUB_OUTPUT"
                {
                  echo "asset_files<<EOF"
                  echo "${DRAFT_FILE}"
                  if [[ -f "${REVIEW_FILE}" ]]; then
                    echo "${REVIEW_FILE}"
                  fi
                  if [[ -f "${SUMMARY_FILE}" ]]; then
                    echo "${SUMMARY_FILE}"
                  fi
                  echo "${GATE_FILE}"
                  echo "${HISTORY_FILE}"
                  echo "${HISTORY_SUMMARY_FILE}"
                  echo "${HISTORY_CARD_FILE}"
                  echo "EOF"
                } >> "$GITHUB_OUTPUT"
                exit 0
              fi
            fi
          fi

          printf '%s\n' \
            "# Release ${TAG}" \
            "" \
            "Release date: ${RELEASE_DATE}" \
            "" \
            "See [CHANGELOG.md](https://github.com/${GITHUB_REPOSITORY}/blob/main/CHANGELOG.md) for details." \
            > "${FALLBACK_FILE}"
          echo "release_body_file=${FALLBACK_FILE}" >> "$GITHUB_OUTPUT"
          echo "summary_file=" >> "$GITHUB_OUTPUT"
          echo "gate_file=${GATE_FILE}" >> "$GITHUB_OUTPUT"
          echo "evidence_used=false" >> "$GITHUB_OUTPUT"
          {
            echo "asset_files<<EOF"
            echo "${FALLBACK_FILE}"
            echo "${GATE_FILE}"
            echo "${HISTORY_FILE}"
            echo "${HISTORY_SUMMARY_FILE}"
            echo "${HISTORY_CARD_FILE}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Evaluate release evidence gate
        shell: bash
        env:
          RELEASE_GATE_ENFORCE: ${{ vars.KSE_RELEASE_GATE_ENFORCE }}
          RELEASE_GATE_REQUIRE_EVIDENCE: ${{ vars.KSE_RELEASE_GATE_REQUIRE_EVIDENCE }}
          RELEASE_GATE_REQUIRE_GATE_PASS: ${{ vars.KSE_RELEASE_GATE_REQUIRE_GATE_PASS }}
          RELEASE_GATE_MIN_SPEC_SUCCESS_RATE: ${{ vars.KSE_RELEASE_GATE_MIN_SPEC_SUCCESS_RATE }}
          RELEASE_GATE_MAX_RISK_LEVEL: ${{ vars.KSE_RELEASE_GATE_MAX_RISK_LEVEL }}
          RELEASE_GATE_MAX_UNMAPPED_RULES: ${{ vars.KSE_RELEASE_GATE_MAX_UNMAPPED_RULES }}
          RELEASE_GATE_MAX_UNDECIDED_DECISIONS: ${{ vars.KSE_RELEASE_GATE_MAX_UNDECIDED_DECISIONS }}
          RELEASE_GATE_REQUIRE_SCENE_BATCH_PASS: ${{ vars.KSE_RELEASE_GATE_REQUIRE_SCENE_BATCH_PASS }}
          RELEASE_GATE_MAX_SCENE_BATCH_FAILURES: ${{ vars.KSE_RELEASE_GATE_MAX_SCENE_BATCH_FAILURES }}
          RELEASE_EVIDENCE_SUMMARY_FILE: ${{ steps.release_notes.outputs.summary_file }}
          RELEASE_EVIDENCE_USED: ${{ steps.release_notes.outputs.evidence_used }}
          RELEASE_GATE_REPORT_FILE: ${{ steps.release_notes.outputs.gate_file }}
        run: |
          set -euo pipefail
          node <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const configWarnings = [];

          function read(name, fallback = '') {
            const value = process.env[name];
            return value === undefined || value === null ? fallback : `${value}`.trim();
          }

          function parseBoolean(name, fallback) {
            const raw = read(name, '');
            if (!raw) return fallback;
            const lowered = raw.toLowerCase();
            if (['1', 'true', 'yes', 'y', 'on'].includes(lowered)) return true;
            if (['0', 'false', 'no', 'n', 'off'].includes(lowered)) return false;
            configWarnings.push(`invalid boolean ${name}=${raw}, fallback=${fallback}`);
            return fallback;
          }

          function parseNumber(name, fallback) {
            const raw = read(name, '');
            if (!raw) return fallback;
            const parsed = Number(raw);
            if (!Number.isFinite(parsed)) {
              configWarnings.push(`invalid number ${name}=${raw}, fallback=${fallback}`);
              return fallback;
            }
            return parsed;
          }

          function parseRiskLevel(name, fallback) {
            const raw = read(name, '').toLowerCase();
            if (!raw) return fallback;
            if (['low', 'medium', 'high', 'unknown'].includes(raw)) {
              return raw;
            }
            configWarnings.push(`invalid risk level ${name}=${raw}, fallback=${fallback}`);
            return fallback;
          }

          function riskRank(level) {
            const normalized = `${level || 'unknown'}`.trim().toLowerCase();
            const ranking = {
              low: 1,
              medium: 2,
              high: 3,
              unknown: 4
            };
            return ranking[normalized] || 5;
          }

          const enforce = parseBoolean('RELEASE_GATE_ENFORCE', false);
          const requireEvidence = parseBoolean('RELEASE_GATE_REQUIRE_EVIDENCE', false);
          const requireGatePass = parseBoolean('RELEASE_GATE_REQUIRE_GATE_PASS', true);
          const minSpecSuccessRate = parseNumber('RELEASE_GATE_MIN_SPEC_SUCCESS_RATE', 0);
          const maxRiskLevel = parseRiskLevel('RELEASE_GATE_MAX_RISK_LEVEL', 'unknown');
          const maxUnmappedRules = parseNumber('RELEASE_GATE_MAX_UNMAPPED_RULES', Number.POSITIVE_INFINITY);
          const maxUndecidedDecisions = parseNumber('RELEASE_GATE_MAX_UNDECIDED_DECISIONS', Number.POSITIVE_INFINITY);
          const requireSceneBatchPass = parseBoolean('RELEASE_GATE_REQUIRE_SCENE_BATCH_PASS', true);
          const maxSceneBatchFailures = parseNumber('RELEASE_GATE_MAX_SCENE_BATCH_FAILURES', 0);
          const evidenceUsed = parseBoolean('RELEASE_EVIDENCE_USED', false);
          const summaryFile = read('RELEASE_EVIDENCE_SUMMARY_FILE', '');
          const gateReportFile = read('RELEASE_GATE_REPORT_FILE', '');

          const violations = [];
          const signals = [];

          if (!summaryFile || !fs.existsSync(summaryFile)) {
            signals.push('summary=missing');
            if (requireEvidence) {
              violations.push('release evidence summary is required but missing');
            }
          } else {
            try {
              const raw = fs.readFileSync(summaryFile, 'utf8');
              const gatePayload = JSON.parse(raw);
              const currentOverview = gatePayload && gatePayload.current_overview && typeof gatePayload.current_overview === 'object'
                ? gatePayload.current_overview
                : {};
              const gate = currentOverview.gate && typeof currentOverview.gate === 'object'
                ? currentOverview.gate
                : {};
              const gateActual = gate.actual && typeof gate.actual === 'object'
                ? gate.actual
                : {};
              const ontology = currentOverview.ontology_validation && typeof currentOverview.ontology_validation === 'object'
                ? currentOverview.ontology_validation
                : {};
              const ontologyMetrics = ontology.metrics && typeof ontology.metrics === 'object'
                ? ontology.metrics
                : {};
              const scenePackageBatch = currentOverview.scene_package_batch && typeof currentOverview.scene_package_batch === 'object'
                ? currentOverview.scene_package_batch
                : {};
              const scenePackageBatchSummary = scenePackageBatch.summary && typeof scenePackageBatch.summary === 'object'
                ? scenePackageBatch.summary
                : {};

              const gatePassed = gate.passed === true;
              const specSuccessRate = Number(gateActual.spec_success_rate_percent);
              const riskLevel = `${gateActual.risk_level || 'unknown'}`.toLowerCase();
              const unmappedRules = Number.isFinite(Number(gateActual.ontology_business_rule_unmapped))
                ? Number(gateActual.ontology_business_rule_unmapped)
                : Number(ontologyMetrics.business_rule_unmapped);
              const undecidedDecisions = Number.isFinite(Number(gateActual.ontology_decision_undecided))
                ? Number(gateActual.ontology_decision_undecided)
                : Number(ontologyMetrics.decision_undecided);
              const sceneBatchStatusRaw = `${scenePackageBatch.status || gateActual.scene_package_batch_status || ''}`.trim().toLowerCase();
              const sceneBatchStatus = sceneBatchStatusRaw || 'unknown';
              let sceneBatchPassed = null;
              if (typeof gateActual.scene_package_batch_passed === 'boolean') {
                sceneBatchPassed = gateActual.scene_package_batch_passed;
              } else if (sceneBatchStatus === 'passed') {
                sceneBatchPassed = true;
              } else if (sceneBatchStatus === 'failed') {
                sceneBatchPassed = false;
              }
              const sceneBatchFailureCount = Number.isFinite(Number(scenePackageBatchSummary.batch_gate_failure_count))
                ? Number(scenePackageBatchSummary.batch_gate_failure_count)
                : (
                  Number.isFinite(Number(scenePackageBatchSummary.failed))
                    ? Number(scenePackageBatchSummary.failed)
                    : null
                );

              signals.push(`summary=${summaryFile}`);
              signals.push(`gate_passed=${gatePassed}`);
              signals.push(`spec_success_rate=${Number.isFinite(specSuccessRate) ? specSuccessRate : 'n/a'}`);
              signals.push(`risk_level=${riskLevel || 'unknown'}`);
              signals.push(`unmapped_rules=${Number.isFinite(unmappedRules) ? unmappedRules : 'n/a'}`);
              signals.push(`undecided_decisions=${Number.isFinite(undecidedDecisions) ? undecidedDecisions : 'n/a'}`);
              signals.push(`scene_package_batch_status=${sceneBatchStatus}`);
              signals.push(`scene_package_batch_passed=${sceneBatchPassed === null ? 'n/a' : sceneBatchPassed}`);
              signals.push(`scene_package_batch_failure_count=${sceneBatchFailureCount === null ? 'n/a' : sceneBatchFailureCount}`);

              if (requireGatePass && !gatePassed) {
                violations.push('handoff gate is not passed');
              }
              if (Number.isFinite(specSuccessRate) && specSuccessRate < minSpecSuccessRate) {
                violations.push(`spec success rate ${specSuccessRate} < min ${minSpecSuccessRate}`);
              }
              if (riskRank(riskLevel) > riskRank(maxRiskLevel)) {
                violations.push(`risk level ${riskLevel} exceeds max ${maxRiskLevel}`);
              }
              if (Number.isFinite(unmappedRules) && unmappedRules > maxUnmappedRules) {
                violations.push(`ontology unmapped rules ${unmappedRules} > max ${maxUnmappedRules}`);
              }
              if (Number.isFinite(undecidedDecisions) && undecidedDecisions > maxUndecidedDecisions) {
                violations.push(`ontology undecided decisions ${undecidedDecisions} > max ${maxUndecidedDecisions}`);
              }
              if (requireSceneBatchPass) {
                if (sceneBatchPassed !== true) {
                  violations.push(`scene package batch status ${sceneBatchStatus} is not passed`);
                }
              }
              if (Number.isFinite(sceneBatchFailureCount) && sceneBatchFailureCount > maxSceneBatchFailures) {
                violations.push(`scene package batch failure count ${sceneBatchFailureCount} > max ${maxSceneBatchFailures}`);
              }
            } catch (error) {
              signals.push(`summary=parse_error:${error.message}`);
              violations.push(`release evidence summary parse failed: ${error.message}`);
            }
          }

          const mode = enforce ? 'enforce' : 'advisory';
          const header = `[release-gate] mode=${mode} evidence_used=${evidenceUsed} require_evidence=${requireEvidence}`;
          console.log(header);
          signals.forEach((line) => console.log(`[release-gate] ${line}`));
          configWarnings.forEach((line) => console.log(`[release-gate] warning=${line}`));

          if (gateReportFile) {
            const reportPayload = {
              mode,
              enforce,
              evidence_used: evidenceUsed,
              require_evidence: requireEvidence,
              require_gate_pass: requireGatePass,
              thresholds: {
                min_spec_success_rate: minSpecSuccessRate,
                max_risk_level: maxRiskLevel,
                max_unmapped_rules: Number.isFinite(maxUnmappedRules) ? maxUnmappedRules : null,
                max_undecided_decisions: Number.isFinite(maxUndecidedDecisions) ? maxUndecidedDecisions : null,
                require_scene_batch_pass: requireSceneBatchPass,
                max_scene_batch_failures: Number.isFinite(maxSceneBatchFailures) ? maxSceneBatchFailures : null
              },
              summary_file: summaryFile || null,
              scene_package_batch_status: null,
              scene_package_batch_passed: null,
              scene_package_batch_failure_count: null,
              config_warnings: configWarnings,
              signals,
              violations,
              gate_passed: violations.length === 0,
              evaluated_at: new Date().toISOString()
            };
            const sceneStatusSignal = signals.find((item) => item.startsWith('scene_package_batch_status='));
            const scenePassedSignal = signals.find((item) => item.startsWith('scene_package_batch_passed='));
            const sceneFailureSignal = signals.find((item) => item.startsWith('scene_package_batch_failure_count='));
            if (sceneStatusSignal) {
              reportPayload.scene_package_batch_status = sceneStatusSignal.replace('scene_package_batch_status=', '') || null;
            }
            if (scenePassedSignal) {
              const raw = scenePassedSignal.replace('scene_package_batch_passed=', '').trim().toLowerCase();
              if (raw === 'true') {
                reportPayload.scene_package_batch_passed = true;
              } else if (raw === 'false') {
                reportPayload.scene_package_batch_passed = false;
              }
            }
            if (sceneFailureSignal) {
              const parsed = Number(sceneFailureSignal.replace('scene_package_batch_failure_count=', '').trim());
              if (Number.isFinite(parsed)) {
                reportPayload.scene_package_batch_failure_count = parsed;
              }
            }
            fs.mkdirSync(path.dirname(gateReportFile), { recursive: true });
            fs.writeFileSync(gateReportFile, `${JSON.stringify(reportPayload, null, 2)}\n`, 'utf8');
            console.log(`[release-gate] report_file=${gateReportFile}`);
          }

          const summaryPath = process.env.GITHUB_STEP_SUMMARY;
          if (summaryPath) {
            const lines = [
              '## Release Evidence Gate',
              '',
              `- mode: ${mode}`,
              `- evidence used: ${evidenceUsed}`,
              `- require evidence: ${requireEvidence}`,
              `- require gate pass: ${requireGatePass}`,
              `- min spec success rate: ${minSpecSuccessRate}`,
              `- max risk level: ${maxRiskLevel}`,
              `- max unmapped rules: ${Number.isFinite(maxUnmappedRules) ? maxUnmappedRules : 'inf'}`,
              `- max undecided decisions: ${Number.isFinite(maxUndecidedDecisions) ? maxUndecidedDecisions : 'inf'}`,
              `- require scene batch pass: ${requireSceneBatchPass}`,
              `- max scene batch failures: ${Number.isFinite(maxSceneBatchFailures) ? maxSceneBatchFailures : 'inf'}`
            ];
            if (configWarnings.length > 0) {
              lines.push('', '### Config Warnings');
              for (const warning of configWarnings) {
                lines.push(`- ${warning}`);
              }
            }
            if (signals.length > 0) {
              lines.push('', '### Observed Signals');
              for (const signal of signals) {
                lines.push(`- ${signal}`);
              }
            }
            if (violations.length > 0) {
              lines.push('', '### Violations');
              for (const violation of violations) {
                lines.push(`- ${violation}`);
              }
            } else {
              lines.push('', '### Result');
              lines.push('- gate passed');
            }
            fs.appendFileSync(summaryPath, `${lines.join('\n')}\n`);
          }

          if (violations.length > 0) {
            const message = `[release-gate] violations: ${violations.join('; ')}`;
            if (enforce) {
              console.error(message);
              process.exit(1);
            }
            console.warn(`${message} (advisory only)`);
          }
          NODE

      - name: Build release gate history index
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF_NAME}"
          NOTES_DIR=".kiro/reports/release-evidence"
          HISTORY_FILE="${NOTES_DIR}/release-gate-history.json"
          HISTORY_SUMMARY_FILE="${NOTES_DIR}/release-gate-history-${TAG}.json"
          HISTORY_CARD_FILE="${NOTES_DIR}/release-gate-history-${TAG}.md"
          LATEST_RELEASE_FILE="${NOTES_DIR}/latest-release-${TAG}.json"
          LATEST_RELEASE_API="https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/latest"

          mkdir -p "${NOTES_DIR}"
          if curl -fsSL \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            "${LATEST_RELEASE_API}" \
            -o "${LATEST_RELEASE_FILE}"; then
            HISTORY_ASSET_URL="$(node -e "const fs=require('fs');const payload=JSON.parse(fs.readFileSync(process.argv[1],'utf8'));const assets=Array.isArray(payload.assets)?payload.assets:[];const hit=assets.find(item=>item&&item.name==='release-gate-history.json');if(hit&&hit.url){process.stdout.write(hit.url);}" "${LATEST_RELEASE_FILE}")"
            if [[ -n "${HISTORY_ASSET_URL}" ]]; then
              curl -fsSL \
                -H "Authorization: Bearer ${GITHUB_TOKEN}" \
                -H "Accept: application/octet-stream" \
                "${HISTORY_ASSET_URL}" \
                -o "${HISTORY_FILE}" || true
            fi
          fi
          rm -f "${LATEST_RELEASE_FILE}"

          if ! node bin/sce.js auto handoff gate-index \
            --dir "${NOTES_DIR}" \
            --history-file "${HISTORY_FILE}" \
            --out "${HISTORY_FILE}" \
            --markdown-out "${HISTORY_CARD_FILE}" \
            --json > "${HISTORY_SUMMARY_FILE}"; then
            printf '%s\n' \
              '{' \
              '  "mode": "auto-handoff-release-gate-history",' \
              '  "error": "failed to build release gate history index"' \
              '}' > "${HISTORY_SUMMARY_FILE}"
            printf '%s\n' \
              '# Release Gate History' \
              '' \
              'Failed to build release gate history markdown.' > "${HISTORY_CARD_FILE}"
            if [[ ! -f "${HISTORY_FILE}" ]]; then
              printf '%s\n' \
                '{' \
                '  "mode": "auto-handoff-release-gate-history",' \
                '  "entries": []' \
                '}' > "${HISTORY_FILE}"
            fi
          fi

      - name: Append release gate trend summary
        shell: bash
        env:
          RELEASE_BODY_FILE: ${{ steps.release_notes.outputs.release_body_file }}
          RELEASE_TAG: ${{ github.ref_name }}
          RELEASE_REPOSITORY: ${{ github.repository }}
          RELEASE_DRIFT_FAIL_STREAK_MIN: ${{ vars.KSE_RELEASE_DRIFT_FAIL_STREAK_MIN }}
          RELEASE_DRIFT_HIGH_RISK_SHARE_MIN_PERCENT: ${{ vars.KSE_RELEASE_DRIFT_HIGH_RISK_SHARE_MIN_PERCENT }}
          RELEASE_DRIFT_HIGH_RISK_SHARE_DELTA_MIN_PERCENT: ${{ vars.KSE_RELEASE_DRIFT_HIGH_RISK_SHARE_DELTA_MIN_PERCENT }}
          RELEASE_DRIFT_PREFLIGHT_BLOCK_RATE_MIN_PERCENT: ${{ vars.KSE_RELEASE_DRIFT_PREFLIGHT_BLOCK_RATE_MIN_PERCENT }}
          RELEASE_DRIFT_HARD_GATE_BLOCK_STREAK_MIN: ${{ vars.KSE_RELEASE_DRIFT_HARD_GATE_BLOCK_STREAK_MIN }}
          RELEASE_DRIFT_PREFLIGHT_UNAVAILABLE_STREAK_MIN: ${{ vars.KSE_RELEASE_DRIFT_PREFLIGHT_UNAVAILABLE_STREAK_MIN }}
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF_NAME}"
          NOTES_DIR=".kiro/reports/release-evidence"
          HISTORY_SUMMARY_FILE="${NOTES_DIR}/release-gate-history-${TAG}.json"

          if [[ -f "${RELEASE_BODY_FILE}" && -f "${HISTORY_SUMMARY_FILE}" ]]; then
            RELEASE_HISTORY_SUMMARY_FILE="${HISTORY_SUMMARY_FILE}" \
              node <<'NODE'
              const fs = require('fs');

              const bodyFile = process.env.RELEASE_BODY_FILE;
              const historyFile = process.env.RELEASE_HISTORY_SUMMARY_FILE;
              if (!bodyFile || !historyFile) {
                process.exit(0);
              }
              if (!fs.existsSync(bodyFile) || !fs.existsSync(historyFile)) {
                process.exit(0);
              }

              let payload = null;
              try {
                payload = JSON.parse(fs.readFileSync(historyFile, 'utf8'));
              } catch (_error) {
                process.exit(0);
              }
              if (!payload || typeof payload !== 'object') {
                process.exit(0);
              }

              const passRate = payload.aggregates && Number.isFinite(Number(payload.aggregates.pass_rate_percent))
                ? Number(payload.aggregates.pass_rate_percent)
                : null;
              const sceneBatchPassRate = payload.aggregates && Number.isFinite(Number(payload.aggregates.scene_package_batch_pass_rate_percent))
                ? Number(payload.aggregates.scene_package_batch_pass_rate_percent)
                : null;
              const sceneBatchFailedCount = payload.aggregates && Number.isFinite(Number(payload.aggregates.scene_package_batch_failed_count))
                ? Number(payload.aggregates.scene_package_batch_failed_count)
                : null;
              const capabilityExpectedUnknownRateHistory = payload.aggregates && Number.isFinite(Number(payload.aggregates.capability_expected_unknown_positive_rate_percent))
                ? Number(payload.aggregates.capability_expected_unknown_positive_rate_percent)
                : null;
              const capabilityProvidedUnknownRateHistory = payload.aggregates && Number.isFinite(Number(payload.aggregates.capability_provided_unknown_positive_rate_percent))
                ? Number(payload.aggregates.capability_provided_unknown_positive_rate_percent)
                : null;
              const preflightAvailabilityRateHistory = payload.aggregates && Number.isFinite(Number(payload.aggregates.release_gate_preflight_availability_rate_percent))
                ? Number(payload.aggregates.release_gate_preflight_availability_rate_percent)
                : null;
              const preflightBlockedRateHistory = payload.aggregates && Number.isFinite(Number(payload.aggregates.release_gate_preflight_block_rate_percent))
                ? Number(payload.aggregates.release_gate_preflight_block_rate_percent)
                : null;
              const {
                buildReleaseDriftSignals,
                resolveReleaseDriftThresholds
              } = require('./scripts/release-drift-signals');
              const thresholds = resolveReleaseDriftThresholds(process.env);
              const driftSignals = buildReleaseDriftSignals(payload, { thresholds });
              const {
                recent,
                recentPass,
                recentKnown,
                riskCounts,
                failedStreak,
                highRiskShare,
                highRiskDeltaPercent,
                recentPreflightKnown,
                recentPreflightBlocked,
                recentPreflightBlockedRate,
                hardGateBlockedStreak,
                preflightUnavailableStreak,
                recentCapabilityExpectedUnknownKnown,
                recentCapabilityExpectedUnknownPositive,
                recentCapabilityExpectedUnknownRate,
                recentCapabilityProvidedUnknownKnown,
                recentCapabilityProvidedUnknownPositive,
                recentCapabilityProvidedUnknownRate,
                alerts: driftAlerts
              } = driftSignals;
              const failStreakThreshold = thresholds.failStreakMin;
              const highRiskShareThreshold = thresholds.highRiskShareMinPercent;
              const highRiskDeltaThreshold = thresholds.highRiskShareDeltaMinPercent;
              const preflightBlockRateThreshold = thresholds.preflightBlockRateMinPercent;
              const hardGateBlockedStreakThreshold = thresholds.hardGateBlockStreakMin;
              const preflightUnavailableStreakThreshold = thresholds.preflightUnavailableStreakMin;
              const capabilityExpectedUnknownRateThreshold = thresholds.capabilityExpectedUnknownRateMinPercent;
              const capabilityProvidedUnknownRateThreshold = thresholds.capabilityProvidedUnknownRateMinPercent;
              const releaseTag = process.env.RELEASE_TAG || 'current';
              const releaseRepository = process.env.RELEASE_REPOSITORY || process.env.GITHUB_REPOSITORY || '';
              const historyCardAsset = `release-gate-history-${releaseTag}.md`;
              const historyJsonAsset = 'release-gate-history.json';
              const historySummaryAsset = `release-gate-history-${releaseTag}.json`;
              const toAssetUrl = (assetName) => {
                if (!releaseRepository || !releaseTag) {
                  return null;
                }
                return `https://github.com/${releaseRepository}/releases/download/${releaseTag}/${assetName}`;
              };
              const historyCardUrl = toAssetUrl(historyCardAsset);
              const historyJsonUrl = toAssetUrl(historyJsonAsset);
              const historySummaryUrl = toAssetUrl(historySummaryAsset);

              const lines = [
                '',
                '## Release Gate Trend',
                '',
                `- Indexed entries: ${Number(payload.total_entries) || 0}`,
                `- Gate pass rate (history): ${passRate === null ? 'n/a' : `${passRate}%`}`,
                `- Scene batch pass rate (history): ${sceneBatchPassRate === null ? 'n/a' : `${sceneBatchPassRate}%`}`,
                `- Scene batch failed runs (history): ${sceneBatchFailedCount === null ? 'n/a' : sceneBatchFailedCount}`,
                `- Capability expected unknown-positive rate (history): ${capabilityExpectedUnknownRateHistory === null ? 'n/a' : `${capabilityExpectedUnknownRateHistory}%`}`,
                `- Capability provided unknown-positive rate (history): ${capabilityProvidedUnknownRateHistory === null ? 'n/a' : `${capabilityProvidedUnknownRateHistory}%`}`,
                `- Release preflight availability rate (history): ${preflightAvailabilityRateHistory === null ? 'n/a' : `${preflightAvailabilityRateHistory}%`}`,
                `- Release preflight blocked rate (history): ${preflightBlockedRateHistory === null ? 'n/a' : `${preflightBlockedRateHistory}%`}`,
                `- Recent pass ratio (latest 5): ${recentKnown === 0 ? 'n/a' : `${recentPass}/${recentKnown}`}`,
                `- Recent risk mix (latest 5): low=${riskCounts.low}, medium=${riskCounts.medium}, high=${riskCounts.high}, unknown=${riskCounts.unknown}`,
                `- Recent capability expected unknown ratio (latest 5): ${recentCapabilityExpectedUnknownKnown === 0 ? 'n/a' : `${recentCapabilityExpectedUnknownPositive}/${recentCapabilityExpectedUnknownKnown} (${recentCapabilityExpectedUnknownRate}%)`}`,
                `- Recent capability provided unknown ratio (latest 5): ${recentCapabilityProvidedUnknownKnown === 0 ? 'n/a' : `${recentCapabilityProvidedUnknownPositive}/${recentCapabilityProvidedUnknownKnown} (${recentCapabilityProvidedUnknownRate}%)`}`,
                `- Recent preflight blocked ratio (latest 5): ${recentPreflightKnown === 0 ? 'n/a' : `${recentPreflightBlocked}/${recentPreflightKnown} (${recentPreflightBlockedRate}%)`}`,
                `- Hard-gate preflight blocked streak (latest 5): ${hardGateBlockedStreak}`,
                `- Preflight unavailable streak (latest 5): ${preflightUnavailableStreak}`,
                `- Trend card: ${historyCardUrl ? `[${historyCardAsset}](${historyCardUrl})` : historyCardAsset}`,
                `- History index: ${historyJsonUrl ? `[${historyJsonAsset}](${historyJsonUrl})` : historyJsonAsset}`,
                `- History summary: ${historySummaryUrl ? `[${historySummaryAsset}](${historySummaryUrl})` : historySummaryAsset}`,
                `- Drift thresholds: fail_streak>=${failStreakThreshold}, high_share>=${highRiskShareThreshold}%, high_share_delta>=${highRiskDeltaThreshold}%, preflight_block_rate>=${preflightBlockRateThreshold}%, hard_gate_block_streak>=${hardGateBlockedStreakThreshold}, preflight_unavailable_streak>=${preflightUnavailableStreakThreshold}, cap_expected_unknown_rate>=${capabilityExpectedUnknownRateThreshold}%, cap_provided_unknown_rate>=${capabilityProvidedUnknownRateThreshold}%`,
                '',
                '### Drift Alerts'
              ];

              if (driftAlerts.length === 0) {
                lines.push('', '- none');
              } else {
                for (const alert of driftAlerts) {
                  lines.push('', `- ${alert}`);
                }
              }

              lines.push(
                '',
                '### Recent Versions'
              );

              if (recent.length === 0) {
                lines.push('', '- none');
              } else {
                for (const item of recent) {
                  const tag = item && item.tag ? item.tag : 'n/a';
                  const passed = item && typeof item.gate_passed === 'boolean'
                    ? (item.gate_passed ? 'yes' : 'no')
                    : 'n/a';
                  const risk = item && item.risk_level ? item.risk_level : 'unknown';
                  const successRate = Number.isFinite(Number(item && item.spec_success_rate_percent))
                    ? `${Number(item.spec_success_rate_percent)}`
                    : 'n/a';
                  const sceneBatch = item && typeof item.scene_package_batch_passed === 'boolean'
                    ? (item.scene_package_batch_passed ? 'pass' : 'fail')
                    : 'n/a';
                  const sceneFailures = Number.isFinite(Number(item && item.scene_package_batch_failure_count))
                    ? `${Number(item.scene_package_batch_failure_count)}`
                    : 'n/a';
                  const capabilityExpectedUnknown = Number.isFinite(Number(item && item.capability_expected_unknown_count))
                    ? `${Number(item.capability_expected_unknown_count)}`
                    : 'n/a';
                  const capabilityProvidedUnknown = Number.isFinite(Number(item && item.capability_provided_unknown_count))
                    ? `${Number(item.capability_provided_unknown_count)}`
                    : 'n/a';
                  const preflightBlocked = item && typeof item.release_gate_preflight_blocked === 'boolean'
                    ? (item.release_gate_preflight_blocked ? 'yes' : 'no')
                    : 'n/a';
                  const hardGateMode = item && item.require_release_gate_preflight === true
                    ? 'enabled'
                    : (item && item.require_release_gate_preflight === false ? 'advisory' : 'n/a');
                  const evaluatedAt = item && item.evaluated_at ? item.evaluated_at : 'n/a';
                  lines.push(
                    '',
                    `- ${tag} | passed=${passed} | risk=${risk} | scene-batch=${sceneBatch} | ` +
                    `scene-failures=${sceneFailures} | capability-unknown=${capabilityExpectedUnknown}/${capabilityProvidedUnknown} | preflight-blocked=${preflightBlocked} | hard-gate=${hardGateMode} | success=${successRate} | at=${evaluatedAt}`
                  );
                }
              }

              fs.appendFileSync(bodyFile, `${lines.join('\n')}\n`, 'utf8');
          NODE
          fi

      - name: Evaluate release drift alerts
        shell: bash
        env:
          RELEASE_TAG: ${{ github.ref_name }}
          RELEASE_DRIFT_ENFORCE: ${{ vars.KSE_RELEASE_DRIFT_ENFORCE }}
          RELEASE_DRIFT_FAIL_STREAK_MIN: ${{ vars.KSE_RELEASE_DRIFT_FAIL_STREAK_MIN }}
          RELEASE_DRIFT_HIGH_RISK_SHARE_MIN_PERCENT: ${{ vars.KSE_RELEASE_DRIFT_HIGH_RISK_SHARE_MIN_PERCENT }}
          RELEASE_DRIFT_HIGH_RISK_SHARE_DELTA_MIN_PERCENT: ${{ vars.KSE_RELEASE_DRIFT_HIGH_RISK_SHARE_DELTA_MIN_PERCENT }}
          RELEASE_DRIFT_PREFLIGHT_BLOCK_RATE_MIN_PERCENT: ${{ vars.KSE_RELEASE_DRIFT_PREFLIGHT_BLOCK_RATE_MIN_PERCENT }}
          RELEASE_DRIFT_HARD_GATE_BLOCK_STREAK_MIN: ${{ vars.KSE_RELEASE_DRIFT_HARD_GATE_BLOCK_STREAK_MIN }}
          RELEASE_DRIFT_PREFLIGHT_UNAVAILABLE_STREAK_MIN: ${{ vars.KSE_RELEASE_DRIFT_PREFLIGHT_UNAVAILABLE_STREAK_MIN }}
          RELEASE_DRIFT_CAPABILITY_EXPECTED_UNKNOWN_RATE_MIN_PERCENT: ${{ vars.KSE_RELEASE_DRIFT_CAPABILITY_EXPECTED_UNKNOWN_RATE_MIN_PERCENT }}
          RELEASE_DRIFT_CAPABILITY_PROVIDED_UNKNOWN_RATE_MIN_PERCENT: ${{ vars.KSE_RELEASE_DRIFT_CAPABILITY_PROVIDED_UNKNOWN_RATE_MIN_PERCENT }}
          RELEASE_GATE_REPORT_FILE: ${{ steps.release_notes.outputs.gate_file }}
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF_NAME}"
          HISTORY_SUMMARY_FILE=".kiro/reports/release-evidence/release-gate-history-${TAG}.json"
          RELEASE_DRIFT_HISTORY_FILE="${HISTORY_SUMMARY_FILE}" \
            node ./scripts/release-drift-evaluate.js

      - name: Refresh release gate history index (post-drift)
        shell: bash
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF_NAME}"
          NOTES_DIR=".kiro/reports/release-evidence"
          GATE_FILE="${NOTES_DIR}/release-gate-${TAG}.json"
          HISTORY_FILE="${NOTES_DIR}/release-gate-history.json"
          HISTORY_SUMMARY_FILE="${NOTES_DIR}/release-gate-history-${TAG}.json"
          HISTORY_CARD_FILE="${NOTES_DIR}/release-gate-history-${TAG}.md"

          if [[ -f "${GATE_FILE}" ]]; then
            if ! node bin/sce.js auto handoff gate-index \
              --dir "${NOTES_DIR}" \
              --history-file "${HISTORY_FILE}" \
              --out "${HISTORY_FILE}" \
              --markdown-out "${HISTORY_CARD_FILE}" \
              --json > "${HISTORY_SUMMARY_FILE}"; then
              echo "[release-gate] warning: post-drift history refresh failed; keep previous gate-index artifacts"
            fi
          fi

      - name: Publish to npm
        run: npm publish --access public
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          body_path: ${{ steps.release_notes.outputs.release_body_file }}
          files: |
            ${{ steps.release_notes.outputs.asset_files }}
            ${{ steps.moqui_baseline.outputs.json_file }}
            ${{ steps.moqui_baseline.outputs.markdown_file }}
            ${{ steps.moqui_core_regression.outputs.json_file }}
            ${{ steps.moqui_core_regression.outputs.markdown_file }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
